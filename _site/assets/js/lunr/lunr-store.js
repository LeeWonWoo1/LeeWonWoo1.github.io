var store = [{
        "title": "[Github 블로그] Github Blog 시작!",
        "excerpt":"Github blog를 개설하는 과정을 간단하게 알아봅니다.   주의! Git의 사용법을 어느정도 숙지해야 합니다.   1. Github repository 생성  새 repository 이름을 [자신의 Github ID].github.io 로 설정한다.      2. Import code  원하는 Jekyll 테마를 선택하고 코드를 복사한다. Jekyll 테마를 모아둔 사이트는 다음과 같다.   Jekyll ? Ruby 언어로 만들어져 html, markdown 등의 텍스트를 가공하는 텍스트 변환 엔진    http://jekyllthemes.org/  http://themes.jekyllrc.org/  https://jekyllthemes.io/    나의 경우 minimal-mistakes 의 ‘dark’ 테마가 마음에 들어 선택했다.   코드를 복사한 뒤 생성한 [자신의 Github ID].github.io repository로 돌아와 import 한다.            이때 나와 같이 Import하지 않고 repository를 fork 하거나 파일을 Download해도 된다.   3. git clone  Import한 파일들을 작업하기 위해 vscode 터미널에서 clone한다.   $ git clone https://github.com/Github ID/Github ID.github.io.git   4. Rubby 설치  Jekyll을 설치하기 전에 Ruby를 설치한다.   Linux Ubuntu 환경   $ sudo apt-get install ruby-full $ ruby -v   설치가 잘 되었다면 cmd 창에 버전이 잘 출력될 것이다.       Windows 환경    Ruby 다운로드 사이트 에서 다운받아 설치한다.  설치 과정에서 \"Add Ruby executables to your PATH\" 에 체크하면 자동으로 환경변수 설정이 완료된다.   5. Jekyll, Bundler 설치  본인이 clone한 폴더로 들어가면 Gemfile 이라는 파일이 있을 것이다. cmd를 켜서 이 파일이 있는 경로로 들어간 후, 아래의 명령을 수행한다.   $ gem install jekyll bundler $ bundle $ jekyll -v   Jekyll이 잘 설치되었다면 cmd 창에 버전이 잘 출력될 것이다.  그 다음 아래의 명령어를 통해 로컬 환경에서 자신이 개발하는 블로그를 확인해 볼 수 있다.   $ jekyll serve   정상적으로 설치 되었다면 로컬서버 http://localhost:4000/  에서 확인하자.      6. 불필요한 파일 삭제  Github에 commit하기 전에 본인이 clone한 폴더에서 불필요한 파일을 삭제한다.      docs 폴더 : post 샘플이 들어가 있으므로 백업해 놓는다.  README.md : 다시 작성하기 위해 삭제했다.   7. Github 연동  수정된 사항들을 깃헙에 “add-commit-push” 하여 반영한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master    push가 완료되면 [자신의 Github ID].github.io 에서 블로그를 확인할 수 있다.  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/etc-startblog/",
        "teaser": null
      },{
        "title": "[Github 블로그] _config.yml 셋팅",
        "excerpt":"config 수정 공식 사이트   minimal-mistakes _config.yml 설정 공식 사이트    _config.yml 실행   vscode로 루트경로에 있는 _config.yml 을 열어주고 작업한다.  필요없는 부분은 제외하고 작성했다.   _config.yml 수정   minimal_mistakes_skin    : \"dark\" # \"air\", \"aqua\", \"contrast\", \"dark\", \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"  # 사이트 기본 세팅 locale                   : \"ko-KR\" title                    : \"LWW's Tech Blog\" # 타이틀 title_separator          : \"&amp;#124;\" # 구분자 subtitle                 : \"Version 1.0\" # 타이틀 하단 글씨 name                     : \"이원우\" # footer에 찍히는 이름 description              : \"꾸준히 기록하는 블로그\" # 설명 url                      : \"https://LeeWonWoo1.github.io\" # 호스트 주소 repository               : \"LeeWonWoo1/LeeWonWoo1.github.io\" # GitHub 유저이름 / 레포지 이름 teaser                   :  logo                     : # 타이틀 옆 이미지 masthead_title           : \"LWW's Tech Blog\" # 최 상단 타이틀 breadcrumbs              : true # 브래드크럼 사용 여부 words_per_minute         : 200   # 댓글 comments:   provider               : \"disqus\" #   disqus:     shortname            : LWW # disqus에 입력한 Web Site Name   discourse:     server               :   # 구글 Recaptcha reCaptcha:   siteKey                :   secret                 : atom_feed:   path                   :    hide                   :  search                   : true  search_full_content      : true   # Analytics analytics:   provider               : false    # Site Author author:   name             : \"이원우\"   avatar           : \"/assets/images/profile/bear.jpg\" # 프로필 이미지   bio              : \"CS / FrontEnd\"   location         : \"Republic of Korea\"   email            : \"plmplmdnjsdn@naver.com\"   links:     - label: \"Website\"       icon: \"fas fa-fw fa-link\"       url: \"https://LeeWonWoo1.github.io\"     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"   # Site Footer footer:   links:     - label: \"Email\"       icon: \"fab fa-fw fa-envelope-square\"       url: mailto:plmplmdnjsdn@naver.com     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"  # Post에 적용될 default 설정 defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: true       share: true       related: true       popular: false   수정하면서 종종 jekyll 서버로 확인한다.   $ jekyll serve   Github 연동  수정을 완료하면 Github에 연동한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/etc-blog-config/",
        "teaser": null
      },{
        "title": "[HTML] 글자와 상자",
        "excerpt":"글자와 상자   요소가 화면에 출력되는 특성. 크게 2가지로 구분됨.   인라인(Inline) 요소 : 글자를 만들기 위한 요소  블록(Block) 요소 : 상자(레이아웃)를 만들기 위한 요소   - Inline 요소   &lt;span&gt;Hello&lt;/span&gt; &lt;span&gt;World!!&lt;/span&gt;  Hello World!! -------------&gt; 요소가 수평으로 쌓임  가로는 포함한 콘텐츠 크기만큼 줄어듬 &lt;---&gt; &lt;-----&gt; Hello World!! ↕ 세로도 포함한 콘텐츠 크기만큼 줄어듬   span은 가장 대표적인 인라인 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Inline 요소는 가로, 세로 너비를 지정할 수 없음   &lt;span style=\"width: 100px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"height: 100px;\"&gt;World!!&lt;/span&gt;  Hello World!!  &lt;-- 반응 없음     외부, 내부 여백을 지정할 수 있지만, 상하 여백은 사용 불가   &lt;span style=\"margin: 20px 20px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"padding: 20px 20px;\"&gt;World!!&lt;/span&gt;  20px         20px   20px     20px &lt;--&gt;『Hello』&lt;--&gt; 『&lt;--&gt;World&lt;--&gt;』      &lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt;    &lt;!-- Inline 요소 안에 Block 요소 사용 불가 --&gt; &lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;  &lt;!-- Inline 요소 안에 Inline 요소 사용 가능 --&gt;       - Block 요소   &lt;div&gt;Hello&lt;/div&gt; &lt;div&gt;World!!&lt;/div&gt;  Hello     ↓ World!!   ↓  요소가 수직으로 쌓임  가로는 부모 요소의 크기만큼 늘어남 &lt;----------------------------------&gt; Hello                              ↕ World!!                            ↕ 세로는 포함한 콘텐츠 크기만큼 줄어듬   div은 가장 대표적인 블록 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Block 요소는 가로, 세로 너비를 지정할 수 있음   &lt;div style=\"width: 100px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"height: 40px;\"&gt;World!!&lt;/div&gt;       100px &lt;--------------&gt; Hello          ↕ World!!                        ↕                                ↕ 40px &lt;------------------------------&gt;     외부, 내부 여백을 지정할 수 있음   &lt;div style=\"margin: 20px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"padding: 20px;\"&gt;World!!&lt;/div&gt;  20px             ↕ 20px          20px &lt;--&gt;『Hello                    』&lt;--&gt;                  ↕ 20px 『               ↕ 20px          20px &lt;--&gt;World!!                      &lt;--&gt;  20px            ↕ 20px             』      &lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;    &lt;!-- Block 요소 안에 Block 요소 사용 불가 --&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;  &lt;!-- Block 요소 안에 Inline 요소 사용 가능 --&gt;   ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-inlineblock/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-1. 요구사항 확인",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 생명 주기(Software Life Cycle) – A   소프트웨어 개발 방법론의 바탕   - 폭포수 모형(Waterfall Model)      고전적 생명 주기 모형   개발의 한 단계가 끝나야 다음 단계로 넘어가는 선형 순차적 모형   메뉴얼 작성   단계가 끝나면 다음 단계 _결과물 명확히 산출_되어야 함   두 개 이상의 과정이 병행 수행 X   타당성 검토 -&gt; 계획 -&gt; 요구 분석 -&gt; 설계 -&gt; 구현(코딩) -&gt; 시험(검사) -&gt; 유지보수   - 프로토타입 모형(Prototype Model)      인터페이스에 중점을 두어 개발   시스템의 일부를 만드는 과정으로 추후 구현 단계에서 사용될 골격 코드   폭포수 모형의 단점 보완   요구 수집 -&gt; 빠른 설계 -&gt; 프로토타입 구축 -&gt; 고객 평가 -&gt; 포로토타입 조정 -&gt; 구현   - 나선형 모형(Spiral Model)      프로토타입 + 위험 분석 기능   여러번의 개발 과정을 거쳐 완벽한 소프트웨어 개발. 점진적 모형   위험의 관리와 최소화 목적   누락되거나 추가된 요구사항 첨가 가능, 정밀   유지보수 과정 필요 없음   계획 및 정의 -&gt; 위험 분석 -&gt; 공학적 개발 -&gt; 고객 평가   - 애자일 모형(Agile Model)      일정 주기 반복 하며 개발   고객과의 소통에 초점   스프린트, 이터레이션의 짧은 개발 주기 반복   결과물에 대한 고객의 평가와 요구를 적극 수용   스크럼(Scrum), XP(eXtreme Programming), 칸반(Kanban), Lean, 크리스탈, ASD, FDD 등   @ 애자일 선언   애자일 개발 4대 핵심 가치      개인과 상호작용에 더 가치를 둠   실행되는 SW에 더 가치를 둠   고객과 협업에 더 가치를 둠   변화에 반응하는 것에 더 가치를 둠   - 폭포수 모형과 애자일의 비교                  구분       폭포수       애자일                       요구사항 반영       어려움       지속적으로 반영                 고객과의 의사소통       적음       지속적                 테스트       마지막에 테스트       반복되는 주기마다 테스트                 개발 중심       계획, 문서(메뉴얼)       고객               2. 스크럼(Scrum) 기법 – A   팀 중심으로 개발 효율성 높임   - 개요      스스로 팀을 구성, 스스로 해결   제품 책임자(PO; Product Owner)            개발 의뢰자나 사용자가 담당       제품 요구사항 작성의 주체       요구사항 백로그 작성, 우선순위 지정           스크럼 마스터(SM; Scrum Master)            객관적인 시각에서 조언       통제가 목표 아님       진행사항 점검, 장애요소 공론화           개발팀(DT; Development Team)            PO, SM을 제외한 개발에 참여하는 모든 사람           - 스크럼 개발 프로세스      제품 백로그 -&gt; 스프린트 계획 회의 -&gt; 스프린트 -&gt; 일일 스크럼 회의 -&gt; 스프린트 검토 회의 -&gt; 스프린트 회고       3. XP(eXtreme Programming) 기법 – A   고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상   - XP      짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적 참여로 S/W를 빠르게 개발   릴리즈 기간을 짧게 반복   릴리즈 테스트마다 고객을 직접 참여시킴   소규모 인원 개발 프로젝트에 효과적   XP의 5대 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백   - XP 개발 프로세스      사용자 스토리 -&gt; 릴리즈 계획 수립 -&gt; 스파이크 -&gt; 이터레이션 -&gt; 승인검사 -&gt; 소규모 릴리즈   - XP 주요 실천 방법      짝 프로그래밍(Pair Programming)            다른 사람과 함께 스행하여 책임을 공동으로 나눔           테스트 주도 개발(Test-Driven Development)            테스트 케이스 먼저 작성       테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구 사용           전체 팀(Whole Team)            모든 구성원들을 각자 자신의 역할이 있고 거기에 책임을 가져야 함           계속적인 통합(Continuous Integration)            모듈 단위로 개발된 코드가 지속적으로 통합           디자인 개선(Design Improvement) 또는 리팩토링(Refactoring)            기능 변경 없이, 단순화, 유연성 강화 등을 통해 시스템 재구성           소규모 릴리즈(Small Releases)            릴리즈 기간을 짧게 반복하여 고객 요구 변화에 신속히 대응               4. 요구사항 정의 – B   - 요구사항 개념 및 특징      요구사항은 소프트웨어가 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약 조건   개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공   개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 도움   요구사항이 잘 정의 되어야 이후 과정의 목표와 계획을 수립할 수 있음   - 요구사항의 유형      기능 요구사항            무엇을 하는지, 어떤 기능을 하는지       입출력에 무엇이 포함되어야 하는지, 어떤 데이터를 저장하거나 연산을 수행해야 하는지       반드시 수행해야 하는 기능       사용자가 제공받기 원하는 기능           비기능 요구사항            시스템 장비 구성       성능       인터페이스       데이터       테스트       보안       품질       제약사항       프로젝트 관리 요구사항       프로젝트 지원 요구사항           사용자 요구사항            사용자 관점에서 본 시스템이 제공해야 할 요구사항       친숙한 표현으로 이해하기 쉽게 작성           시스템 요구사항            개발자 관점에서 본 시스템이 사용자와 다른 시스템에 제공해야 할 요구사항       전문적이고 기술적인 용어로 표현       소프트웨어 요구사항이라고도 함           - 요구사항 개발 프로세스   요구 사항 도출(Elicitation) -&gt; 분석(Analysis) -&gt; 명세(Specification) -&gt; 확인(Validation)       5. UML(Unified Modeling Language) – A   - UML 개요      객체 지향 모델링 언어   Rumbaugh, Booch, Jacobson 등 객체지향 방법론의 장접 통합. OMG에서 표준으로 지정   구조 다이어그램 6개, 행위 다이어그램 7개   사물과 사물 간의 관계를 용도에 맞게 표현   구성요소는 사물, 관계, 다이어그램   - 사물(Things)      관계가 형성될 수 있는 대상   구조 사물(Structural Things)            시스템의 개념적, 물리적 요소       Class, Use Case, Component, Node 등           행동 사물(Behavioral Things)            시간과 공간에 따른 요소들의 행위       Interaction, State Machine           그룹 사물(Grouping Things)            요소들을 그룹으로 묶어서 표현       Package           주해 사물(Annotation Things)            부가적인 설명이나 제약조건       Note           - 관계(Relationships)      사물과 사물 사이의 연관성 표현   연관(Association) 관계            2개 이상의 사물이 서로 관련되어 있음       사물 사이 실선 연결, 방향성은 화살표로       양방향 관계의 경우 화살표 생략하고 실선으로만 연결       다중도를 선 위에 표기           집합(Aggregation) 관계            하나의 사물이 다른 사물에 포함되어 있음       서로 독립적       포함하는 쪽으로 속이 빈 마름모 연결하여 표현           포함(Composition) 관계            포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계       독립될 수 없고 생명주기를 함께 함       포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현           일반화(Generalization) 관계            하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현       일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)       상위 사물 쪽으로 속이 빈 화살표 연결하여 표현           의존(Dependency) 관계            연관은 있으나 짧은 시간 동안만 연관을 유지하는 관계       소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계       영향 받는 쪽으로 점선 화살표 연결하여 표현           실체화(Realization) 관계            할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계       기능 쪽으로 속이 빈 점선 화살표 연결           - 다이어그램(Diagram)      사물과 관계를 도형으로 표현   가시화한 View를 제공하여 의사소통에 도움   정적 모델링에서는 구조적 다이어그램, 동적 모델링에서는 행위 다이어그램 사용   @ 구조적 다이어그램      클래스(Class) 다이어그램   객체(Object) 다이어그램   컴포넌트(Component) 다이어그램   배치(Deployment) 다이어그램   복합체 구조(Composite Structure) 다이어그램   패키지(Package) 다이어그램   @ 행위 다이어그램      유스케이스(Use Case) 다이어그램   시퀀스(Sequence) 다이어그램   커뮤니케이션(Communication) 다이어그램   상태(State) 다이어그램   활동(Activity) 다이어그램   상호작용 개요(Interaction Overview) 다이어그램   타이밍(Timing) 다이어그램  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-2. 화면 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 사용자 인터페이스 – A   - UI 개요      사용자 인터페이스(UI)는 사용자와 시스템 간의 상호작용이 원활하도록 돕는 장치나 S/W   UI의 3가지 분야            정보 제공을 위한 물리적 제어       콘텐츠의 상세적인 표현과 전체적인 구성       모든 사용자가 편리하고 간편하게 사용           - UI 특징      S/W 영역 중 변경이 가장 많이 발생   편리성과 가독성을 높여 작업 시간을 단축시키고 업무에 대한 이해도 높여줌   최소한의 노력으로 원하는 결과 얻을 수 있게 함   오류를 줄임   구체적인 방법 제시   매개 역할   UI를 설계하기 위해서는 S/W 아키텍처 반드시 숙지해야 함   - UI 구분      CLI(Command Line Interface) : 텍스트 형태   GUI(Graphical User Interface) : 그래픽 환경   NUI(Natural User Interface) : 말이나 행동으로 조작   - UI 기본 원칙      직관성   유효성   학습성   유연성   - UI 설계 지침      사용자 중심   일관성   단순성   결과 예측 가능   가시성   표준화   접근성   명확성   오류 발생 해결       2. UI 표준 및 지침 – B      기술의 중립성(웹 표준), 표현 보장성(웹 접근성), 기능의 호환성(웹 호환성) 고려 확인   UI 표준 : 모든 UI에 공통적으로 적용될 내용   UI 지침 : UI 개발 과정에서 꼭 지켜야 할 공통의 조건   - 한국형 웹 콘텐츠 접근성 지침(KWCAG)      인식의 용이성            대체 텍스트       멀티미디어 대체 수단       명료성           운용의 용이성            키보드 접근성       충분한 시간 제공       광과민성 발작 예방       쉬운 내비게이션           이해의 용이성            가독성       예측 가능성       콘텐츠의 논리성       입력 도움           견고성            문법 준수       접근성           - 전자정부 웹 표준 준수 지침      내용의 문법 준수            적절한 문서타입 명시       문법 준수       인코딩 방식 표기           내용과 표현의 분리            마크업 언어를 사용해 웹 문서 구조화       스타일 언어는 표준 문법 준수           동작의 기술 중립성 보장            스크립트의 비표준 문법 확장 배제       대체 텍스트나 정보 제공           플러그인의 호환성            다양한 웹 브라우저에서 호환되는 것 사용           콘텐츠의 보편적 표현            메뉴는 다양한 브라우저에서 접근할 수 있어야 함       웹 사이트를 다양한 인터페이스로 이용할 수 있어야 함           운영체제에 독립적인 콘텐츠 제공            운영체제에 종속적이지 않은 범용적인 포맷을 사용           부가 기능의 호환성 확보            다양한 브라우저에서 사용할 수 있어야 함           다양한 프로그램 제공            다양한 브라우저에서 사용할 수 있어야 함       윈도우, 리눅스, 맥킨토시 중 2개 이상의 운영체제를 지원해야 함               3. UI 설계 도구 – A      UI의 화면 구조나 화면 배치 등을 설계할 때 사용하는 도구   기획단계에서 미리 보여주기 위한 용도   - 와이어프레임(Wireframe)      페이지에 대한 개략적인 레아아웃이나 UI 요소 등에 대한 뼈대 설계   페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계   레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용   툴 : 손그림, PPT, 키노트, 스케치, 일러스트, 포토샵 등   - 목업(Mockup)      와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형   실제로 구현되지는 않음   툴 : 파워 목업, 발사믹 목업 등   - 스토리보드(Story Board)      와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가   최종적으로 참고하는 작업 지침서, 서비스 구축을 위한 모든 정보 포함   상단이나 우측에는 제목, 작성자 기입, 좌측에는 UI화면, 우측에는 Description 기입   Description은 명확하고 세부적으로 작성   툴 : PPT, 키노트, 스케치, Axure 등   - 프로토타입(Prototype)      와이어프레임이나 스토리보드 등에 인터렉션을 적용한 동적인 형태의 모형   작업자 간 서비스 이해를 위해 작성하는 샘플   페이퍼 프로토타입과 디지털 프로토타입으로 나뉨   툴 : HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등   - 유스케이스(Use Case)      사용자 측면에서의 요구사항   사용자의 요구사항을 파악해 초기에 기능적인 요구를 결정하고 그 결과를 문서화할 수 있음   자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것. 다이어그램 형식으로 묘사   유스케이스 다이어그램이 완성되면, 명세서 작성       4. UI 요구사항 확인 – B      새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해서 작성하는 단계   목표 정의 -&gt; 활동사항 정의 -&gt; UI 요구사항 작성 -&gt; 요구사항 요소 확인 -&gt; 정황 시나리오 작성 -&gt; 요구사항 작성       5. 품질 요구사항 – B      요구사항이 얼마나 충족하는가를 나타내는 S/W 특성의 총체   품질은 사용자의 요구사항을 충족시킴으로써 확립   ISO/IEC 9126            품질 특성과 평가를 위한 표준 지침       품질에 대한 요구사항을 기술하거나 품질 평가 등에 사용       기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성           호환성과 보안성을 강화하여 ISO/IEC 25010으로 개정            기능적합성, 신뢰성, 사용성, 실행효율성, 유지보수성, 이식성, 호환성, 보안성           - 기능성(Functionality)      사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부   적절성/정합성(Suitability) : 적절한 기능을 제공   정밀성/정확성(Accuracy) : 결과를 정확하게 산출   상호 운용성(Interoperability) : 서로 어울려 작업   보안성(Security) : 접근을 권한에 따라 허용하거나 차단   준수성(Compliance) : 표준, 관례 및 규정을 준수   - 신뢰성(Reliability)      요구된 기능을 정확하고 일관되게 오류 없이 수행   성숙성(Maturity) : 고장을 피해감   고장 허용성(Fault Tolerance) : 고장 시 규정된 성능 수준을 유지   회복성(Recoverability) : 고장 시 다시 회복하고 데이터를 복구   - 사용성(Usability)      사용자가 정확하게 이해하고 사용하며, 다시 사용하고 싶은 정도   이해성(Understandability) : 사용자가 이해할 수 있는 능력   학습성(Learnability) : S/W를 학습할 수 있도록 하는 능력   운용성(Operability) : 운용하고 제어할 수 있도록 하는 능력   친밀성(Attractiveness) : 다시 사용하고 싶어 하도록 하는 능력   - 효율성(Efficiency)      할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도   시간 효율성(Time Behaviour) : 적절한 반응 시간 및 처리시간, 처리율 제공   자원 효율성(Resource Behaviour) : 적절한 자원의 양과 종류를 제공   - 유지 보수성(Maintainability)      환경의 변화에서 S/W를 개선하거나 확장할 수 있는 정도   분석성(Analyzability) : 수정될 부분의 식별을 가능하게 하는 능력   변경성(Changeability) : 변화로 인한 수정 등을 쉽게 구현   안정성(Stability) : 변경으로 인한 예상치 못한 결과를 최소화하는 능력   시험성(Testability) : 변경이 검증될 수 있는 능력   - 이식성(Portability)      다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도   적용성(Adaptability) : 다른 환경으로 변경될 수 있는 능력   설치성(Installability) : 임의의 환경에 설치할 수 있는 능력   대체성(Replaceability) : 다른 S/W를 대신하여 사용될 수 있는 능력   공존성(Co-existence) : 다른 S/W와 공존할 수 있는 능력       6. UI 프로토타입 제작 및 검토 – A   - UI 프로토타입 개요      프로토타입은 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적 형태의 모형   테스트 가능   간단하게 만들어야 함   핵심 기능만을 제공하지만, 필요한 기능은 반드시 포함   요구사항이 모두 반영될 때까지 개선, 보완   실제 사용자를 대상으로 테스트   - UI 프로토타입 장단점      장점            설득, 이해 쉬움       혼선 예방으로 개발 시간 단축       사전 오류 발견           단점            반복적인 개선작업으로 작업 시간 증가, 필요이상으로 자원 소모       중요한 작업 생략될 수 있음           - 프로토타이핑 종류      페이퍼 프로토타입(Paper Prototype)            아날로그적 방법, 손으로 직접 작성       제작기간이 짧고, 업무 협의가 빠른 경우 사용       장점                    비용 저렴           대화하면서 생성 가능           즉시 변경 가능           고객이 과다한 기대 안함                       단점                    테스트하기 부적당           상호 관계가 많은 경우 나타내기 복잡           여러 사람들에게 나눠주거나 공유하기 어렵다                           디지털 프로토타입(Digital Prototype)            프로그램을 사용하여 작성       재사용이 필요한 경우, 숙련된 전문가가 있을 경우 사용       장점                    최종 제품과 비슷하게 테스트           수정 쉬움           재사용 가능                       단점                    프로그램의 사용법을 알아야 함                           - UI 프로토타입 제작 단계      요구사항 분석   개발할 시스템의 핵심적인 기능을 페이퍼/디지털 방식으로 작성   사용자가 확인하는 단계, 추가 및 수정 의견 제안   수정과 합의가 이루어짐       7. UI 설계서 작성 – B   - UI 설계서 개요      UI 설계를 구체화하여 작성하는 문서. 대표적인 화면들을 설계   원활한 의사소통을 위해 작성   - UI 설계서 표지 작성      혼동되지 않도록 프로젝트명 또는 시스템명을 포함   - UI 설계서 개정 이력 작성      UI 설계서가 수정될 때마다 어떤 부분이 수정되었는지 정리해 놓은 문서   - UI 요구사항 정의서 작성      사용자의 요구사항을 확인하고 정리한 문서   - 시스템 구조 작성      전체 시스템의 구조를 설계한 것   - 사이트 맵 작성      사이트에 표시할 콘텐츠를 한 눈에 알아 볼 수 있도록 메뉴별로 구분하여 설계한 것   - 프로세스 정의서 작성      프로세스들을 작업 진행 순서에 맞춰 정리한 것   UI 전체적인 흐름 파악 가능   - 화면 설계      필요한 화면을 페이지별로 설계   와이어프레임을 대략적으로 스케치   주요 흐름을 스토리보드 형태로 작성   - UI 화면 설계의 기본 구성 요소      윈도우, 메뉴, 아이콘, 포인터       8. UI 상세 설계 – B      실제 구현을 위해 모든 화면에 대한 자세한 설계를 진행하는 단계. 반드시 시나리오 작성   최종 목표를 달성하기 위한 방법이 순차적으로 묘사   - UI 시나리오 문서 작성 원칙      구체적으로 작성. Tree 구조 또는 Flow Chart 표기법으로 작성   공통적으로 적용될 UI 요소와 인터렉션을 일반 규칙으로 정의   레이아웃과 속할 기능 정의   인터렉션의 순서, 분기, 조건, 루프 등을 명시   예외 상황에 대비한 다양한 케이스 정의   기능별 상세 기능 시나리오를 정의   UI 시나리오 규칙을 지정   - UI 시나리오 문서 작성을 위한 일반 규칙      주요 키의 위치와 기능   공통 UI 요소   기본 스크린 레이아웃   기본 인터랙션 규칙   공통 단위 태스크 흐름   케이스 문서   - UI 요소      체크 박스 : 1개 이상의 값을 선택할 수 있는 버튼   라디오 버튼 : 하나만 선택할 수 있는 버튼   텍스트 박스 : 데이터를 입력하고 수정할 수 있는 상자   콤보 상자 : 지정된 목록 상자에 내용을 표시하여 선택하거나 새로 입력할 수 있는 상자   목록 상자 : 콤보 상자와 같이 목록을 표시하지만 새로운 내용을 입력할 수 없음   - UI 시나리오 문서의 요건      완정성(Complete)   일관성(Consistent)   이해성(Understandable)   가독성(Readable)   수정 용이성(Modifiable)   추적 용이성(Traceable)   - UI 시나리오 문서로 인한 기대 효과      오류 감소   재작업 감소, 혼선 최소화   불필요한 기능 최소화   개발 비용 절감   개발 속도 향상  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp2/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-3. 애플리케이션 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 아키텍처 – A   - 소프트웨어 아키텍처의 설계      골격이 되는 기본 구조, 시스템의 구조 또는 구조체   원칙과 지침, 의사소통 도구   비기능적 요구사항의 제약 반영, 기능적 요구사항을 구현하는 방법을 찾는 과정   분할 방법, 모듈에 할당될 기능, 모듈 간의 인터페이스 등 결정   - 모듈화(Modularity)      성능을 향상시키거나 수정 및 재사용, 유지관리 등을 위해 기능들을 모듈 단위로 나누는 것   자주 사용하는 것들을 공통 모듈로 구성하여 재사용성 향상   크기를 작게 나누면 통합 비용이 많이 듦   크기를 크게 나누면 모듈 하나의 개발 비용이 많이 듦   - 추상화(Abstraction)      전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화   유사한 모델을 만들어서 여러 가지 요인들을 테스트   최소의 비용으로 실제 상황에 대처, 구조 및 구성을 대략적으로 파악   과정 추상화            전반적인 흐름만 파악할 수 있게 설계           데이터 추상화            데이터 구조를 대표할 수 있는 표현으로 대체           제어 추상화            이벤트 발생을 대표할 수 있는 표현으로 대체           - 단계적 분해(Stepwise Refinement)      하향식 설계 전략. 상위의 중요 개념으로부터 하위의 개념으로 구체화   추상화의 반복에 의해 세분화   기능에서부터 시작해 알고리즘, 자료구조 등 상세한 내역을 뒤로 미뤄 진행   - 정보 은닉(Information Hiding)      정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법   필요한 정보만 인터페이스를 통해 주고 받음   모듈을 독립적으로 수행할 수 있음   모듈이 변경되더라도 다른 모듈에 영향을 주지 않아 수정, 시험, 유지보수 용이   - 소프트웨어 아키텍처의 품질 속성      시스템 측면            성능, 보안, 가용성, 기능성, 사용성, 변경용이성, 확장성 등           비즈니스 측면            시장 적시성, 비용과 혜택, 예상 시스템 수명 등           아키텍처 측면            개념적 무결성, 정확성, 완결성, 구축 가능성 등           - 소프트웨어 아키텍처 설계 과정      설계 목표 설정 -&gt; 시스템 타입 결정 -&gt; 아키텍처 패턴 적용 -&gt; 서브시스템 구체화 -&gt; 검토       2. 아키텍처 패턴 – A   - 아키텍처 패턴의 개요      아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식   S/W 시스템의 구조를 구성하기 위한 기본적인 윤곽   서브시스템들과 그 역할이 정의, 관계와 여러 규칙, 지침 등이 포함   아키텍처 스타일 또는 표준 아키텍처라고도 함   - 레이어 패턴(Layers pattern)      시스템을 계층으로 구분   상위 계층은 서비스 제공자, 하위 계층은 클라이언트가 됨   마주보는 두 개의 계층 사이에서만 상호작용   변경 작업 용이   특정 계층만을 교체해 시스템을 개선하는 것이 가능   OSI 참조 모델   - 클라이언트-서버 패턴(Client-Server pattern)      하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성   사용자는 클라이언트와만 의사소통   서버는 항상 대기 상태를 유지   클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고 서로 독립적   - 파이프-필터 패턴(Pipe-Filter Pattern)      데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터 전송   재사용성이 좋고, 추가가 쉬워 확장이 용이   재배치하여 다양한 파이프라인 구축 가능   데이터 변환, 버퍼링, 동기화 등에 주로 사용   Unix의 Shell   - 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)      서브시스템을 3개의 부분으로 구조화   모델(Model) : 핵심 기능과 데이터를 보관   뷰(View) : 정보를 표시   컨트롤러(Controller) : 입력을 처리   별도의 컴포넌트로 분리되어 서로 영향을 받지 않고 개발 작업 수행 가능   여러 개의 뷰를 만들 수 있으므로 대화형 어플리케이션에 적합   - 마스터-슬레이브 패턴(Master-Slave Pattern)      장애 허용 시스템, 병렬 컴퓨팅 시스템   - 브로커 패턴(Broker Pattern)      분산 환경 시스템   - 피어-투-피어 패턴(Peer-To-Peer Pattern)      클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용   - 이벤트-버스 패턴(Event-Bus Pattern)      소스, 리스너, 채널, 버스   - 블랙보트 패턴(Blackboard Pattern)      음성 인식, 차량 식별, 신호 해석   - 인터프리터 패턴(Interpreter Pattern)      프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용       3. 객체지향(Object-Oriented) – A   - 객체지향의 개요      S/W를 개발할 때 객체들을 조립해서 작성할 수 있는 기법   재사용 및 확장 용이, 빠르게 개발할 수 있고 유지보수 쉬움   복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리 지원   사용자와 개발자가 쉽게 이해할 수 있음   - 객체(Object)      데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 S/W 모듈   데이터            객체가 가지고 있는 정보. 속성이나 상태, 분류 등       속성, 상태, 변수, 상수, 자료 구조           함수            객체가 수행하는 기능       메소드, 서비스, 동작, 연산           객체의 특성            독립적으로 식별 가능한 이름       상태는 시간에 따라 변함       상호 연관성에 의한 관계 형성       행위의 특징을 나타낼 수 있음       일정한 기억장소를 가지고 있음           - 클래스(Class)      공통된 속성과 연산을 갖는 객체의 집합   객체들이 갖는 속성과 연산을 정의하고 있는 틀   각각의 객체를 인스턴스, 새로운 객체를 생성하는 것을 인스턴스화   최상위 클래스는 상위 클래스를 갖지 않는 클래스   슈퍼 클래스는 특정 클래스의 부모 클래스   서브 클래스는 특정 클래스의 자식 클래스   - 캡슐화(Encapsulation)      데이터와 데이터를 처리하는 함수를 하나로 묶는 것   인터페이스를 제외한 세부 내용이 은폐   외부 모듈의 변경으로 인한 파급 효과가 적음   재사용 용이   인터페이스가 단순해지고, 객체 간 결합도 낮아짐   - 상속(Inheritance)      부모 클래스의 모든 속성과 연산을 자식 클래스가 물려 받는 것   자식 클래스는 속성과 연산을 다시 정의하지 않고 사용 가능   새로운 속성과 연산을 첨가하여 사용 가능   재사용을 높임   - 다형성(Polymorphism)      메시지에 의해 객체가 연산을 수행할 때, 고유한 방법으로 응답할 수 있는 능력   객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함   같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 함       4. 모듈 – A   - 모듈의 개요      모듈화를 통해 분리된 시스템의 각 기능. 서브루틴, 서브시스템 등과 같은 의미로 사용   단독으로 컴파일 가능, 재사용 가능   모듈의 기능적 독립성은 하나의 기능만을 수행하고 과도한 상호작용을 배재함으로써 달성   수정하더라도 다른 모듈에 거의 영향을 미치지 않으며, 오류 발생시 쉽게 발견하고 해결 가능   결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 함   - 결합도(Coupling)      모듈간 상호 의존하는 정도   결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음   결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움   @ 내용 결합도(Content Coupling)      한 모듈이 다른 모듈이 내부 기능 및 그 내부 자료를 직접 참조하거나 수정   제어가 이동하는 경우   @ 공통(공유) 결합도(Common Coupling)      공통 데이터 영역을 여러 모듈이 사용할 때의 결합도   조금의 변경이 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 함   @ 외부 결합도(External Coupling)      선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도   데이터의 범위를 각 모듈에서 제한할 수 있음   @ 제어 결합도(Control Coupling)      다른 모듈 내부의 논리적 흐름을 제어하기 위해 제어신호를 이용하여 통신   다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우   처리 기능이 두 모듈에 분리되어 설계된 경우   하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상 발생   @ 스탬프 결합도(Stamp Coupling)      배열이나 레코드 등의 자료 구조가 전달될 때의 결합도   동일한 자료 구조를 조회하는 경우   @ 자료 결합도(Data Coupling)      자료 요소로만 구성될 때의 결합도   가장 바람직한 결합도   - 응집도(Cohesion)      정보 은닉 개념을 확장한 것   모듈이 독립적인 기능으로 정의되어 있는 정도   응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음   @ 기능적 응집도(Functional Cohesion)      모든 기능 요소들이 단일 문제와 연관되어 수행될 경우   @ 순차적 응집도(Sequential Cohesion)      출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우   @ 교환적 응집도(Communication Cohesion)      동일한 입출력을 사용하여 서로 다른 기능을 수행하는 구성요소들이 모였을 경우   @ 절차적 응집도(Procedural Cohesion)      다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우   @ 시간적 응집도(Temporal Cohesion)      특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우   @ 논리적 응집도(Logical Cohesion)      유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우   @ 우연적 응집도(Coincidental Cohesion)      각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우   - 팬인(Fan-In) / 팬아웃(Fan-Out)      팬인은 모듈을 제어하는 모듈의 수. 팬아웃은 모듈에 의해 제어되는 모듈의 수   시스템의 복잡도를 알 수 있음   팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있으나, 단일 장애점 발생 가능   팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고 단순화할 수 있는지 검토   시스템 복잡도를 최적화하기 위해 팬인을 높게, 팬아웃은 낮게 설계       5. 코드 – B   - 코드의 개요      자료의 추출을 쉽게 하기 위해 사용하는 기호   신속, 정확, 명료하게 정보 전달   일정한 규칙에 따라 작성   식별기능, 분류기능, 배열기능   - 코드의 종류      순차 코드            1, 2, 3 ..           블록 코드            1001~1100 : 총무부           10진 코드            1000 : 공학, 1100 : S/W 공학           그룹 분류 코드            1-01-001 : 본사-총무부-인사계           연상 코드            TV-40 : 40인치 TV           표의 숫자 코드            120-720-1500 : 두께x폭x길이가 120x720x1500인 강판           합성 코드            KE-711 : 대한항공 711기           - 코드 부여 체계      이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식   유일한 코드 부여하여 식별 및 추출을 용이하게 함   각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 함   코드의 자릿수와 구분자, 구조 등을 상세하게 명시       6. 디자인 패턴 – B   - 디자인 패턴의 개요      세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식   재사용할 수 있는 기본형 코드들이 포함   디자인 패턴을 참고하여 적용하는 것이 더 효율적   Don’t reinvent the wheel   유사한 형태의 다른 패턴으로 변화되는 특징   - 아키텍처 패턴 vs 디자인 패턴                  아키택처       디자인                       상위수준 설계       하위수준 설계                 전체 시스템 구조 설계       서브시스템에 속하는 컴포넌트들과 그 관계 설계           - 생성 패턴(Creational Pattern)      객체의 생성과 관련된 패턴   객체의 생성과 참조 과정을 캡슐화하여 프로그램에 유연성을 더해줌   @ 추상 팩토리(Abstract Factory)      인터페이스를 통해 서료 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현   연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능   @ 빌더(Builder)      작게 분리된 인스턴스를 건축 하듯이 조합하여 객체 생성   동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음   @ 팩토리 메소드(Factory Method)      객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화   상위클래스에서는 인터페이스 정의하고 실제 생성은 서브 클래스가 담당   @ 프로토타입(Prototype)      원본 객체를 복제하는 방법으로 객체를 생성   비용이 큰 경우 이용   @ 싱글톤(Singleton)      객체를 생성하면 어디서든 참조할 수 있지만, 여러 프로세스가 동시 참조 불가   클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비 최소화   - 구조 패턴(Structural Pattern)      클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴   구조가 복잡한 시스템을 개발하기 쉽게 도와줌   @ 어댑터(Adapter)      인터페이스를 다른 클래스가 이용할 수 있도록 변환   인터페이스가 일치하지 않을 때 이용   @ 브리지(Bridge)      서로가 독립적으로 확장할 수 있도록 구성한 패턴   기능과 구현을 두 개의 별도 클래스로 구현   @ 컴포지트(Composite)      복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용   객체를 트리구조로 구성   @ 데코레이터(Decorator)      객체 간의 결합을 통해 능동적으로 기능들을 확장   부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식   @ 퍼싸드(Facade)      상위에 인터페이스를 구성함으로써 서브 클래스의 기능을 간편하게 사용할 수 있도록 함   통합 인터페이스를 제공하는 Wrapper 객체가 필요   @ 플라이웨이트(Flyweight)      매번 생성하는 것이 아니고 가능한 한 공유해서 사용해 메모리 절약   다수의 유사 객체를 생성하거나 조작할 때 유용   @ 프록시(Proxy)      접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할   네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용   - 행위 패턴(Behavioral Pattern)      클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의   하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화하도록 도움   @ 책임 연쇄(Chain of Responsibility)      객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태   @ 커맨드(Command)      요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장   추상 클래스와 구체 클래스로 분리하여 단순화   @ 인터프리터(Interpreter)      언어에 문법 표현을 정의하는 패턴   SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용   @ 반복자(Iterator)      접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴   내부 표현 방법의 노출 없이 순차적인 접근이 가능   @ 중재자(Mediator)      복잡한 상호작용을 캡슐화하여 객체로 정의   객체 사이의 의존성을 줄여 결합도 감소시킴   @ 메멘토(Memento)      객체 내부 상태를 객체화함으로써 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공   Ctrl + Z 같은 기능 개발할 때 이용   @ 옵서저(Observer)      객체의 상태가 변화하면 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴   분산 시스템 간에 이벤트를 생성, 발행하고, 이를 수신해야 할 때 이용   @ 상태(State)      동일한 동작을 다르게 처리해야 할 때 사용하는 패턴   객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리   @ 전략(Strategy)      동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴   원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘 변경 가능   @ 템플릿 메소드(Template Method)      상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 패턴   코드의 양을 줄이고 유지보수를 용이하게 해줌   @ 방문자(Visitor)      데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴   분리된 처리 기능은 각 클래스를 방문하여 수행  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp3/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-4. 인터페이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 시스템 인터페이스 요구사항 분석 – B   - 시스템 인터페이스 요구사항 구성      시스템끼리 서로 연동하여 상호작용하기 위한 접속 방법이나 규칙   명세서에는 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 방식, 송신 데이터, 주기 등 포함   - 시스템 인터페이스 요구사항 분석      기능적 요구사항과 비기능적 요구사항으로 분류   요구사항 분석 기법을 적절히 이용   적절한 수준으로 세분화   누락된 요구사항이나 제한조건 추가   상대적 중요도를 평가하여 우선순위를 부여   - 시스템 인터페이스 요구사항 분석 절차      요구사항 선별 -&gt; 요구사항 관련 자료 준비 -&gt; 요구사항 분류 -&gt; 요구사항 분석 및 명세서 구체화 -&gt; 요구사항 명세서 공유       2. 인터페이스 요구사항 검증 – B      요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 베이스라인 설정   검토 계획 수립 -&gt; 검토 및 오류 수정 -&gt; 베이스라인 설정   - 요구사항 검증 방법      요구사항 검토            동료 검토 : 동료들이 결함 발견       워크스루 : 짧은 검토 회의를 통해 결함 발견       인스펙션 : 검토 전문가들이 결함 발견           프로토타이핑   테스트 설계   CASE 도구 활용   - 인터페이스 요구사항 검증의 주요 항목      완전성(Completeness)   일관성(Consistency)   명확성(Unambiguity)   기능성(Functionality)   검증 가능성(Verifiability)   추적 가능성(Traceability)   변경 용이성(Easily Changeable)       3. 인터페이스 방법 명세화 – B   - 시스템 연계 기술      DB Link : DB Link 객체를 이용하는 방식   API/Open API : DB에서 데이터를 읽어 와 제공   연계 솔루션 : EAI 서버와 송수신 시스템에 설치되는 클라이언트 이용   Socket : 서버는 통신을 위한 소켓을 생성하여 포토 할당하여 클라이언트의 통신 요청 시 연결하여 통신   Web Service : WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스   - 인터페이스 통신 유형      단방향 : 요청만 하고 응답이 없는 방식   동기 : 요청하고 응답이 올때까지 대기   비동기 : 요청하고 다른 작업을 수행하다 응답이 오면 처리   - 인터페이스 처리 유형      실시간 방식 : 요청한 내용을 바로 처리   지연 처리 방식 : 매건 단위로 처리할 경우 비용이 많이 발생할 때   배치 방식 : 대량의 데이터를 처리할 때       4. 미들웨어 솔루션 명세 – A   - 미들웨어의 개념 및 종류      운영체제와 응용프로그램 사이에서 추가적인 서비스를 제공하는 소프트웨어   표준화된 인터페이스 제공하여 데이터 교환에 일관성 보장   - DB(DataBase)      클라이언트에서 원격의 DB와 연결하기 위한 미들웨어   DB를 사용해서 시스템 구축하는 경우 2-Tier 아키텍처라고 함   ODBC, IDAPI, Glue   - RPC(Remote Procedure Call)      응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식   Entera, ONC/RPC   - MOM(Message Oriented Middleware)      메시지 기반의 비동기형 메시지를 전달하는 방식   온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 사용됨   MQ, Message Q, JMS   - TP-Monitor(Transaction Processing Monitor)      온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어   빠른 응답 속도를 유지해야 하는 업무에 사용   tuxedo, tmax   - ORB(Object Request Broker)      객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현   트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음   Orbix, CORBA   - WAS(Web Application Server)      동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어   웹 환경을 구현하기 위한 미들웨어   웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현 가능   WebLogic, WebSphere  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp4/",
        "teaser": null
      },{
        "title": "[HTML] HTML 구조 및 태그",
        "excerpt":"HTML 구조   &lt;!DOCTYPE html&gt;  &lt;!-- 문서의 HTML 버전을 지정 --&gt;  &lt;html&gt;       &lt;!-- 문서의 전체 범위 --&gt;    &lt;head&gt;     &lt;!-- 문서의 정보를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보이지 않는 정보를 작성하는 범위 --&gt;   &lt;/head&gt;    &lt;body&gt;     &lt;!-- 문서의 구조를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보여지는 구조를 작성하는 범위 --&gt;   &lt;/body&gt; &lt;/html&gt;   Head 태그 내부   - meta 태그   &lt;meta charset=\"UTF-8\" /&gt;   &lt;!-- 문자 인코딩 방식 --&gt; &lt;meta name=\"viewport\" content=\"width=xxxx...\" /&gt; &lt;!-- 정보의 종류     정보의 값 --&gt;  &lt;meta /&gt;는 HTML 문서의 제작자, 내용, 키워드 등의 정보를 검색엔진이나 브라우저에 제공       - title 태그   &lt;title&gt;Google&lt;/title&gt; &lt;!-- HTML 문서의 제목을 정의. 웹 브라우저 탭에 표시됨--&gt;       - link 태그   &lt;!-- 관계              경로 --&gt; &lt;link rel=\"stylesheet\" href=\"./main.css\" /&gt; &lt;link rel=\"icon\" htrf=\"./favicon.png\" /&gt;  &lt;link /&gt;는 외부 문서를 가져와 연결할 때 사용. 대부분 CSS 파일       - style 태그   &lt;!-- CSS를 HTML 문서 안에서 작성하는 경우에 사용 --&gt; &lt;style&gt;   div {     color : red;   } &lt;/style&gt;       - script 태그   &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;!-- JS파일 가져오는 경우--&gt; &lt;!-- defer : HTML 구조가 준비된 후에 JS를 해석 --&gt;  &lt;!-- JS를 HTML 문서 안에서 작성하는 경우 --&gt; &lt;script&gt;   console.log('Hello World!!') &lt;/script&gt;   Body 태그 내부   - div 태그   &lt;div&gt;&lt;/div&gt;  &lt;!-- Block, 특별한 의미가 없는 구분을 위한 요소 --&gt;       - h 태그   &lt;h1&gt;제목1&lt;/h1&gt;    &lt;!-- Block, 제목을 의미하는 요소 --&gt; &lt;h2&gt;제목2&lt;/h2&gt;    &lt;!-- 숫자가 작을수록 더 중요한 제목--&gt; &lt;h6&gt;제목6&lt;/h6&gt;       - p 태그   &lt;p&gt;가나 다라마&lt;/p&gt;  &lt;!-- Block, 문장을 의미하는 요소 --&gt;       - img 태그   &lt;!-- 경로              대체 텍스트 --&gt; &lt;img src=\"img/xxx.png\" alt=\"xxx\" /&gt; &lt;!-- Inline, 이미지 삽입 요소--&gt;       - ul, li 태그   &lt;ul&gt;  &lt;!-- Block, 순서가 필요 없는 목록의 집합--&gt;   &lt;li&gt;강아지&lt;/li&gt;    &lt;li&gt;고양이&lt;/li&gt;  &lt;!-- 목록 내 각 항목 --&gt;   &lt;li&gt;돼지&lt;/li&gt; &lt;/ul&gt;       - a 태그   &lt;!-- Inline, 다른/같은 페이지로 이동하는 하이퍼링크 지정하는 요소 --&gt; &lt;a href=\"http://www.google.com\" target=\"_blank\"&gt;Google&lt;/a&gt; &lt;!-- URL                       URL의 표시(브라우저 탭) 위치 --&gt;       - span 태그   &lt;span&gt;가나다&lt;/span&gt; &lt;!-- Inline, 특별한 의미가 없는 구분을 위한 요소--&gt;       - br 태그   &lt;p&gt;가나다라&lt;br/&gt;마바사아&lt;/p&gt; &lt;!--Inline, 줄바꿈 요소--&gt;  가나다라 마바사아       - input 태그   &lt;!--Inline-Block, 데이터를 입력하는 요소--&gt; &lt;input type=\"text\" value=\"xxx\" placeholder=\"yyy\" disabled/&gt;  &lt;!--  타입         입력된 값     힌트            비활성화 --&gt;       - label 태그   &lt;label&gt; &lt;!--Inline, 라벨 가능 요소(input)의 제목--&gt;   &lt;input type=\"checkbox\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"checkbox\" checked /&gt; Cat &lt;/label&gt;   &lt;label&gt; &lt;!-- animals 그룹에서 1개만 입력 --&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Cat &lt;/label&gt;        - table, tr, td 태그   &lt;table&gt;  &lt;!-- Table, 표 요소, 행과 열의 집합 --&gt;    &lt;tr&gt;   &lt;!-- Table, 행을 지정하는 요소 --&gt;     &lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt; &lt;!-- Table, 열을 지정하는 요소 --&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;C&lt;/td&gt;&lt;td&gt;D&lt;/td&gt;   &lt;/tr&gt;  &lt;/table&gt;  A B C D  주의! TABLE 요소보다 Grid같은 CSS 기능으로 레이아웃을 작업해야 함   HTML 전역 속성   &lt;태그 title=\"설명\"&gt;&lt;/태그&gt;   &lt;!-- 요소의 정보나 설명을 지정 --&gt; &lt;태그 style=\"스타일\"&gt;&lt;/태그&gt; &lt;!-- 요소에 적용할 스타일 지정 --&gt; &lt;태그 class=\"이름\"&gt;&lt;/태그&gt;   &lt;!-- 요소를 지칭하는 중복 가능한 이름 --&gt; &lt;태그 id=\"이름\"&gt;&lt;/태그&gt;      &lt;!-- 요소를 지칭하는 고유한 이름 --&gt; &lt;태그 data-이름=\"데이터\"&gt;&lt;/태그&gt; &lt;!-- 요소에 데이터를 지정 --&gt;  ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-structure/",
        "teaser": null
      },{
        "title": "[CSS] CSS 개요",
        "excerpt":"CSS 기본 문법   /* 주석 */ 선택자 {   속성 : 값;   속성 : 값; }   CSS 선언 방식   - 내장 방식   style 태그의 내용으로 스타일 작성   &lt;style&gt;   div {     color: red;     margin: 10px;   } &lt;/style&gt;       - 인라인 방식   요쇼의 style 속성에 직접 스타일 작성   &lt;div style=\"color: red; margin: 10px;\"&gt;&lt;/div&gt;       - 링크 방식   링크 태그로 외부 CSS 파일을 가져와서 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ div {   color: red;   margin: 20px; }       - @import 방식   CSS의 @import 규칙으로 CSS문서 안에서 또 다른 CSS문서를 가져와 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ @import url(\"./sub.css\");  div {   color: red;   margin: 20px; }  /* sub.css */ .sub {   width: 10px;   height: 20px; }   CSS 선택자   - 기본   /* 전체 선택자 : 모든 요소 선택 */ * {   color: red; }  /* 태그 선택자 : 태그 이름의 요소 선택 */ div {   color: red; }  /* 클래스 선택자 : class 속성 값의 요소 선택  */ .cat {   color: red; }  /* 아이디 선택자 : id 속성 값의 요소 선택 */ #cat {   color: red; }       - 복합   /* 일치 선택자 : 선택자를 동시에 만족하는 요소 선택 */ div.cat {   color: red; }  /* 자식 선택자 : 자식 요소 선택 */ ul &gt; .cat {   color: red; }  /* 하위(후손) 선택자 : 하위 요소 선택. 띄어쓰기가 선택자의 기호 */ div .cat {   color: red; }  /* 인접 형제 선택자 : 다음 형제 요소 하나를 선택 */ .cat + li {   color: red; }  /* 일반 형제 선택자 : 다음 형제 요소 모두를 선택 */ .cat ~ li {   color: red; }       - 가상 클래스   /* hover : 마우스 커서가 올라가 있는 동안 */ a:hover {   color: red; }  /* active : 마우스를 클릭하고 있는 동안 */ a:active {   color: red; }  /* focus : 포커스되면 선택 */ /* focus가 될 수 있는 요소는 HTML 대화형 콘텐츠가 해당 */ /* input, a, button, label, select 등 여러 요소 */  /* HTML 대화형 콘텐츠 요소가 아니더라도, tabindex 속성을 사용한 요소도 focus가 될 수 있음 */  input:focus {   color: red; }  /* first-child : 형제 요소중 첫째라면 선택*/ .animals div:first-child {   color: red; }  /* last-child : 형제 요소중 막내라면 선택 */ .animals span:last-child {   color: red; }  /* nth-child : 형제 요소중 n째라면 선택 */ .animals *:nth-child(2) {   color: red; } .animals *:nth-child(2n) {   color: red; } .animals *:nth-child(2n+1) {   color: red; }  /* not : 아닌 요소 선택 */ .animals *:not(div) {   color: red; }       - 가상 요소   /* before : 내부 앞에 내용을 삽입 */ .cat::before {   content: \"앞\" }  /* after 내부 뒤에 내용을 삽입 */ .cat::after {   content: \"뒤\" }       - 속성   /* 속성 : 해당 속성을 포함한 요소 선택 */ [disabled] {   color: red; } [type] {   color: red; }  /* 속성-값 : 해당 속성을 포함하고 값이 x인 요소 선택 */ [type=\"password\"] {   color: red; }   스타일 상속   .animals {   color: red; }  &lt;div class=\"ecosystem\"&gt;생태계   &lt;div class=\"animals\"&gt;동물     &lt;div class=\"cat\"&gt;고양이&lt;/div&gt;     &lt;div class=\"dog\"&gt;강아지&lt;/div&gt;     &lt;div class=\"tiger\"&gt;호랑이&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"plant\"&gt;식물&lt;/div&gt; &lt;/div&gt;  생태계   동물     고양이     강아지     호랑이      식물       - 상속되는 CSS 속성들   모두 글자/문자 관련 속성들      font-style   font-weight   font-size   line-height   font-family   color   text-align   …       - 강제 상속      값에 inherit 넣어서 명시하면 상속됨   선택자 우선순위      같은 요소가 여러 선언의 대상이 된 경우, 어떤 선언의 CSS속성을 우선 적용할지 결정하는 방법   점수가 높은 선언 우선   점수가 같으면 마지막에 해석된 선언이 우선   body { color : red; } /* 전체 선택자 : 0점 */ * { color : orange; }  div { color : yellow; } /* 태그 선택자 : 1점 */  .cat { color: green; } /* Class 선택자 : 10점 */  #dog { color: blue; } /* ID 선택자 : 100점 */  &lt;div style=\"color: darkblue;\"&gt;Hi&lt;/div&gt; &lt;!-- 인라인 선언 : 1000점 --&gt;  div { color: purple !important; } /* !important : 999999점 */  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-basic/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 박스모델",
        "excerpt":"박스 모델   - 단위   px 픽셀 % 상대적 백분율 em 요소의 글꼴 크기 rem 루트 요소(html)의 글꼴 크기 vw 뷰포트 가로 너비의 백분율 vh 뷰포트 세로 너비의 백분율       - 색상 표현   이름 : red, royalblue, tomato // 브라우저에서 제공하는 색 이름 Hex 색상코드 : #000, #FFFFFF // 16진수 색상 RGB : rgb(255, 255, 255) // 빛의 삼원색 RGBA : rgba(0, 0, 0, 0.5) // 빛의 삼원색 + 투명도 HSL : hsl(120, 100%, 50%) // 색상, 채도, 명도 HSLA : hsla(120, 100%, 50%, 0.5) // 색상, 채도, 명도 + 투명도       - width, height   /* 요소의 가로/세로 너비 */ width, height {   기본값: auto; 브라우저가 너비를 계산   단위: px, em, vw; }       - max-width, max-height   /* 요소가 커질 수 있는 최대 가로/세로 너비 */ max-width, max-height {   기본값: none; 최대 너비 제한 없음   단위: px, em, vw; }       - min-width, min-height   /* 요소가 작아질 수 있는 최소 가로/세로 너비 */ min-width, min-height {   기본값: 0; 최소 너비 제한 없음   단위: px, em, vw; }       - margin   /* 요소의 외부 여백을 지정하는 단축 속성 */ margin {   기본값: 0; 외부 여백 없음   auto 브라우저가 여백을 계산. 가운데 정렬에 활용   단위: px, em, vw;   음수 사용 가능 }  적용 {   margin: 10px;  /* top, right, bottom, left*/   margin: 10px 20px;  /* top, bottom / left, right */   margin: 10px 20px 30px;  /* top / left, right / bottom */   margin: 10px 20px 30px 40px;  /* top / right / bottom / left */ }  개별 속성 {   margin-top: 10px;   margin-bottom: 10px;   margin-left: 10px;   margin-right: 10px; }       - padding   /* 요소의 내부 여백을 지정하는 단축 속성 */ padding {   기본값: 0; 내부 여백 없음   단위: px, em, vw;   %: 부모 요소의 가로 너비에 대한 비율로 지정   요소의 크기가 커짐 }  적용 {   padding: 10px;  /* top, right, bottom, left*/   padding: 10px 20px;  /* top, bottom / left, right */   padding: 10px 20px 30px;  /* top / left, right / bottom */   padding: 10px 20px 30px 40px;  /* top / right / bottom / left */ }  개별 속성 {   padding-top: 10px;   padding-bottom: 10px;   padding-left: 10px;   padding-right: 10px; }       - border   /* 요소의 테두리 선을 지정하는 단축 속성 */ border {   border: 두께 종류 색상;   요소의 크기가 커짐 }  적용 {   border: 4px solid black; }  두께 {   border-width: px, em, %; }  종류 {   기본값: none; 선 없음   border-style: solid; 실선   border-style: dashed; 파선   border-style: dotted; 점선   border-style: double; 두줄선   border-style: groove; 홈이 파여있는 모양   border-style: ridge; 솟은 모양(groove 반대)   border-style: inset; 요소 전체가 들어간 모양   border-style: outset; 요소 전체가 나온 모양 }  색상 {   기본값: black;   투명: transparent; }  모서리 {   /* 둥글게 깎기 */   기본값: 0;   border-radius: px, em, vw; }       - box-sizing   /* 요소의 크기 계산 기준을 지정 */ box-sizing {   기본값: content-box; 요소의 내용으로 크기 계산   box-sizing: border-box; 요소의 내용 + padding + border로 크기 계산 }       - overflow   /* 내용이 넘쳤을 때, 보여짐을 제어 */ overflow {   기본값: visible; 넘친 내용을 그대로 보여줌   overflow: hidden; 넘친 내용을 잘라냄   overflow: scroll; 넘친 내용을 잘라내고 스크롤바 생성   overflow: auto; 넘친 내용이 있는 경우에만 잘라내고 스크롤바 생성 }  개별속성 {   overflow-x   overflow-y }       - display   /* 화면 출력 특성 */ display {   기본값: block;   기본값: inline;   기본값: inline-block; 각 요소에 이미 지정되어 있는 값   display: flex; 플렉스 박스 (1차원 레이아웃)   display: grid; 그리드 (2차원 레이아웃)   display: none; 보여짐 특성 없음, 화면에서 사라짐   기타: table, table-row, table-cell 등; }       - opacity   /* 요소 투명도 */ opacity {   기본값: 1; 불투명   opacity: 0~1; 0부터 1사이의 소수점 숫자 }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-boxmodel/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-1. 데이터 입출력 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 자료구조 – A   - 자료 구조의 정의      자료의 표현과 그것과 관련된 연산   자료들을 조직하고 구조화하는 것   필요한 모든 연산들을 처리할 수 있음   프로그램 실행시간이 달라짐   - 자료 구조의 분류      선형 구조            배열       선형 리스트                    연속 리스트           연결 리스트                       스택       큐       데크           비선형 구조            트리       그래프           - 배열(Array)      동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합   정적인 자료구조   기억장소 추가가 어려움   데이터 삭제 시 데이터가 저장되어 있던 기억장소가 빈 공간으로 남아있어 메모리 낭비 발생   첨자를 이용하여 데이터에 접근   반복적인 데이터 처리 작업에 적합한 구조   동일한 이름의 변수를 사용하여 처리가 간편   첨자의 개수에 따라 n차원 배열이라고 부름   - 선형 리스트(Linear List)      일정한 순서에 의해 나열된 자료 구조   배열을 이용하는 연속 리스트, 포인터를 이용하는 연결 리스트로 구분   @ 연속 리스트(Contiguous List)      연속되는 기억장소에 저장되는 자료 구조   기억장소 이용 효율은 밀도가 1로서 가장 좋음   데이터 삽입, 삭제 시 자료의 이동이 필요   @ 연결 리스트(Linked List)      자료들을 반드시 연속적으로 배열시키지 않고 노드의 포인터 부분을 이용해서 서로 연결   노드의 삽입, 삭제 작업이 용이   기억공간이 연속적으로 놓여있지 않아도 저장 가능   순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않음   포인터를 찾는 시간이 필요해 접근 속도가 느림   중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘듬   - 스택(Stack)      리스트의 한쪽 끝으로만 자료의 삽입, 삭제가 이루어짐   후입선출(LIFO)   기억공간이 꽉 차있는 상태에서 삽입되면 Overflow 발생   기억공간이 비어있는 상태에서 삭제하면 Underflow 발생   삽입(PUSH), 삭제(POP), 마지막 삽입 자료(Top), 밑바닥(Bottom)   - 큐(Queue)      리스트의 한쪽에서는 삽입, 다른 한쪽에서는 삭제가 이루어짐   선입선출(FIFO)   시작과 끝을 표시하는 두 개의 포인터가 있음   프런트(F, Front) 포인터 : 가장 먼저 삽입된 자료의 기억공간을 가리킴. 삭제 작업   리어(R, Rear) 포인터 : 가장 마지막에 삽입된 자료의 기억공간을 가리킴. 삽입작업   운영체제의 작업 스케줄링에 사용   - 트리(Tree)      정점(Node)과 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 형태   하나의 기억공간을 노드(Node), 노드와 노드를 연결하는 선을 링크(Link)   가족의 계보, 조직도 등을 표현하기 적합   노드 : 자료 항목과 다른 항목에 대한 가지를 합친 것   근 노드(Root Node) : 트리의 맨 위에 있는 노드   차수(Degree) : 각 노드에서 뻗어 나온 가지의 수   단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식이 하나도 없는 노드   자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들   부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들   형제 노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들   트리의 차수 : 노드들의 차수 중에서 가장 많은 수       2. 데이터저장소 / 데이터베이스 / DBMS – A   - 데이터저장소      데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것   논리 데이터 저장소 : 데이터 간 연관성, 제약조건을 식별하여 논리적인 구조로 조직화   물리 데이터 저장소 : 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장   데이터베이스를 구축하는 과정과 동일   - 데이터베이스      상호 관련된 데이터들의 모임   통합된 데이터(Integrated Data) : 중복을 배제한 데이터의 모임   저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료   운영 데이터(Operational Data) : 조직의 고유한 업무를 수행하는 데 없어서는 안 될 자료   공용 데이터(Shared Data) : 공동으로 소유하고 유지하는 자료   - DBMS(DataBase Management System)      사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 S/W   데이터의 종속성과 중복성의 문제를 해결   모든 응용 프로그램들이 DB를 공용할 수 있도록 관리   DB의 구성, 접근 방법, 유지관리에 대한 모든 책임을 짐   DBMS의 필수 기능            정의 기능 : 데이터 Type과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시       조작 기능 : 검색, 갱신, 삽입, 삭제 등의 인터페이스 수단을 제공       제어 기능 : 데이터의 무결성이 유지되도록 제어, 보안 유지, 권한 검사, 병행 제어           장점            데이터의 논리적, 물리적 독립성 보장       데이터의 중복을 피할 수 있어 기억 공간 절약       자료를 공동으로 이용할 수 있음       데이터의 일관성을 유지할 수 있음       데이터의 무결성을 유지할 수 있음       보안을 유지할 수 있음       데이터를 표준화 할 수 있음       통합 관리가 가능       최신의 데이터 유지 가능       실시간 처리 가능           단점            DB 전문가 부족       전산화 비용 증가       Overhead 발생       Backup과 Recovery이 어려움       시스템이 복잡           - 데이터의 독립성      데이터의 독립성은 DBMS의 궁극적 목표   논리적 독립성 : 데이터의 논리적 구조를 변경해도 응용 프로그램은 변경되지 않음   물리적 독립성 : 응용 프로그램에는 영향을 주지 않고, 데이터의 물리적 구조만을 변경       3. 데이터 입출력 – B   - 데이터 입출력 개요      DB에 데이터를 입력하거나 출력하는 작업   데이터를 조작하는 모든 행위를 의미. SQL 사용   개발 코드 내에 SQL 코드를 삽입하거나, 객체와 데이터를 연결하는 데이터 접속(Data Mapping)   논리적 기능을 수행하기 위한 작업의 단위 또는 한번에 수행되야 할 연산들을 트랜잭션이라고 함   - SQL(Structured Query Language)      많은 회사에서 관계형 데이터베이스(RDB)를 지원하는 언어로 채택   관계대수와 관계해석을 기초로 한 혼합 데이터   질의어지만 질의 기능뿐만 아니라, 데이터 구조 정의, 조작, 제어기능을 모두 갖춤   데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 구분            DDL : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의, 변경, 삭제       DML : 저장된 데이터를 실질적으로 처리       DCL : 보안, 무결성, 회복, 병행수행 제어 등을 정의하는데 사용           - 데이터 접속(Data Mapping)      프로그래밍 코드와 DB의 데이터를 연결하는 것   SQL Mapping : 코드 내에 SQL을 직접 입력하여 DBMS 객체에 접속. JDBC, ODBC, MyBatis   ORM(Object-Relational Mapping) : 객체와 RDB의 데이터를 연결. JPA, Hibernate, Django   - 트랜잭션(Transaction)      DB 상태를 변환시키는 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행돼야 할 연산   TCL : 트랜잭션을 제어하기 위한 명령어. COMMIT, ROLLBACK, SAVEPOINT            COMMIT : 트랜잭션이 수행한 변경 내용을 DB에 저장       ROLLBACK : 모든 변경 작업을 취소하고 이전 상태로 되돌림       SAVEPOINT(=CHECKPOINT) : ROLLBACK 할 저장점을 지정               4. 절차형 SQL – B   - 절차형 SQL 개요      프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL   프로그래밍 언어에 비해 효율은 떨어지지만, 연속적인 작업들을 처리하는데 적합   다양한 기능을 수행하는 저장 모듈 생성할 수 있음   DBMS 엔진에서 직접 실행돼 입출력 패킷이 적은 편   BEGIN ~ END 형식의 블록 구조로 되어 있어 기능별 모듈화 가능   프로시저 : 트랜잭션 언어, 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업 수행   트리거 : 이벤트가 발생할 때마다 관련 작업이 자동으로 수행   사용자 정의 함수 : 예약어 RETURN을 사용하여 처리 결과를 단일값으로 반환   - 절차형 SQL의 테스트와 디버깅      디버깅을 통해 기능의 적합성 여부를 검증, 실행을 통해 결과를 테스트   테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부 확인   SHOW  명령어를 통해 내용을 확인하고 문제를 수정   디버깅을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인   DB에 변화를 줄 수 있는 삽입 등의 SQL 문을 주석으로 처리하고, 출력문을 이용해 확인   - 쿼리 성능 최적화      데이터 입출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화   성능 측정 도구인 APM을 사용하여 최적화 할 쿼리 선정   옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp5/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-2. 통합 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 단위 모듈 테스트 – B   - 단위 모듈 테스트의 개요      모듈이 정해진 기능을 정확히 수행하는지 검증   단위 테스르라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법 사용   모듈을 단독적으로 실행할 수 있는 환경과 테스트에 필요한 데이터 모두 준비   에러를 쉽게 발견하고 수정할 수 있음   시스템 수준의 오류는 잡아낼 수 없음   - 테스트 케이스      사용자의 요구사항을 정확하게 준수했는지를 확인하기 위함   테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당   직관적인 테스트는 검증이 누락되거나 불필요한 반복으로 인력과 시간을 낭비 할 수 있음   ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스 구성 요소            식별자       테스트 항목       입력 명세       출력 명세       환경 설정       특수 절차 요구       의존성 기술           - 테스트 프로세스      게획 및 제어 -&gt; 분석 밀 설계 -&gt; 구현 및 실현 -&gt; 평가 -&gt; 완료       2. 개발 지원 도구 – B   - 통합 개발 환경(IDE; Integrated Development Environment)      편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공   통합 개발 환경을 제공하는 S/W   코드의 자동 생성 및 컴파일 가능, 추가 기능을 위한 도구를 추가할 수 있음   오류가 발생할 부분을 시각화하므로 수정이 용이   다양한 서비스와 연동하여 개발에 편의를 제공하고 필요한 정보를 공유   이클립스, 비주얼 스튜디오, 엑스 코드, 안드로이드 스튜디오, IDEA 등   - 빌드 도구      빌드는 소스 코드 파일들을 실행할 수 있는 제품 S/W로 변환하는 과정 또는 결과물   전처리, 컴파일 등의 작업들을 수행하는 S/W   Ant            자바 프로젝트의 공식 빌드 도구       XML 기반의 빌드 스크립트, 자유도와 유연성이 높음       개발자가 모든 것을 정의, 스크립트 재사용이 어려움           Maven            Ant의 대안으로 개발됨       규칙이나 표준이 존재하여 예외 사항만 기록, 컴파일과 빌드를 동시에 수행       의존성을 설정하여 라이브러리를 관리           Gradle            Ant와 Mavn을 보완하여 개발       안드로이드 스튜디오의 공식 빌드 도구       의존성을 활용하여 Groovy 기반의 빌드 스크립트 사용           - 기타 협업 도구      서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구   업무 보조 도구 포함   다양한 플랫폼에서 사용할 수 있도록 제공   익숙하지 않거나 이용할 의지가 없으면 오히려 협업의 방해 요소가 될 수 있음   협업 도구 종류            일정 관리 : Google Calendar, Wunderlist, Trello, Jira, Flow       정보 공유 및 커뮤니케이션 : Slack, Jandi, Taskworld       디자인 : Sketch, Zeplin       기타 : Evernote(아이디어 공유), Swagger(API 문서화로 협업도움), Github          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp6/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-3. 제품 소프트웨어 패키징",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 패키징 – B   - 소프트웨어 패키징의 개요      모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것   사용자를 중심으로 진행   모듈화하여 패키징   일반적인 배포 형태로 패키징   사용자의 편의성 및 실행 환경을 우선적으로 고려   - 패키징 시 고려사항      사용자의 시스템 환경에 필요한 최소 환경을 정의   UI는 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 매뉴얼과 일치   하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공   편의성을 고려한 안정적인 배포가 중요   패키징의 변경 및 개선에 대한 관리를 항상 고려   - 패키징 작업 순서      애자일 기법의 경우 2~4주 내에서 지정하며, 각 주기가 끝날 때마다 패키징 수행   주기별로 패키징한 결과물은 테스트 서버에 배포   최종 패키징한 결과물은 사용할 수 있도록 온라인 또는 오프라인으로 배포   기능 식별 -&gt; 모듈화 -&gt; 빌드 -&gt; 사용자 환경 분석 -&gt; 패키징 및 적용시험 -&gt; 패키징 변경 개선 -&gt; 배포       2. 릴리즈 노트 작성 – B   - 릴리즈 노트의 개요      릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서   테스트 진행 방법에 대한 결과와 S/W 사양에 대한 개발팀의 정확한 준수 여부 확인 가능   전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유   버전 관리나 릴리즈 정보를 체계적으로 관리   초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시에 제공   포함된 기능이나 사용 환경에 대한 내용을 확인   개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공   철저한 테스트를 거친 것, 사양에 대한 최종 승인을 얻은 후 문서화 되어 제공   - 릴리즈 노트 초기 버전 작성 시 고려사항      정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성   변경 또는 개선된 항목에 대한 이력 정보들도 작성   표준 형식은 없음   - 릴리즈 노트 추가 버전 작성 시 고려사항      특수한 상황이 발생하는 경우 릴리즈 노트를 추가로 작성   모든 수정된 내용을 담아 릴리즈 노트를 작성   기능 업그레이드를 완료한 경우에는 릴리즈 버전을 출시하고 릴리즈 노트를 작성   요구사항에 의해 추가나 수정된 경우 별도의 릴리즈 버전으로 출시하고 릴리즈 노트 작성   - 릴리즈 노트 작성 순서      모듈 식별 -&gt; 릴리즈 정보 확인 -&gt; 릴리즈 노트 개요 작성 -&gt; 영향도 체크 -&gt; 정식 릴리즈 노트 작성 -&gt; 추가 개선 항목 식별       3. 디지털 저작권 관리(DRM) – A      저작권이란 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한   복제하기 쉬운 저작물에 대해 이를 막기 위한 기술적인 방법을 통칭해 저작권 보호 기술이라 함   - 디지털 저작권 관리(DRM; Digital Right Management)의 개요      디지털 콘텐츠 관리 및 보호 기술   원본 콘텐츠가 아날로그인 경우 디지털로 변환한 후 패키저로 DRM 패키징 수행   크기가 작은 경우 실시간 패키징 수행, 크기가 큰 경우 미리 패키징 수행 후 배포   패키징을 수행하면 암호화된 전자서명이 포함되고 라이선스 정보가 클리어링 하우스에 등록   콘텐츠를 사용하기 위해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인   종량제 방식을 적용한 경우 실제 사용량을 측정하여 이용한 만큼의 요금 부과   - 디지털 저작권 관리의 흐름도      클리어링 하우스 : 저작권에 대한 사용 권한, 라이선스 발급, 결제 관리 등 수행   콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자   패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램   콘텐츠 분배자 : 암호화된 콘텐츠를 유통하는 곳이나 사람   콘텐츠 소비자 : 콘텐츠를 구매해서 사용하는 주체   DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램   보안 컨테이너 : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치   - 디지털 저작권 관리의 기술 요소      암호화(Encryption) : 콘텐츠를 암호화하고 전자 서명을 할 수 있는 기술   키 관리(Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술   암호화 파일 생성(Packager) : 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술   식별 기술(Identification) : 콘텐츠에 대한 식별 체계 표현 기술   저작권 표현(Right Expression) : 라이선스의 내용 표현 기술   정책 관리(Policy Management) : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술   크랙 방지(Tamper Resistance) : 크랙에 의한 콘텐츠 사용 방지 기술   인증(Authentication) : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술       4. 소프트웨어 버전 등록 – B   - 소프트웨어 패키징의 형상 관리      형상관리(SCM)는 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동   S/W 변경의 원인을 알아내고 제어, 적절히 변경되고 있는지 확인하며 해당 담당자에게 통보   S/W 개발의 전 단계에 적용되는 활동. 유지보수 단계에서도 수행   S/W 개발의 전체 비용을 줄이고, 방해 요인이 최소화되도록 보증   - 형상 관리의 중요성      변경 사항을 체계적으로 추적하고 통제할 수 있음   무절제한 변경을 방지할 수 있음   발견된 버그나 수정 사항을 추적할 수 있음   S/W는 형태가 없어 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로 사용   - 형상 관리 기능      형상 식별 : 이름과 관리 번호를 부여, Tree 구조로 구분하여 수정 및 추적이 용이하도록 함   버전 제어 : 다른 버전의 형상 항목을 관리, 특정 절차와 도구를 결합   형상 통제 : 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정   형상 감사 : 기준선의 무결성을 평가하기 위해 공식적으로 승인하는 작업   형상 기록 : 결과를 기록, 관리하고 보고서를 작성하는 작업   - 소프트웨어의 버전 등록 관련 주요 용어      Repository : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장   Import : 아무것도 없는 저장소에 처음으로 파일을 복사   Check-Out : 저장소에서 파일을 받아옴. 버전관리를 위한 파일들도 받아옴   Check-In : 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신   Commit : 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료   Update : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화   - 소프트웨어 버전 등록 과정      Import -&gt; Check-Out -&gt; Commit -&gt; Update -&gt; Diff       5. 소프트웨어 버전 관리 도구 – A   - 공유 폴더 방식      로컬 컴퓨터의 공유 폴더에 저장되어 관리   약속된 공유 폴더에 매일 복사   담당자는 파일을 자기 PC로 복사한 후 컴파일 하여 이상 유무를 확인   파일 오류가 확인되면, 개발자에게 수정 의뢰   이상 없으면 개발자들이 동작 여부 다시 확인   파일의 변경 사항을 DB에 기록하여 관리   SCCS, RCS, PVCS, QVCS   - 클라이언트/서버 방식      버전 관리 자료가 중앙 시스템에 저장되어 관리되는 방식   서버의 자료를 PC로 복사하여 작업한 후 변경된 내용을 서버에 반영   모든 버전 관리는 서버에서 수행   하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력   서버에 문제가 생기면 협업 및 버전 관리 작업 중단   CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce   @ Subversion(서브버전, SVN)      CVS를 개선한 것   서버에는 최신 버전의 파일들과 변경 내역이 관리   서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영   모든 개발 작업은 trunk 디렉터리에서 수행   추가 작업은 branches 디렉터리 안에 별도의 디렉터리 만들어 작업   완료후 trunk 디렉터리와 병합   커밋 할 때마다 리비전이 1씩 증가   서버는 주로 유닉스 사용   소스가 오픈되어 있어 무료로 사용 가능   CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능   - 분산 저장소 방식      하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리   작업한 후 변경된 내용을 로컬에서 우선 반영한 후, 이를 원격 저장소에 반영   원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업할 수 있음   @ Git      로컬 저장소와 원격 저장소 존재   로컬 저장소는 실제 개발을 진행하는 장소로, 버전 관리가 수행   원격 저장소는 버전을 공동 관리하는 곳   버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업 가능   branch를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능   파일의 변화를 스냅샷으로 저장. 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름 파악 가능       6. 빌드 자동화 도구 – B   - 빌드 자동화 도구의 개념      빌드란 소스 코드 파일들을 컴파일한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정   빌드 자동화 도구는 빌드를 포함하여 테스트 및 배포를 자동화하는 도구   애자일 환경같은 지속적인 통합 개발 환경에서 유용하게 활용   - Jenkins      Jenkins는 Java 기반의 오픈소스 형태, 가장 많이 사용되는 빌드 자동화 도구   서블릿 컨테이너에서 실행되는 서버 기반 도구   SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능   친숙한 Web GUI 제공으로 사용이 쉬움   여러 대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능   - Gradle      Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구. 안드로이드 앱 개발 환경에서 사용   플러그인을 설정하면 Java, C/C++, Python 등의 언어도 빌드 가능   Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용   실행할 처리 명령을 모아 Task로 만든 후 Task 단위로 실행   Task를 재사용하거나 공유할 수 있는 빌드 캐시 기능을 지원해 빌드의 속도를 향상시킬 수 있음  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp7/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-4. 애플리케이션 테스트 관리",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 애플리케이션 테스트 – B   - 애플리케이션 테스트의 개념      잠재되어 있는 결함을 찾아내는 일련의 행위   고객의 요구사항을 만족시키는지 확인(Validation)   기능을 정확히 수행하는지 검증(Verrfication)   개발할 소프트웨어의 유형을 분류하고 특성을 정리해서 중점적으로 테스트할 사항을 정리   - 애플리케이션 테스트의 필요성      프로그램 실행 전에 오류를 발견하여 예방   제품의 신뢰도 향상   새로운 오류의 유입 예방   최소한의 시간과 노력으로 많은 결함을 찾아낼 수 있음   - 애플리케이션 테스트의 기본 원리      잠재적인 결함은 줄일 수 있지만 완벽한 소프트웨어 테스팅은 불가능   결함 대부분은 특정 모듈에 집중. 20%의 코드에서 80%의 결함이 발견. 파레토 법칙 적용   동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 살충제 패러독스 발생   정황에 따라 테스트를 다르게 수행   결함을 제거해도 요구사항을 만족시키지 못하면 품질이 높다고 말할 수 없음. 오류 부재의 궤변   테스트와 위험은 반비례   작은 부분에서 시작하여 점점 확대하며 진행   개발자와 관계없는 별도의 팀에서 수행       2. 애플리케이션 테스트의 분류 – B   - 프로그램 실행 여부에 따른 테스트   @ 정적 테스트      프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석   개발 초기에 결함 발견 가능. 개발 비용을 낮출 수 있음   워크스루, 인스펙션, 코드 검사 등   @ 동적 테스트      프로그램을 실행하여 오류를 찾는 테스트. 개발 모든 단계에서 수행 가능   블래박스 테스트, 화이트박스 테스트   - 테스트 기반에 따른 테스트   @ 명세 기반 테스트      요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인   동등 분할, 경계 값 분석 등   @ 구조 기반 테스트      내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인   구문 기반, 결정 기반, 조건 기반 등   @ 경험 기반 테스트      유사 소프트웨어나 기술 등에 대한 경험을 기반으로 함   요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 효과적   에러 추정, 체크 리스트, 탐색적 테스팅   - 시각에 따른 테스트   @ 검증(Verification) 테스트      개발자의 시각에서 명세서대로 완성됐는지 테스트   @ 확인(Validation) 테스트      사용자의 시각에서 요구한대로 제품이 완성됐는지, 정상 동작하는지 테스트   - 목적에 따른 테스트   @ 회복 테스트      결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인   @ 안전 테스트      불법적인 침입으로부터 시스템을 보호할 수 있는지 확인   @ 강도 테스트      과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 정상적으로 실행되는지 확인   @ 성능 테스트      실시간 성능이나 전체적인 효율성을 진단하는 테스트   @ 구조 테스트      내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트   @ 회귀 테스트      변경 또는 수정된 코드에 새로운 결함이 없음을 확인   @ 병행 테스트      기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교       3. 테스트 기법에 따른 애플리케이션 테스트 – A   - 화이트박스 테스트      원시 코드를 오픈시킨 상태에서 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계   구조적 테스트. 프로시저 설계의 제어 구조를 사용하여 테스트 케이스를 설계   테스트 과정의 초기에 적용   모듈 안의 작동을 직접 관찰   모든 문장을 한 번 이상 실행하여 수행   선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어   - 화이트박스 테스트의 종류   @ 기초 경로 검사      대표적인 화이트박스 테스트 기법   절차적 설계의 논리적 복잡성을 측정할 수 있게 해줌   실행 경로의 기초를 정의하는 데 지침으로 사용   @ 제어 구조 검사      조건 검사 : 논리적 조건을 테스트하는 설계 기법   루프 검사 : 반복 구조에 초점을 맞춰 실시하는 설계 기법   데이터 흐름 검사 : 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 설계 기법   - 화이트박스 테스트의 검증 기준      문장 검증 기준 : 모든 구문이 한 번 이상 수행되도록 설계   분기 검증 기준 : 모든 조건문이 한 번 이상 수행되도록 설계   조건 검증 기준 : 모든 조건문에 대해 조건문이 True, False 경우가 한 번 이상 수행되도록 설계   분기/조건 기준 : 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True, False인 경우가 한 번 이상 수행되도록 설계   - 블랙박스 테스트      각 기능이 완전히 작동되는 것을 입증하는 테스트. 기능 테스트   요구사항 명세서를 보면서 테스트하는 것. 구현된 기능을 테스트   인터페이스에서 실시되는 테스트   테스트 과정의 후반부에 적용   - 블랙박스 테스트의 종류   @ 동치 분할 검사      입력 자료에 초점을 맞춰 검사   타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 함. 자료에 맞는 결과가 출력되는지 확인   @ 경계값 분석      동치 분할 기법을 보완하기 위함   중간값보다 경계값에서 오류가 발생될 확률이 높다는 점 이용   입력 조건의 경계값을 테스트 케이스로 선정하여 검사   @ 원인-효과 그래프 검사      입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 후 효용성 높은 케이스 선정하여 검사   @ 오류 예측 검사      과거의 경험이나 확인자의 감각으로 테스트   보충적 검사 기법. 데이터 확인 검사   @ 비교 검사      여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트       4. 개발 단계에 따른 애플리케이션 테스트 – A   - 개발 단계에 따른 애플리케이션 테스트      코드 상의 오류뿐만 아니라 요구 분석의 오류, 설계 인터페이스 오류 등도 발견할 수 있음   애플리케이션 테스트 + 소프트웨어 개발 단계 = V-모델   요구사항 -&gt; 분석 -&gt; 설계 -&gt; 구현 -&gt; // 단위테스트 -&gt; 통합테스트 -&gt; 시스템티스트 -&gt; 인수테스트   - 단위 테스트(Unit Test)      설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트   사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행   구조 기반 테스트와 명세기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행            구조 기반 테스트 : 화이트박스 테스트       명세 기반 테스트 : 블랙박스 테스트           - 통합 테스트(Integration Test)      단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트   모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사   - 시스템 테스트(System Test)      개발된 S/W가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검   실제 사용 환경과 유사하게 만든 테스트 환경에서 수행   기능적 요구사항 : 블랙박스 테스트 시행   비기능적 요구사항 : 화이트박스 테스트 시행   - 인수 테스트(Acceptance Test)      개발한 S/W가 사용자의 요구사항을 충족하는지에 중점   사용자가 직접 테스트   문제가 없으면 사용자는 S/W를 인수하고 프로젝트 종료   사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부 확인   운영상의 인수 테스트 : 시스템 관리자가 수행   계약 인수 테스트 : 계약상의 인수/검수 조건을 준수하는지 여부 확인   규정 인수 테스트 : 규정에 맞게 개발되었는지 확인   알파 테스트            개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트       통제된 환경에서 시행. 문제점을 사용자와 개발자가 함께 확인           베타 테스트            최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트       사용자가 직접 테스트       개발자에 의해 제어되지 않은 상태에서 테스트       오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고               5. 통합 테스트 – A      단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트   비점진적 통합 방식            모든 모둘이 미리 결합되어 있는 프로그램 전체를 테스트. 빅뱅 통합 테스트       규모가 작은 소프트웨어에 유리. 단시간 내에 테스트 가능       오류 발견 및 장애 위치 파악 및 수정이 어려움           점진적 통합 방식            모듈 단위로 단계적으로 통합하면서 테스트. 하향식, 상향식, 혼합식       오류 수정이 용이하고, 인터페이스와 연관된 오류를 완전히 테스트 할 가능성 높음           - 하향식 통합 테스트      상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트   깊이 우선 통합법이나 넓이 우선 통합법 사용   테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음   상위 모듈에서는 테스트 케이스를 사용하기 어려움   절차            주요 제어 모듈은 작성된 프로그램 사용. 종속 모듈은 Stub으로 대체       하위 모듈인 Stub들이 한 번에 하나씩 실제 모듈로 교체됨       모듈이 통합될 때마다 테스트를 실시       새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시           - 상향식 통합 테스트      하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트   Stub은 필요하지 않지만, 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 Cluster가 필요 -절차            하위 모듈들을 Cluster로 결합       더미 모듈인 Driver를 작성       통합된 클러스터 단위로 테스트       테스트가 완료되면 Cluster는 프로그램 구조의 상위로 이동하여 결합하고 Driver는 실제 모듈로 대체           - 테스트 Driver와 Stub의 차이점                  구분       Driver       Stub                       필요시기       상위 모듈 없음       하위 모듈 없음                 테스트방식       상향식       하향식                 공통점       소프트웨어 개발과 테스트를 병행할 경우 이용                         차이점       인터페이스 역할, 원래 모듈로 교체       가짜 모듈의 역할, 작성하기 쉬움           - 혼합식 통합 테스트      하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합. 샌드위치식 통합 테스트 방법   - 회귀 테스팅      이미 테스트된 프로그램의 테스팅을 반복하는 것   변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트   반복해서 테스트 함   변경된 부분을 테스트할 수 있는 테스트 케이스만을 선정하여 수행   대표적인 테스트 케이스를 선정   파급 효과가 높은 부분이 포함된 테스트 케이스를 선정   실제 수정이 발생한 모듈 또는 컴포넌트에서 시행하는 테스트 케이스 선정       6. 애플리케이션 테스트 프로세스 – B   - 애플리케이션 테스트 프로세스      사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트   계획 -&gt; 분석 및 디자인 -&gt; 테스트 케이스 및 시나리오 작성 -&gt; 수행 -&gt; 결과 평가 및 리포팅 -&gt; 결함 추적 및 관리       7. 테스트 케이스 / 테스트 시나리오 / 테스트 오라클 – B   - 테스트 케이스      구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 명세 기반 테스트의 설계 산출물   검토 및 자료확보 -&gt; 위험 평가 및 우선순위 결정 -&gt; 요구사항 정의 -&gt; 구조 설계 및 방법 결정 -&gt; 테스트 케이스 정의 -&gt; 타당성 확인 및 유지 보수   - 테스트 시나리오      테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합. 구체적인 절차를 명세한 문서   테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정   테스트 순서를 미리 정함으로써 테스트 항목을 빠짐없이 수행   작성시 유의사항            여러 개의 시나리오로 분리하여 작성       사용자의 요구사항과 설계 문서 등을 토대로 작성       유스케이스간 업무 흐름이 정상적인지를 테스트 할 수 있도록 작성       개발된 모듈 또는 프로그램 간의 연계가 정상적으로 동작하는지 테스트할 수 있도록 작성           - 테스트 오라클      테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법   결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 게산하거나 확인   특징            제한된 검증 : 모든 테스트 케이스에 적용할 수 없음       수학적 기법 : 수학적 기법을 이용하여 구할 수 있음       자동화 가능 : 실형, 결과 비교, 커버리지 측정 등을 자동화 할 수 있음           종류            참 오라클 : 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공. 모든 오류 검출       샘플링 오라클 : 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과 제공       추정 오라클 : 샘플링 오라클 개선. 나머지 입력 값들에 대해서 추정으로 처리       일관성 검사 : 변경이 있을 때, 수행 전과 후의 결과 값이 동일한지 확인               8. 테스트 자동화 도구 – B   - 테스트 자동화의 개념      반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용한 것   휴먼 에러를 줄이고 테스트 정확성을 유지하면서 품질을 향상시킴   - 테스트 자동화 도구의 장점 / 단점      장점            반복적인 작업을 자동화하여 인력 및 시간을 줄임       향상된 테스트 품질 보장       요구사항 등을 일관성 있게 검증       객관적인 평가 기준을 제공       다양한 표시 형태로 제공       UI가 없는 서비스도 정밀 테스트 가능           단점            도구의 사용 방법에 대한 교육 및 학습 필요       프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요       비공개 상용 도구의 경우 고가의 추가 비용 필요           - 테스트 자동화 수행 시 고려사항      재사용 및 측정이 불가능한 테스트 프로그램은 제외   용도에 맞는 적절한 도구를 선택해서 사용   환경 설정 및 습득 기간을 고려해서 프로젝트 일정을 계획   프로젝트 초기에 테스트 엔지니어의 투입 시기를 계획   - 테스트 자동화 도구의 유형      정적 분석 도구            프로그램을 실행하지 않고 분석       작성된 소스 코드를 이해하고 있어야만 분석 가능           테스트 실행 도구            스크립트 언어를 사용하여 테스트를 실행       데이터 주도 접근 방식       키워드 주도 접근 방식           성능 테스트 도구            인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부 확인           테스트 통제 도구            테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행       형상 관리 도구, 결함 추적/관리 도구 등           테스트 하네스 도구            애플리케이션의 컴포넌트 및 모듈을 테스트하는 환경의 일부분       테스트를 지원하기 위해 생성된 코드와 데이터를 의미       테스트가 실행될 환경을 시뮬레이션 하여 정상적으로 테스트되도록 함       구성 요소                    테스트 드라이버 : 모듈 테스트 수행 후의 결과를 도출           테스트 스텁 : 타 모듈의 기능을 단순히 수행하는 도구           테스트 슈트 : 테스트 케이스의 집합           테스트 케이스 : 테스트 항목의 명세서           테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서           목 오브젝트 : 예정된 행위를 수행하는 객체                               9. 결함 관리 – B   - 결함의 정의      설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것   - 결함 관리 프로세스      계획 -&gt; 기록 -&gt; 검토 -&gt; 수정 -&gt; 재확인 -&gt; 추적 및 모니터링 -&gt; 분석 및 보고서 작성   - 결함 추적 순서      등록 -&gt; 검토 -&gt; 할당 -&gt; 수정 -&gt; 조치 보류 -&gt; 종료 -&gt; 해제   - 결함 관리 도구      Mantis : 단위별 작업 내용 기록하여 결함 추적 가능   Trac : 결함 추적은 물론 결함을 통합하여 관리   Redmine : 프로젝트 관리 및 결함 추적 가능   Bugzilla : 결함을 지속적으로 관리할 수 있는 도구. 결함의 심각도와 우선 순위 지정 가능  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp8/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-5. 인터페이스 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 모듈 연계를 위한 인터페이스 기능 식별 – A   - 모듈 연계의 개요      모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것   @ EAI(Enterprise Application Integration)      기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션   비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확장성을 높임   Point-to-Point            1 : 1 연결       변경 및 재사용이 어려움           Hub &amp; Spoke            허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식       확장 및 유지 보수가 용이       허브 장애 발생 시 시스템 전체에 영향을 미침           Message Bus(ESB 방식)            미들웨어를 두어 처리하는 방식       확장성이 뛰어나며 대용량 처리가 가능           Hybrid            Hub &amp; Spoke와 Message Bus의 혼합 방식       그룹 내에서는 Hub &amp; Spoke, 그룹 간에는 Message Bus 방식 사용       한 가지 방식으로 EAI 구현 가능       데이터 병목 현상을 최소화           @ ESB(Enterprise Service Bus)      애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션   통합 측면에서 EAI와 유사하지만, 애플리케이션 보다는 서비스 중심의 통합을 지향   특정 서비스에 국한되지 않고 범용적으로 사용하기 위해 결합도를 약하게 유지   관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원 가능       2. 인터페이스 기능 구현 정의 – B   - 인터페이스 기능 구현 정의에 대한 개요      인터페이스를 실제로 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술   컴포넌트 명세서 확인 -&gt; 인터페이스 명세서 확인 -&gt; 일관된 인터페이스 기능 구현 정의 -&gt; 정의된 인터페이스 기능 구현 정형화   - 모듈 세부 설계서      모듈의 구성 요소와 세부적인 동작 등을 정의한 설계서   컴포넌트 명세서            컴포넌트의 개요 및 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세 등을 정의           인터페이스 명세서            컴포넌트 명세서의 항목 중 인터페이스 클래스의 세부 조건 및 기능 등을 정의               3. 인터페이스 예외 처리 – B   - 인터페이스 예외 처리의 개요      구현된 인터페이스가 동작하는 과정에서 기능상 예외 상황이 발생 했을 때 이를 처리하는 절차   - 데이터 통신을 이용한 인터페이스 예외 처리      JSON, XML 등 인터페이스 객체를 이용해 구현한 인터페이스 동작이 실패한 경우를 대비   예외 케이스를 정의하고 각 예외 케이스마다 예외 처리 방법을 기술   - 인터페이스 엔티티를 이용한 인터페이스 예외 처리      동작이 실패할 경우를 대비해 해당 엔티티에 인터페이스의 실패 상황과 원인 등을 기록하고 사용자 및 관리자에서 알려주는 방식       4. 인터페이스 보안 – B   - 인터페이스 보안의 개요      보안 취약점을 분석한 후 적절한 보안 기능을 적용   - 인터페이스 보안 기능 적용      네트워크 영역            스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화 설정       IPSec, SSL, S-HTTP 등의 방식으로 적용           애플리케이션 영역            애플리케이션 코드 상의 보안 취약점을 보완하는 방향           데이터베이스 영역            접근 권한과 프로시저, 트리거 등 DB 동작 객체의 보안 취약점에 보안 기능을 적용       암호화나 익명화 등 데이터 자체의 보안 방안도 고려               5. 연계 테스트 – B   - 연계 테스트의 개요      연계 시스템과 구성 요소가 정상적으로 동작하는지 확인하는 활동   연계 테스트 케이스 작성 -&gt; 연계 테스트 환경 구축 -&gt; 수행 -&gt; 검증       6. 인터페이스 구현 검증 – A   - 인터페이스 구현 검증의 개요      인터페이스가 정상적으로 문제없이 작동하는지 확인하는 것   - 인터페이스 구현 검증 도구      검증하기 위해서 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 통합 테스트 필요   테스트 자동화 도구를 이용하면 효율적으로 수행 가능   xUnit            Java, C++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크           STAF            서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원           FItNesse            웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원           NTAF            협업 기능과 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크           Selenium            다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크           watir            Ruby를 사용하는 애플리케이션 테스트 프레임워크           - 인터페이스 구현 감시 도구      인터페이스 동작 상태를 APM을 사용하여 모니터링 할 수 있음   종합적인 정보를 조회하고 분석할 수 있음   Scouter, Jennifer 등   APM            리소스 방식 : Nagios, Zabbix, Cacti 등       End-to-End 방식 : VisualVM, Jennifer, Scouter 등          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp9/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-1. 논리 데이터베이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 데이터베이스 설계 – A   - 데이터베이스 설계의 개념      DB 구조에 맞게 변형한 후 DBMS로 DB를 구현하여 일반 사용자들이 사용하게 하는 것   - 데이터베이스 설계 시 고려사항      무결성 : 저장된 데이터가 정해진 제약 조건을 항상 만족   일관성 : 특정 질의에 대한 응답이 처음부터 끝까지 일정해야 함   회복 : 장애 발생 직전의 상태로 복구할 수 있어야 함   보안 : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호   효율성 : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화   DB 확장 : 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함   - 데이터베이스 설계 순서      요구조건 분석 -&gt; 개념적 설계 -&gt; 논리적 설계 -&gt; 물리적 설계 -&gt; 구현   - 요구 조건 분석      DB를 사용할 사람들로부터 필요한 용도를 파악하는 것   사용자에 따른 수행 업무와 필요 데이터 수집   요구 조건 명세서 작성   - 개념적 설계(정보 모델링, 개념화)      현실 세계에 대한 인식을 추상적 개념으로 표현   개념 스키마 모델링과 트랜잭션 모델링을 병행 수행   DBMS에 독립적인 E-R 다이어그램으로 작성   DBMS에 독립적인 개념 스키마 설계   - 논리적 설계(데이터 모델링)      특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정   논리적 구조의 데이터로 모델화   개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계   트랜잭션의 인터페이스를 설계   RDB라면 테이블을 설계하는 단계   - 물리적 설계(데이터 구조화)      논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환   DB 파일의 저장 구조 및 액세스 경로 결정   데이터가 컴퓨터에 저장되는 방법을 묘사   - 데이터베이스 구현      도출된 데이터베이스 스키마를 파일로 생성하는 과정   DDL을 이용하여 DB 스키마를 기술한 후 컴파일하여 빈 DB 파일 생성   빈 DB 파일에 데이터 입력   응용 프로그램을 위한 트랜잭션 작성   DB 접근을 위한 응용 프로그램 작성       2. 데이터 모델의 개념 – B   - 데이터 모델의 정의      현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형   데이터 모델 구성 요소 : 객체, 속성, 관계   데이터 모델 종류 : 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델   데이터 모델에 표시할 요소 : 구조, 연산, 제약 조건   - 데이터 모델의 구성 요소      개체(Entity) : 현실 세계의 대상체   속성(Attribute) : 데이터의 가장 작은 논리적 단위. 데이터 항목 또는 데이터 필드에 해당   관계(Relationship) : 개체 간의 관계 또는 속성 간의 논리적인 연결   - 개념적 데이터 모델      현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정   타입들 간의 관계를 이용하여 현실 세계를 표현   정보 모델이라고도 함   E-R 모델   - 논리적 데이터 모델      개념적 구조를 컴퓨터가 처리할 수 있도록 변환하는 과정   데이터 타입과 이들간의 관계를 이용하여 현실 세계를 표현   특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용   관계 모델, 계층 모델, 네트워크 모델   - 데이터 모델에 표시할 요소      구조 : 데이터 구조 및 정적 성질   연산 : 실제 데이터를 처리하는 작업에 대한 명세   제약 조건 : 실제 뎅터의 논리적인 제약 조건       3. 데이터 모델의 구성요소 - 개체(Entity) – A   - 개체의 정의 및 특징      DB에 표현하려는 것. 현실 세계의 대상체   어떤 정보를 제공하는 역할   영속적으로 존재하는 개체의 집합   독립적으로 존재하거나 그 자체로서도 구별 가능   유일한 식별자에 의해 식별 가능   업무 프로세스에 의해 이용됨   다른 개체와 하나 이상의 관계가 있음   - 개체명 지정 방법      해당 업무에서 사용하는 용어로 지정   약어 사용은 제한   단수 명사 사용   개체명은 유일해야 함   의미에 따라 이름을 부여       4. 데이터 모델의 구성요소 - 속성(Attribute) – B   - 속성의 정의 및 특징      DB를 구성하는 가장 작은 논리적 단위   데이터 항목 또는 데이터 필드에 해당   개체를 구성하는 항목   개체의 특성을 기술   속성의 추를 Degree 또는 차수라고 함   - 속성의 종류   @ 속성의 특성에 따른 분류      기본 속성            업무 분석을 통해 정의한 속성       가장 많고 일반적       업무상 코드로 정의한 속성은 기본 속성에서 제외           설계 속성            설계 과정에서 도출해내는 속성       데이터 모델링을 위해 업무를 규칙화하려고 새로 만들거나 변형하여 정의하는 속성           파생 속성            다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성       되도록 적은 수를 정의하는 것이 좋음           @ 개체 구성 방식에 따른 분류      기본키 속성 : 개체를 식별할 수 있는 속성   외래키 속성 : 다른 개체와의 관계에서 포함된 속성   일반 속성 : 개체에 포함도어 있고 기본키, 외래키에 포함되지 않은 속성   - 속성 후보 선정 원칙      속성으로 지정할 후보는 최대한 많이 선택하는 것이 좋음   원시 속성으로 판단되는 속성 후보는 버리지 않음   속성 후보군을 만들고 가장 근접한 개체에 할당   - 속성명 지정 원칙      업무에서 사용하는 용어로 지정   서술형으로 지정하지 않음   약어의 사용 제한   개체명은 속성명으로 사용할 수 없음   개체에서 유일하게 식별 가능하도록 지정       5. 데이터 모델의 구성 요소 - 관계(Relationship) – B   - 관계의 정의      개체와 개체 사이의 논리적인 연결   - 관계의 형태      1 : 1   1 : N   N : M   - 관계의 종류      종속 관계   중복 관계   재귀 관계   배타 관계       6. E-R(개체-관계) 모델 – A   - E-R 모델의 개요      개념적 데이터 모델의 대표   개체와 개체간의 관계를 기본 요소로 데이터를 개념적인 논리 데이터로 표현하기 위한 방법   대체 타입과 관계 타입을 이용해 현실 세계를 개념적으로 표현   데이터를 개체, 관계, 속성으로 묘사   특정 DBMS를 고려한 것은 아님   E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음   일반화 계층 같은 복잡한 개념들이 첨가되어 확장된 모델로 발전   - E-R 다이어그램      기호를 사용하여 시각적으로 표현한 그림   역할을 가진 모든 실체들을 표현   뷰들을 하나로 단일화   @ 피터 첸 표기법      개체 : 사각형   관계 : 마름모   속성 : 타원   다중값 속성 : 이중 타원   기본키 속성 : 밑줄 타원   복합 속성 : 복수 타원   1:1, 1:N, N:M 등 개체 간 관계에 대한 대응수를 선 위에 기술 : 관계   개체 타입과 속성을 연결 : 선, 링크   @ 정보 공학 표기법      개체 : 사각형   개체명 : 박스 바깥쪽 위   속성 : 기본키 속성과 일반 속성을 분리하여 표시   관계 : 관계 표기 기호를 사용            필수 : ㅣ       선택적 : ㅇ       다중 : &lt;           @ 바커 표기법      개체 : 모서리가 둥근 박스   개체명 : 박스 안 가장 위   속성            값이 반드시 저장되어야 하는 경우 : *       값이 저장될 수도, 안될 수도 있는 경우 : ㅇ           관계            필수 : ㅡ       선택적 : ………       다중 : &lt;               7. 관계형 데이터베이스의 구조 – A   - 관계형 데이터베이스의 개요      개체나 관계를 모두 릴레이션이라는 표로 표현   개체를 표현하는 개체 릴레이션, 관계를 나타내는 관계 릴레이션으로 구분   장점 : 간결하고 보기 편리하며, 다른 DB로 변환이 용이   단점 : 성능이 다소 떨어짐   - 관계형 데이터베이스의 Relation 구조      구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성   @ 튜플      릴레이션을 구성하는 각각의 행   속성의 모임으로 구성   파일 구조에서 레코드와 같은 의미   튜플의 수를 Cardinality 또는 기수, 대응수라고 함   @ 속성      DB를 구성하는 가장 작은 논리적 단위   파일 구조상의 데이터 항목 또는 데이터 필드에 해당   개체의 특성을 기술   속성의 수를 Degree 또는 차수라고 함   @ 도메인      하나의 Attribute가 취할 수 있는 같은 타입의 Atomic 값들의 집합   값의 합법 여부를 시스템이 검사하는데 이용   - 릴레이션의 특징      한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 튜플들은 모두 상이함   튜플 사이에는 순서가 없음   튜플의 삽입, 삭제 등의 작업으로 릴레이션은 시간에 따라 변함   릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음   속성의 명칭은 유일해야 하지만, 값은 동일한 값이 있을 수 있음   속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장   8. 관계형 데이터베이스의 제약 조건 : Key – A      제약 조건이란 키를 이용하여 입력되는 데이터에 제한을 주는 것.   개체 무결성 제약, 참조 무결성 제약 등이 해당   - Key의 개념 및 종류      키는 조건에 만족하는 튜플을 찾거나 정렬할 때 튜플을 서로 구분할 수 있는 기준이 되는 Attribute   @ 후보키(Candidate Key)      튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합. 즉 기본키로 사용할 수 있는 속성들   모든 릴레이션에는 반드시 하나 이상의 후보키 존재   유일성과 최소성을 만족시켜야 함   유일성 : 하나의 키 값으로 하나의 튜플만을 유일하게 식별   최소성 : 유일하게 식별하는 데 꼭 필요한 속성으로만 구성   @ 기본키(Primary Key)      후보키 중에서 특별히 선정된 주키로 중복된 값을 가질 수 없음   특정 튜플을 유일하게 구별할 수 있는 속성   후보키의 성질을 가짐. 유일성과 최소성을 가지며, 튜플을 식별하기 위해 반드시 필요   NULL 값을 가질 수 없음   @ 대체키(Alternate Key)      후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키. 보조키라고도 함   @ 슈퍼키(Super Key)      속성들의 집합으로 구성된 키   슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음   유일성은 만족시키지만, 최소성은 만족시키지 못함   @ 외래키(Foreign Key)      다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합   참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현   외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음       9. 관계형 데이터베이스의 제약 조건 : 무결성 - B   - 무결성의 개념 및 종류      무결성이란 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성   부정확한 자료가 DB 내에 저장되는 것을 방지하기 위한 제약 조건   @ 개체 무결성(Entity Integrity)      기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정   @ 도메인 무결성(Domain Integrity)      주어진 속성 값이 정의된 도메인에 속한 값이어야 함   @ 참조 무결성(Referential Integrity)      외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함   릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정   외래키와 참조하려는 테이블의 기본키는 도메인과 속성 개수가 같아야 함   @ 사용자 정의 무결성      속성 값들이 사용자가 정의한 제약 조건에 만족해야 하는 규정   - 데이터 무결성 강화      데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 함   DB 구축 과정에서 정의   애플리케이션            데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 추가       복잡한 규칙 등은 애플리케이션 내에서 처리       장점 : 복잡한 무결성 조건의 구현이 가능       단점 : 분산되어 있어 관리가 힘들고, 개별 시행으로 적정성 검토가 어려움           데이터베이스 트리거            트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가       장점 : 통합 관리가 가능하고, 복잡한 요구 조건의 구현이 가능       단점 : 운영 중 변경이 어렵고, 사용상 주의가 필요           제약 조건            제약 조건을 설정하여 무결성을 유지       장점 : 통합 관리 가능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지       단점 : 복잡한 제약 조건의 구현과 예외적인 처리가 불가능           10. 관계대수 및 관계해석 – A   - 관계대수의 개요      RDB에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어   연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션, 결과도 릴레이션   연산의 순서를 명시   순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음   - Select      선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산   행에 해당하는 튜플을 구하는 것. 수평 연산   시그마(σ) 기호를 사용   표기 형식 : σ  (R)   비교 연산이 허용되며, 논리 연산자를 사용하여 여러 조건들을 하나의 조건으로 결합 가능   σ Avg &gt; 90 (성적) :  릴레이션에서 평균 90점 이상인 튜플을 추출하시오   - Project      속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산   중복이 발생하면 제거됨   열에 해당하는 Attribute를 추출 하는 것. 수직 연산자   파이(π) 기호를 사용   표기 형식 : π  (R)   π Name, Avg (성적) :  릴레이션에서 Name과 Avg 속성을 추출하시오   - Join      공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산   차수는 합, Cartesian Product는 곱   Cartesian Product를 수행한 다음 Select를 수행한 것과 같음   ▷◁ 기호를 사용   R ▷◁ 키속성r = 키속성s S   성적 ▷◁ No = No 학적부 :  릴레이션과  릴레이션을 No 속성을 기준으로 합치시오   자연 조인            중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법       자연 조인이 성립되려면 두 릴레이션의 속성명과 도메인이 같아야 함           - Division      X ⊃ Y인 R(X), S(Y)가 있을 때, S가 가진 속성을 제외한 속성만을 구하는 연산   ÷ 기호를 사용   표기 형식 : R [속성r ÷ 속성s] S   - 일반 집합 연산자      집합 이론에서 사용하는 연산자   UNION ∪ : 합집합   INTERSECTION ∩ : 교집합   DIFFERENCE - : 차집합   CARTESIAN PRODUCT X : 교차곱   - 관계 해석      수학의 술어 해석에 기반을 두고 RDB를 위해 제안   관계 데이터의 연산을 표현하는 방법. 계산 수식을 사용   원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성   튜플 관계해석과 도메인 관계해석이 있음   관계해석과 관계대수는 RDB를 처리하는 기능과 능력면에서 동등   관계대수로 표현한 식은 관계해석으로 표현 가능   질의어로 표현       11. 정규화(Normalization) – A   - 정규화의 개요      종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개 바람직한 스키마로 만드는 과정   분해하는 과정   차수가 높아질수록 만족시켜야 할 제약 조건이 늘어남   DB의 논리적 설계 단계에서 수행   논리적 처리 및 품질에 큰 영향을 미침   일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장   정규화 수준이 높을수록 유연한 데이터 구축이 가능. 데이터의 정확성 높아짐   물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하됨   - 정규화의 목적      데이터 구조의 안정성 및 무결성 유지   어떠한 릴레이션이라도 DB 내에서 표현 가능   효과적인 검색 알고리즘을 생성   중복을 배제하여 이상의 발생 방지 및 자료 저장 공간의 최소화 가능   데이터 삽입 시 릴레이션을 재구성할 필요성 줄임   데이터 모형의 단순화 가능   속성의 배열 상태 검증 가능   개체와 속성의 누락 여부 확인이 가능   자료 검색과 추출의 효율성 추구   - 이상의 개념 및 종류      정규화를 거치지 않으면 데이터들이 불필요하게 중복되어 릴레이션 조작시 문제 발생   삽입 이상 : 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입   삭제 이상 : 삭제할 때 의도와는 상관없는 값들도 함께 삭제   갱신 이상 : 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생김   - 정규화의 원칙      정보의 무손실 표현. 정보의 손실이 있어서는 안됨   분리의 원칙. 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현   데이터의 중복성이 감소되어야 함   - 정규화 과정      1NF : 도메인이 원자값만으로 되어 있는 정규형   2NF : 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족   3NF : 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음   BCNF : 결정자가 모두 후보키인 정규형   4NF : 다치 종속이 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족   5NF : 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형   정규화 과정 정리            도메인이 원자값       부분적 함수 종속 제거       이행적 함수 종속 제거       결정자이면서 후보키가 아닌 것 제거       다치 종속 제거       조인 종속성 이용       도부이결다조               12. 반정규화(Denormalization) – B      정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 행위   시스템의 성능이 향상, 관리 효율성 증가   데이터의 일관성 및 정합성이 저하   - 테이블 통합      조인되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행   1:1 관계 테이블 통합, 1:N 관계 테이블 통합, 슈퍼타입/서브타입 테이블 통합   고려사항            검색은 편하지만 레코드 증가로 인해 처리량 증가       통합으로 인해 입력, 수정, 삭제 규칙이 복잡해질 수 있음       Not Null, Default, Check 등의 제약조건을 설계하기 어려움           - 테이블 분할      테이블을 수직 또는 수평으로 분할하는 것   수평 분할            레코드를 기준으로 테이블을 분할       사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할           수직 분할            하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할           - 중복 테이블 추가      여러 테이블에서 데이터를 사용하거나 다른 서버 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 효율성 향상   중복 테이블을 추가하는 경우            정규화로 인해 수행 속도가 느려지는 경우       많은 범위의 데이터를 자주 처리해야 하는 경우       특정 범위의 데이터만 자주 처리해야 하는 경우       처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우           - 중복 속성 추가      조인해서 데이터를 처리할 때 데이터 조회 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가   데이터 무결성 확보가 어렵고, 디스크 공간이 추가로 필요   중복 속성을 추가하는 경우            조인이 자주 발생하는 속성인 경우       접근 경로가 복잡한 속성인 경우       액세스의 조건으로 자주 사용되는 속성인 경우       기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우           고려사항            테이블 중복과 속성의 중복을 고려       데이터 일관성 및 무결성에 유의       SQL 그룹 함수를 이용하여 처리할 수 있어야 함       저장 공간의 지나친 낭비를 고려               13. 시스템 카탈로그 – A   - 시스템 카탈로그의 의미      시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 DB   사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블   카탈로그들이 생성되면 데이터 사전에 저장   - 시스템 카탈로그 저장 정보      시스템 카탈로그에 저장된 정보를 메타 데이터라고 함   메타 데이터의 유형            DB 객체 정보 : Table, Index, View 등의 구조 및 통계 정보       사용자 정보 : 아이디, 패스워드, 접근 권한 등       테이블의 무결성 제약 조건 정보 : 기본키, 외래키, NULL 값 허용 여부 등       함수, 프로시저, 트리거 등에 대한 정보           - 카탈로그 특징      일반 이용자도 SQL을 이용하여 내용 검색할 수 있음   INSERT, DELETE, UPDATE로 카탈로그를 갱신하는 것은 허용되지 않음   DBMS에 따라 상이한 구조   DBMS가 스스로 생성하고 유지함   변화가 있으면 시스템이 자동으로 갱신함   위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 가져야 함   - 카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템      DDL Compiler : 메타 데이터를 갖는 테이블로 변환하여 데이터 사전에 저장   DML Compiler : DML문을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신   Data Directory            데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템       시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있음       데이터 디렉터리는 시스템만 접근할 수 있음           질의 최적화기 : 사용자의 요구를 효율적인 형태로 변환하고 질의를 처리하는 좋은 전략 모색   트랜잭션 처리기 : 트랜잭션 문제를 해결하여, 사용자가 DB 자원을 배타적으로 이용할 수 있도록 함  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp10/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 글꼴, 문자",
        "excerpt":"글꼴   - font-style   /* 글자의 기울기 */ font-style {   기본값: normal; 기울기 없음   font-style: italic; 이텔릭체   font-style: oblique; 기울어진 글자 }       - font-weight   /* 글자의 두께 */ font-weight {   기본값: normal or 400; 기본 두께   font-weight: bold or 700; 두껍게   font-weight: bolder; 부모 요소보다 두껍게   font-weight: lighter; 부모 요소보다 얇게   font-weight: 100 ~ 900; 100단위의 숫자 9개 }       - font-size   /* 글자의 크기 */ font-size {   기본값: 16px; 기본 크기   단위: px, em, rem;   %: 부모 요소의 폰트 크기에 대한 비율   font-size: larger; 부모 요소보다 크게   font-size: smaller; 부모 요소보다 작게   font-size: xx-small ~ xx-large; 가장 작은 크기 ~ 가장 큰 크기까지 7단계 크기 }       - line-height   /* 한 줄의 높이, 행간과 유사 */ line-height {   기본값: normal; 브라우저의 기본 정의   line-height: 숫자; 요소의 글꼴 크기의 배수로 지정   단위: px, em, rem;   %: 요소의 글꼴 크기의 비율로 지정 }       - font-family   font-family {   font-family: serif; 바탕체 계열   font-family: sans-serif; 고딕체 계열   font-family: monospace; 고정너비 글꼴 계열   font-family: cursive; 필기체 계열   font-family: fantasy; 장식 글꼴 계열 }   Hello World! Hello World! Hello World! Hello World! Hello World!  문자   - color   /* 글자의 색상 */ color {   기본값: rgb(0, 0, 0); 검정색   color: 색상; 기타 지정 가능한 색상 }       - text-align   /* 문자의 정렬 방식 */ text-align {   기본값: left; 왼쪽 정렬   text-align: right; 오른쪽 정렬   text-align: center; 가운데 정렬   text-align: justify; 양쪽 정렬 }       - text-decoration   /* 문자의 장식(선) */ text-decoration {   기본값: none; 장식 없음   text-decoration: underline; 밑줄   text-decoration: overline; 윗줄   text-decoration: line-through; 중앙 선 }   Hello World! Hello World! Hello World! Hello World!      - text-indent   /* 문자 첫 줄의 들여쓰기 */ text-indent {   기본값: 0; 들여쓰기 없음   단위: px, em, rem;   %: 요소의 가로 너비에 대한 비율   음수 사용 가능   반대는 내어쓰기 outdent }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-font/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-2. 물리 데이터베이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 사전 조사 분석 – B      논리적 구조료 표현된 논리적 DB를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환   데이터 단위는 저장 레코드   꼭 포함되어야 할 것은 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계 등   여러 가지 타입의 저장 레코드 집합이라는 면에서 단순한 파일과 다름   물리적 DB 구조는 DB 시스템 성능에 중대한 영향을 미친다   고려사항            인덱스 구조       레코드 크기       레코드 개수       트랜잭션의 갱신과 참조 성향       개념 스키마의 변경 여부 검토       트랜잭션들의 수행속도를 높이기 위한 고려       파일 크기의 변화 가능성           기존 시스템을 분석하여 파악   물리적 설계 옵션            반응시간       공간 활용도       트랜잭션 처리량           - 데이터 명명 규칙 파악      데이터 표준화 및 논리 DB 설계의 결과물 등을 통해 파악   서로 일관성 유지   동일 명칭 부여의 근거   중복 구축 등을 방지   도메인과 데이터 사전에 대한 지식 필요   도메인 : 객체에 포함된 속성들의 데이터 타입, 크기 등을 표준화 규칙에 따라 일관성 있게 정의한 것   데이터 사전            일관성 있는 데이터 이름과 인터페이스를 제공하기 위해 데이터 속성의 논리명, 물리명, 용어정의를 기술       프로젝트에서 사용하는 명칭 부여의 근거           - 시스템 자원 파악      시스템 자원은 DB 설치에 영향을 미칠 수 있는 물리적 요소. 사전에 미리 파악해야 함   하드웨어 자원, 운영체제 및 DBMS 버전, DBMS 파라미터 정보   - 데이터베이스 관리 요소 파악      DB 관리 요소는 운영과 관련된 관리 요소. 미리 파악해야 함   파악한 후 DB 시스템 조사 분석서 작성       2. 데이터베이스 저장 공간 설계 – B   - 테이블      Row와 Column으로 구성   모든 데이터는 테이블에 저장됨   논리 설계 단계의 개체에 대응하는 객체   DBMS 종류에 따라 테이블의 명칭과 기능 등은 약간씩 차이가 있음   @ 일반 테이블      대부분의 DBMS에서 표준 테이블로 사용되는 테이블   Row 위치는 속성 값에 상관없이 데이터가 저장되는 순서에 따라 결정   @ 클러스터드 인덱스 테이블      기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블   접근 경로가 단축됨   @ 파티셔닝 테이블      대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블   대용량의 데이터를 효과적으로 관리할 수 있음   파티션 키를 잘못 구성하면 성능 저하 등의 역효과 초래   범위분할 : 지정한 열의 값을 기준으로 분할   해시분할 : 해시 함수를 적용한 결과 값에 따라 분할   조합분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할   @ 외부 테이블      DB에서 일반 테이블처럼 이용할 수 있는 외부 파일. 객체로 존재   데이터웨어하우스에서 ETL 등의 작업에 유용하게 사용   @ 임시 테이블      트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블   트랜잭션이 종료되면 삭제됨   임시로 사용하는 테이블   - Column      테이블의 열. 데이터 타입, 길이 등으로 정의됨   데이터 타입은 데이터의 일관성 유지를 위해 사용되는 가장 기본적인 것   도메인을 정의한 경우 도메인에 따라 데이터의 타입과 길이 정의   두 컬럼의 데이터 타입이나 길이가 다르면 DBMS 내부적으로 데이터 타입을 변환한 수 비교 연산 수행   참조 관계인 컬럼들은 데이터 타입과 길이가 일치해야 함   - 테이블스페이스      테이블이 저장되는 논리적인 영역. 하나 또는 그 이상의 테이블 저장 가능   테이블을 저장하면 논리적으로는 테이블스페이스에 저장, 물리적으로는 연관된 데이터 파일에 저장   나눠 관리하면 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장됨   고려사항            업무별로 구분하여 지정       대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장       테이블과 인덱스는 분리하여 저장       LOB 타입의 데이터는 독립적인 공간으로 지정               3. 트랜잭션 분석 / CRUD 분석 – B   - 트랜잭션 정의      DB의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 연산   병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위   시스템이 응답하기 위한 상태 변환 과정의 작업 단위   - 트랜잭션의 특성      Atomicity(원자성)            트랜잭션의 연산은 완료(Commit)되든지 전혀 반영되지 않도록 복구(Rollback)되어야 함       모든 명령은 반드시 완벽히 수행되야 하며, 오류 발생 시 트랜잭션 전부가 취소돼야 함           Consistency(일관성)            실행을 성공적으로 완료하면 언제나 일관성 있는 DB 상태로 변환       고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야 함           Isolation(독립성, 격리성, 순차성)            트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음       완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음           Durability(영속성, 지속성)            완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영           - CRUD 분석      Create, Read, Update, Delete   CRUD 매트릭스를 작성하여 분석   트랜잭션의 주기별 발생 횟수를 파악하고, 테이블에 저장되는 데이터의 양을 유추할 수 있음   많은 트랜잭션이 몰리는 테이블을 파악할 수 있음   연결 지연이나 타임아웃 오류를 방지할 수 있음   - CRUD 매트릭스      Row에는 프로세스를, Column에는 테이블을, 행과 열이 만나는 위치에는 변화를 표시   프로세스의 트랜잭션이 테이블에 수행하는 작업을 검증   복수의 변화를 줄 때는 C &gt; D &gt; U &gt; R의 우선순위 적용   불필요하거나 누락된 테이블 또는 프로세스를 찾음   - 트랜잭션 분석      테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB 용량을 산정하고 구조를 최적화   업무 개발 담당자가 수행   디스크 입출력 분산을 통한 성능 향상을 가져올 수 있음   - 트랜잭션 분석서      단위 프로세스와 CRUD 매트릭스를 이용하여 작성       4. 인덱스 설계 – A   - 인덱스의 개념      &lt;키 값, 포인터&gt; 쌍으로 구성되는 데이터 구조   물리적 구조와 밀접한 관계   물리적 구조에 접근하는 방법 제공   파일의 레코드에 대한 액세스를 빠르게 수행   삽입, 삭제가 수시로 일어나는 경우, 인덱스의 개수를 최소로 하는 것이 효율적   인덱스가 없으면 모든 데이터 페이지를 확인하는 TABLE SCAN 발생   기본키를 위한 인덱스를 기본 인덱스, 기본 인덱스가 아닌 인덱스를 보조 인덱스라고 함   DBMS에서는 모든 기본키에 대해서 자동적으로 기본 인덱스를 생성함   레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터트 인덱스라 함            클러스터드 인덱스                    인덱스 키의 순서에 따라 데이터가 정렬되어 저장           인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있음           삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬해야 함           한 개의 릴레이션에 하나의 인덱스만 생성할 수 있음                       넌클러스터드 인덱스                    키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식           데이터 검색을 위해 인덱스를 검색하여 실제 데이터의 위치를 확인해야 하므로 검색 속도가 떨어짐           한 개의 릴레이션에 여러 개의 인덱스를 만들 수 있음                           - 트리 기반 인덱스      인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것   B 트리 인덱스            루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 검색       포인터들이 트리 노드에 오름차순으로 저장       모든 리프 노드는 같은 레벨에 있음           B+ 트리 인덱스            단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분       인덱스 세트에 있는 노드들은 경로로만 제공       순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴       단말 노드만을 이용한 순차 처리 가능           - 비트맵 인덱스      인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용   목적은 Row의 주소를 제공하는 것   분포도가 좋은 컬럼에 적합하며, 성능 향상 효과를 얻을 수 있음   효율적인 논리 연산이 가능하고 저장 공간이 작음   다중 조건을 만족하는 튜플의 개수 계산에 적합   동일한 값이 반복되는 경우가 많아 압축 효율이 좋음   - 함수 기반 인덱스      컬럼의 값 대신 특정 함수나 수식을 적용하여 산출된 값을 사용   B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용   데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하 발생할 수 있음   사용자 정의 함수일 경우 시스템 함수보다 부하가 더 큼   대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용됨   - 비트맵 조인 인덱스      다수의 조인된 객체로 구성된 인덱스   비트맵 인덱스와 물리적 구조가 동일   - 도메인 인덱스      개발자가 필요한 인덱스를 직접 만들어 사용하는 것. 확장형 인덱스   프로그램에서 제공하는 인덱스처럼 사용할 수도 있음   - 인덱스 설계      분명하게 드러난 컬럼에 대해 기본적인 인덱스를 먼저 지정   테이블, 컬럼 등 선정 -&gt; 인덱스 최적화 수행 -&gt; 인덱스 정의서 작성   - 인덱스 대상 테이블 선정 기순      MULTI BLOCK READ 수에 따라 판단   랜덤 액세스가 빈번한 테이블   특정 범위나 특정 순서로 데이터 조회가 필요한 테이블   다른 테이블과 순차적 조인이 발생되는 테이블   - 인덱스 대상 컬럼 선정 기준      컬럼의 분포도가 10~15% 이내인 컬럼   분포도가 10~15% 이상이어도 부분 처리를 목적으로 하는 컬럼   조회 및 출력 조건으로 사용되는 컬럼   기본키와 Unique키 제약 조건을 사용한 컬럼   수정이 빈번하지 않은 컬럼   ORDER BY, GROUP BY, UNION이 빈번한 컬럼   분포도가 좁은 컬럼은 단독 인덱스로 생성   인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스로 생성   - 인덱스 설계 시 고려사항      새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있음   인덱스를 지나치게 많이 만들면 오버헤드 발생   넓은 범위를 인덱스로 처리하면 많은 오버헤드 발생   인덱스를 만들면 추가적인 저장 공간이 필요   인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계       5. View 설계 – A   - View의 개요      접근이 허용된 자료만을 제한적으로 보여주기 위해 기본 테이블로부터 유도된 가상 테이블   물리적으로 존재하지 않지만, 있는 것처럼 간주   임시적인 작업을 위한 용도로 활용   조인문의 사용 최소화로 사용상의 편의성을 최대화   - View의 특징      기본 테이블과 같은 형태의 구조를 사용, 조작도 기본 테이블과 거의 같음   물리적으로 구현되어 있지 않음   데이터의 논리적 독립성을 제공   관리가 용이하고 명령문이 간단해짐   뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용   기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야 삽입, 삭제, 갱신등의 연산 가능   정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음   뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 삭제됨   - View의 장단점      장점            논리적 데이터 독립성 제공       동일 데이터에 동시에 여러 사용자의 상이한 응용이나 요구 지원       데이터 관리를 간단하게 해줌       접근 제어를 통한 자동 보안이 제공           단점            독립적인 인덱스를 가질 수 없음       뷰가 정의를 변경할 수 없음       삽입, 삭제, 갱신 연산에 제약이 따름           - View 설계 순서      대상 테이블 선정 -&gt; 대상 컬럼 선정 -&gt; 정의서 작성   - View 설계시 고려 사항      반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성   사용할 데이터를 다양한 관점에서 제시해야 함   데이터의 보안 유지를 고려하여 설계       6. 클러스터 설계 – A   - 클러스터의 개요      동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법   클러스터링키로 지정된 컬럼 값의 순서대로 저장, 여러 개의 테이블이 하나의 클러스터에 저장   - 클러스터의 특징      데이터 조회 속도는 향상. 입력, 수정, 삭제 성능은 저하   데이터의 분포도가 넓을수록 유리   저장 공간을 절약할 수 있음   저장 공간이 줄어듬   대용량 처리 트랜잭션은 클러스터링 안하는게 좋음   처리 범위가 넓은 경우는 단일 테이블 클러스터링 사용   조인이 많이 발생하는 경우는 다중 테이블 클러스터링 사용   파티셔닝된 테이블에는 클러스터링 할 수 없음   클러스터링 하면 디스크 I/O가 줄어듬   클러스터드 인덱스를 생성하면 접근 성능이 향상됨   - 클러스터 대상 테이블      분포도가 넓은 테이블   대량의 범위를 자주 조회하는 테이블   입력, 수정, 삭제가 자주 발생하지 않는 테이블   자주 조인되어 사용되는 테이블   ORDER BY, GROUP BY, UNION이 빈번한 테이블       7. 파티션 설계 – A   - 파티션의 개요      대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것   성능 저하를 방지할 뿐만 아니라 데이터 관리가 쉬워짐   파티션키 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장   데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행됨   - 파티션의 장단점      장점            데이터 접근 시 액세스 범위를 줄여 쿼리 성능 향상       디스크의 성능 향상       속도가 빠름       데이터 손상 정도를 최소화 할 수 있음       데이터 가용성이 향상       입출력을 분산시킬 수 있음           단점            세심한 관리가 요구됨       조인에 대한 비용이 증가       용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능 저하           - 파티션의 종류      범위 분할            지정한 열의 값을 기준으로 분할           해시 분할            해시 함수를 적용한 결과 값에 따라 데이터를 분할       범위 분할의 단점을 보완. 데이터를 고르게 분산할 때 유용       특정 데이터가 어디에 있는지 판단할 수 없음       데이터가 고르게 분포한 컬럼에 효과적           조합 분할            범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할       범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용           - 파티션키 선정 시 고려 사항      테이블 접근 유형에 따라 파티셔닝이 이뤄지도록 선정   이력성 데이터는 파티션 생성주기와 소멸주기를 일치시켜야 함   - 인덱스 파티션      파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것   파티션된 테이블의 종속 여부            Local Partitioned Index : 테이블 파티션과 인덱스 파티션이 1:1 대응       Global Partitioned Index : 테이블 파티션과 인덱스 파티션이 독립적으로 구성       Local Partitioned Index가 데이터 관리가 쉬움           인덱스 파티션키 컬럼의 위치            Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 같음       Non-Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다름               8. 분산 데이터베이스 설계 – A   - 분산 데이터베이스 정의      논리적으로는 하나의 시스템에 속하지만 물리적으로 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 DB   데이터의 처리나 이용이 많은 지역에 DB를 위치해 데이터 처리가 해당 지역에서 해결   - 분산 데이터베이스의 구성 요소      분산 처리기 : 자체 처리 능력. 지리적으로 분산되어 있는 컴퓨터 시스템   분산 데이터베이스 : 지리적으로 분산되어 있는 DB. 해당 지역의 특성에 맞게 DB 구성   통신 네트워크 : 분산 처리기들을 통신망으로 연결하는 통신 네트워크   - 분산 데이터베이스 설계 시 고려 사항      작업부하의 노드별 분산 정책   지역의 자치성 보장 정책   데이터의 일관성 정책   사이트나 회선의 고장으로부터의 회복 기능   통신 네트워크를 통한 원격 접근 기능   - 분산 데이터베이스의 목표      위치 투명성 : 실제 위치를 알 필요 없이 DB의 논리적인 명칭만으로 액세스 가능   중복 투명성 : 데이터가 중복되어 있더라도 사용자는 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업 수행   병행 투명성 : 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음   장애 투명성 : 장애에도 불구하고 트랜잭션을 정확하게 처리   - 분산 데이터베이스의 장단점      장점            지역 자치성이 높음       자료의 공유성 향상       분산 제어 가능       시스템 성낭 향상       중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음       효용성과 융통성이 높음       신뢰성 및 가용성 높음       점진적 시스템 용량 확장이 용이           단점            DBMS가 수행할 기능이 복잡       DB 설계가 어려움       개발 비용 증가       처리 비용 증가       잠재적 오류 증가           - 분산 데이터베이스 설계      전역 관계망을 논리적 측면에서 소규모 단위로 분할한 후, 분할된 결과를 복수의 노드에 할당하는 과정으로 진행   @ 테이블 위치 분산      테이블을 각기 다른 서버에 분산시켜 배치   테이블의 구조를 변경하지 않으며, 다른 DB의 테이블과 중복되지 않게 배치   해당 테이블들이 놓일 서버들을 미리 설정해야 함   @ 분할      테이블의 데이터를 분할하여 분산시키는 것   분할 규칙            완전성 : 전체 데이터를 대상으로 분할       재구성 : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성할 수 있어야 함       상호 중첩 배제 : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 함           주요 분할 방법            수평 분할 : 속성의 값을 기준으로 Row 단위로 분할       수직 분할 : 속성 단위로 분할           @ 할당      동일한 분할을 여러 개의 서버에 생성하는 분산 방법   비중복 할당 방식            분산 DB의 단일 노드에서만 분할이 존재       분할된 테이블 간의 의존성은 무시되고 비용 증가, 성능 저하 등의 문제 발생 가능           중복 할당 박식            동일한 테이블을 다른 서버에 복제하는 방식       일부만 복제하는 부분복제, 전체를 복제하는 완전 복제가 있음               9. 데이터베이스 이중화 / 서버 클러스터링 – B   - 데이터베이스 이중화      시스템 오류로 인한 DB 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 DB를 복제하여 관리   문제가 발생하면 복제된 DB를 이용하여 즉시 문제를 해결할 수 있음   사용자가 수행하는 작업이 다른 DB에도 동일하게 적용   DB 부하를 줄일 수 있음   손쉽게 백업 서버를 운영할 수 있음   - 데이터베이스 이중화의 분류      Eager 기법 : 데이터 변경이 발생하면 변경 내용이 즉시 적용   Lazy 기법 : 트랜잭션 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 DB에 전달   - 데이터베이스 이중화 구성 방법      활동-대기 방법            한 DB가 활성 상태이면 다른 DB는 대기       활성 DB에 장애가 발생하면 대기 DB가 자동으로 모든 서비스를 대신 수행       구성 방법과 관리가 쉬움           활동-활동 방법            두개의 DB가 서로 다른 서비스를 제공하다가 한쪽에 문제가 생기면 나머지 DB가 서비스 제공       처리율이 높지만 구성 방법 및 설정이 복잡           - 클러스터링      두 대 이상의 서버를 하나의 서버처럼 운영하는 기술   서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공   고가용성 클러스터링            하나의 서버에 장애가 발생하면 다른 서바가 받아 처리하여 서비스 중단을 방지           병렬 처리 클러스터링            전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리       사용자의 요청을 로드 밸런서가 여러 대의 서버로 분산               10. 데이터베이스 보안 / 암호화 – B   - 데이터베이스 보안의 개요      권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술   DB 사용자들은 일반적으로 서로 다른 객체에 대하여 다른 접근 권리 또는 권한을 가짐   - 암호화      데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 함   암호화 과정 : 평문 -&gt; 암호문   복호화 과정 : 암호문 -&gt; 평문   개인키 암호 방식(비밀키 암호 방식)            동일한 키로 데이터를 암호화하고 복호화 함       대칭 암호 방식, 단일키 암호화 기법이라고도 함       비밀키는 DB 사용 권한이 있는 사용자만 나누어 가짐           공개키 암호 방식            서로 다른 키로 데이터를 암호화하고 복호화 함       공개키는 DB 사용자에게 공개. 복호화 키는 관리자가 비밀리에 관리       비대칭 암호 방식. 대표적으로 RSA               11. 데이터베이스 보안 : 접근통제 – A   - 접근통제      데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한   자원의 불법적인 접근 및 파괴를 예방   비인가된 사용자의 접근 감시   접근 요구자의 사용자 식별   접근 요구의 정당성 확인 및 기록   접근의 승인 및 거부   임의 접근 통제            데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여       주체가 접근통제 권한을 지정하고 제어       부여된 권한을 다른 사용자에게 허가할 수 있음       GRANT, REVOKE           강제 접근 통제            주체와 객체의 등급을 비교하여 접근 권한을 부여       제3자가 접근통제 권한을 지정       객체별로 보안 등급 부여, 사용자별로 인가 등급 부여       자신보다 보안 등급이 높은 객체에 대해 읽기, 수정, 등록이 모두 불가능       자신과 보안 등급이 같은 객체에 대해 읽기, 수정, 등록 가능       자신보다 보안 등급이 낮은 객체에 대해 읽기 가능           - 접근통제 정책      신분 기반 정책            주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법       IBP : 최소 권한 정책. 단일 주체에게 하나의 객체에 대한 허가 부여       GBP : 복수 주체에 하나의 객체에 대한 허가 부여           규칙 기반 정책            주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법       MLP : 사용자 및 객체별로 지정된 기밀 분류에 따른 정책       CBP : 집단별로 지정된 기밀 허가에 따른 정책           역할 기반 정책            주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한       인사 담당자, DBA 등           - 접근통제 매커니즘      접근통제 정책을 구현하는 기술적인 방법   접근통제 목록, 능력 리스트, 보안 등급, 패스워드, 암호화   - 접근통제 보안 모델      보안 정책을 구현하기 위한 정형화된 모델   기밀성 모델            군사적인 목적으로 개발된 수학적 모델. 기밀성 보장이 최우선       군대 시스템 등 특수 환경에서 주로 사용           무결성 모델            불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델       데이터의 일관성 유지에 중점       주체 및 객체의 보안 등급을 기반으로 함           접근통제 모델            접근통제 행렬 : 행은 주체, 열은 객체           - 접근통제 조건      접근통제 매커니즘의 취약점을 보완하기 위해 접근통제 정책에 부가하여 적용할 수 있는 조건   값 종속 통제 : 객체에 저장된 값에 따라 다르게 접근 통제를 허용해야 하는 경우   다중 사용자 통제 : 다수의 사용자가 동시에 접근을 요구하는 경우   컨텍스트 기반 통제 : 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때   - 감사 추적      DB에 접근하여 수행한 모든 활동을 기록하는 기능   오류가 발생한 DB를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용       12. 스토리지 – B   - 스토리지 개요      단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술   - DAS(Direct Attached Storage)      서버와 저장장치를 전용 케이블로 직접 연결. 외장하드를 연결하는 것이 해당   서버에서 저장장치를 관리   직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬움   초기 구축 비용 및 유지보수 비용 저렴   다른 서버에서 접근할 수 없고 파일 공유 불가능   확장성 및 유연성이 상대적으로 떨어짐   저장 데이터가 적고 공유가 필요 없는 환경에 적합   - NAS(Network Attached Storage)      서버와 저장장치를 네트워크를 통해 연결   NAS Storage가 내장된 저장장치를 직접 관리   Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있음   파일 공유 가능, 장소에 구애받지 않고 저장장치에 쉽게 접근 가능   확장성 및 유연성이 우수   접속 증가 시 성능 저하   - SAN(Storage Area Network)      서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성   파이어 채널 스위치를 이용하여 네트워크 구성   광케이블로 연결하므로 처리 속도가 빠름   저장장치 및 파일 공유 가능   확장성, 유연성, 가용성이 뛰어남   높은 트랜잭션 처리에 효과적   장비의 업그레이드가 필요하고, 비용이 많이 듦       13. 논리 데이터 모델의 물리 데이터 모델 변환 – A   - 테이블      Row : 튜플, 인스턴스   Column : 속성   기본키 : 후보키 중에서 선택한 주키. 특정 튜플을 유일하게 구별할 수 있는 속성   외래키 : 다른 릴레이션의 기본키를 참조하는 속성   - Entity를 테이블로 변환      고려사항            테이블과 Entity 명칭은 동일하게 하는 것을 권고       Entity는 한글명 사용, 테이블은 영문명 사용       메타 데이터 관리 시스템에 표준화된 용어가 있을 때는 메타에 등록된 단어를 사용           - 슈퍼타입/서브타입을 테이블로 변환      물리 데이터 모델을 설계할 때는 슈퍼타입/서브타입을 테이블로 변환해야 함   슈퍼타입 기준 테이블 변환            서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것       서브타입에 속성이나 관계가 적을 경우에 적용. 서브타입의 모든 속성이 포함       장점                    데이터 액세스가 상대적으로 용이           뷰를 이용해 각각의 서브타입만을 액세스하거나 수정할 수 있음           임의 집합에 대한 처리가 용이           수행 속도가 빨라짐           SQL 문장 구성이 단순해짐                       단점                    컬럼이 증가해 디스크 저장 공간이 증가           서브타입에 대한 구분이 필요한 경우가 많이 발생           인덱스 크기의 증가로 인덱스 효율이 떨어짐                           서브타입 기준 테이블 변환            슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입을 개별적인 테이블로 만드는 것       서브타입에 속성이나 관계가 많이 포함된 경우 적용       장점                    서브타입 속성들의 선택 사양이 명확한 경우 유리           처리할 때마다 서브타입 유형을 구분할 필요가 없음           테이블당 크기가 감소하여 전체 테이블 스캔시 유리                       단점                    수행 속도 감소           복잡한 처리를 하는 SQL의 통합이 어려움           부분 범위에 대한 처리가 곤란           여러 테이블을 통합한 뷰는 조회만 가능           식별자의 유지 관리가 어려움                           개별타입 기준 테이블 변환            슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환       1:1 관계가 형성       전체 데이터에 대한 처리가 빈번한 경우       서브타입의 처리가 대부분 독립적으로 발생하는 경우       통합하는 테이블의 컬럼 수가 많은 경우       서브타입의 컬럼 수가 많은 경우       트랜잭션이 주로 슈퍼타입에서 발생하는 경우       슈퍼타입의 처리 범위가 넓고 빈번하게 발생하여 단일 테이블 클러스터링이 필요한 경우       장점                    저장 공간이 상대적으로 작음           슈퍼타입 또는 서브타입 각각의 테이블에 속한 정보만 조회하는 경우 문장 작성 용이                       단점                    슈퍼타입 또는 서브타입의 정보를 같이 처리하면 항상 조인이 발생하여 성능이 저하됨                           - 속성을 컬럼으로 변환      논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환   일반 속성 변환            표준화 된 약어를 사용하여 일치시키는 것이 좋음       SQL 예약어 사용을 피함       가능한 한 짧게 지정       복합 단어를 컬럼명으로 사용할 때는 미리 정의된 표준을 따름       샘플 데이터를 작성하여 컬럼의 정합성 검증           Primary UID를 기본키로 변환            논리 데이터 모델에서의 Primary UIU는 물리 데이터 모델의 기본키로 만듬           Primary UID(관계의 UID Bar)를 기본키로 변환            다른 Entity와의 관계로 인해 생성된 Primary UIU는 물리 데이터 모델의 기본키로 만듬           Secondary(Alternate) UID를 유니크기로 변환            논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크 키로 만듬           - 관계를 외래키로 변환      기본키와 이를 참조하는 외래키로 변환   1:1 관계            A의 기본키를 B의 외래키로 추가하거나 B의 기본키를 A의 외래키로 추가하여 표현           1:N 관계            A의 기본키를 B의 외래키로 추가하여 표현하거나 별도의 테이블로 표현           N:M 관계            A와 B의 기본키를 모두 포함한 별도의 릴레이션으로 표현           1:N 순환 관계            A에 A의 기본키를 참조하는 외래키 컬럼을 추가하여 표현       데이터의 계층 구조를 표현하기 위해 주로 사용           - 관리 목적의 테이블/컬럼 추가      논리 데이터 모델에 존재하지 않는 테이블이나 컬럼을 물리 데이터 모델에 추가하여 DB의 관리 혹은 프로그래밍의 수행 속도를 향상시킬 수 있음   - 데이터 타입 선택      DBMS의 물리적 특성과 성능을 고려하여 최적의 데이터 타입과 데이터의 최대 길이 선택   문자타입, 숫자타입, 날짜타입 등  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp11/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 배경, 배치",
        "excerpt":"배경   - background-color   /* 요소의 배경 색상 */ background-color {   기본값: transparent; 투명함   색상: 지정 가능한 색상; }       - background-image   /* 요소의 배경 이미지 삽입 */ background-image {   기본값: none; 이미지 없음   background-image: url(\"경로\"); 이미지 경로 }       - background-repeat   /* 요소의 배경 이미지 반복 */ background-repeat {   기본값: repeat; 이미지를 수직, 수평 반복   background-repeat: repeat-x; 이미지를 수평 반복   background-repeat: repeat-y; 이미지를 수직 반복   background-repeat: no-repeat; 반복 없음 }       - background-position   /* 요소의 배경 이미지 위치 */ background-position {   기본값: 0% 0%; 0% ~ 100% 사이 값   방향: top, bottom, left, right, center;   단위: px, em, rem;  }       - background-size   /* 요소의 배경 이미지 크기 */ background-size {   기본값: auto; 이미지의 실제 크기   단위: px, em, rem;   cover: 비율을 유지, 요소의 더 넓은 너비에 맞춤;   contain: 비율을 유지, 요소의 더 짧은 너비에 맞춤; }       - background-attachment   /* 요소의 배경 이미지 스크롤 특성 */ background-attachment {   기본값: scroll; 이미지가 요소를 따라서 같이 스크롤   background-attachment: fixed; 이미지가 뷰포트에 고정, 스크롤X   background-attachment: local; 요소 내 스크롤 시 이미지가 같이 스크롤 }       배치   - position   /* 요소의 위치 지정 기준 */ position {   기본값: static; 기준 없음   position: relative; 요소 자신을 기준   position: absolute; 위치 상 부모 요소를 기준, 부모 꼭 확인해야 함   position: fixed; 뷰포트를 기준   position: sticky; 스크롤 영역 기준   position과 같이 사용하는 CSS속성들은 모두 음수 사용 가능 }       - 요소 쌓임 순서      어떤 요소가 사용자와 더 가깝게 있는지 결정            요소에 position 속성의 값이 있는 경우 위에 쌓임(static제외)       1번 조건이 같은 경우, z-index 속성의 숫자 값이 높을 수록 위에 쌓임       1, 2번 조건이 같은 경우, HTML의 다음 구조일 수록 위에 쌓임           - z-index   /* 요소 쌓임 정도를 지정 */ z-index {   기본값: auto; 부모 요소와 동일한 쌓임 정도   숫자: 숫자가 높을 수록 위에 쌓임; }   - 요소의 display가 변경      position 속성의 값으로 absolute, fixed가 지정된 요소는 display 속성이 block로 변경   태그 {   display: block;   position: absolute;   top: 30px;   left: 30px;   z-index: 1; }  /* 위와 아래는 동일 */  태그 {   position: absolute;   top: 30px;   left: 30px;   z-index: 1;   }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-bgpo/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-3. SQL 응용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. SQL의 개념 – B   - SQL의 개요      국제 표준 DB 언어. 많은 회사에서 RDB를 지원하는 언어로 채택   관계대수와 관계해석을 기초로 한 혼합 데이터 언어   질의어지만 질의 기능 뿐만 아니라 데이터 구조 정의, 데이터 조작, 제어 기능을 모두 갖춤   - SQL의 분류      DDL(Data Define Language, 데이터 정의어)            SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용       논리적 데이터 구조와 물리적 데이터 구조의 사상을 정의       DB 관리자나 DB 설계자가 사용       CREATE : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의       ALTER : TABLE에 대한 정의를 변경하는 데 사용       DROP : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제           DML(Data Manipulation Language, 데이터 조작어)            저장된 데이터를 실질적으로 처리하는 데 사용       DB 사용자와 DB 관리 시스템 간의 인터페이스 제공       SELECT : 튜플 검색       INSERT : 튜플 삽입       DELETE : 튜플 삭제       UPDATE : 튜플 내용 변경           DCL(Data Control Language, 데이터 제어어)            데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는데 사용       DB 관리자가 데이터 관리를 목적으로 사용       COMMIT : 결과를 물리적 디스크로 저장. 작업이 완료되었음을 관리자에게 알려줌       ROLLBACK : 비정상적으로 종료되었을 때 원래의 상태로 복구       GRANT : 사용자에게 사용 권한을 부여       REVOKE : 사용자의 사용 권한을 취소               2. DDL – C   - DDL 개념      DB를 구축하거나 수정 할 목적으로 사용하는 언어   데이터 사전에 여러개의 테이블로서 저장됨   - CREATE SCHEMA      스키마를 정의하는 명령문   스키마 이름과 소유권자나 허가권자를 정의   CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_id;  // ID가 홍길동인 스키마 대학교를 정의하는 SQL문 CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;       - CREATE DOMAIN      도메인을 정의하는 명령문   SQL 에서 지원하는 전체 테이터 타입의 값이 아니고 일부분일 때, 그 값의 범위를 도메인으로 정의   일반적인 데이터 타입처럼 사용   CREATE DOMAIN 도메인명 [AS] 데이터_타입   [DEFAULT 기본값]   [CONSTRAINT 제약조건명 CHECK (범위값)];  // '성별'을 '남' 또는 '여'와 같이 정해진 1개의 문자로 표현되는 도메인 SEX를 정의하는 SQL문 CREATE DOMAIN SEX CHAR(1)   DEFAULT '남'   CONSTRAINT VALID-SEX CHECK(VALUE IN('남', '여'));       - CREATE TABLE      테이블을 정의하는 명령문   CREATE TABLE 테이블명   (속성명 데이터_타입 [DEFAULT 기본값] [NOT NULL], ...   [, PRIMARY KEY(기본키_속성명, ...)]   [, UNIQUE(대체키_속성명, ...)]   [, FOREIGN(외래키_속성명, ...)]     [REFERENCES 참조테이블(기본키_속성명, ...)]     [ON DELETE 옵션]     [ON UPDATE 옵션]   [, CONSTRAINT 제약조건명] [CHECK (조건식)]);      UNIQUE : 대체키로 사용할 속성. 중복된 값 가질 수 없음   FOREIGN KEY ~ REFERENCES ~            참조할 다른 테이블과 참조할 때 사용할 외래키 속성 지정       외래키가 지정되면 참조 무결성의 CASCADE 법칙이 적용됨       ON DELETE 옵션 : 튜플이 삭제되었을 때 옵션. NO ACTION, CASCADE, SET NULL, SET DEFAULT       ON UPDATE 옵션 : 참조 속성 값이 변경되었을 때 옵션. NO ACTION, CASCADE, SET NULL, SET DEFAULT                    NO ACTION : 기본 테이블에 아무런 조취를 취하지 않음           CASCADE : 참조 테이블의 튜플이 삭제, 수정되면 기본 테이블 튜플 삭제, 수정됨           SET NULL : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플 속성 값을 NULL로 변경           SET DEFAULT : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플 속성 값을 기본값으로 변경                           CONSTRAINT : 제약 조건의 이름을 지정.   CHECK : 속성 값에 대한 제약 조건 정의   CREATE TABLE 학생   (이름 VARCHAR(15) NOT NULL,   학번 CHAR(8),   전공 CHAR(5),   성별 SEX,   생년월일 DATE,   PRIMARY KEY(학번),   FOREIGN KEY(전공) REFERENCES 학과(학과코드)     ON DELETE SET NULL     ON UPDATE CASCADE,   CONSTRAINT 생년월일제약     CHECK(생년월일&gt;='1980-01-01'));       - CREATE VIEW      뷰를 정의하는 명령문   CREATE VIEW 뷰명[(속성명[, 속성명, ...])] AS SELECT문;      SELECT문은 서브 쿼리로 사용하여 SELECT문의 결과로서 뷰를 생성   SELECT문에는 UNION이나 ORDER BY절을 사용할 수 없음   속성명을 기술하지 않으면 SELECT문의 속성명이 자동으로 사용됨   // &lt;고객&gt; 테이블에서 '주소'가 '안산시'인 고객들의 // '성명'과 '전화번호'를 '안산고객'이라는 뷰로 정의 CREATE VIEW 안산고객(성명, 전화번호) AS SELECT 성명, 전화번호 FROM 고객 WHERE 주소 = '안산시';       - CREATE INDEX      인데스를 정의하는 명령문   CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(속성명 [ASC | DESC] [,속성명 [ASC | DESC]]) [CLUSTER];      UNIQUE : 사용된 경우 중복값 없는 속성으로 인덱스 생성. 생략된 경우 중복 값 허용   정렬            ASC : 오름차순       DESC : 내림차순       생략시 : 오름차순           CLUSTER : 사용하면 인덱스가 클러스터드 인덱스로 설정됨   // &lt;고객&gt; 테이블에서 UNIQUE한 특성을 갖는 '고객번호' 속성에 대해 // 내림차순으로 정렬하여 '고객번호_idx'라는 이름으로 인덱스를 정의 CREATE UNIQUE INDEX 고객번호_idx ON 고객(고객번호 DESC);       - ALTER TABLE      테이블에 대한 정의를 변경하는 명령문   // ADD : 새로운 속성을 추가할 때 사용 ALTER TABLE 테이블명 ADD 속성명 데이터_타입 [DEFAULT '기본값'];  // ALTER : 특정 속성의 Default 값을 변경할 때 사용 ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];  // DROP COLUMN 특정 속성을 삭제할 때 사용 ALTER TABLE 테이블명 DROP COLUMN 속성명[CASCADE];   // &lt;학생&gt; 테이블에 최대 3문자로 구성되는 '학년' 속성 추가 ALTER TABLE 학생 ADD 학년 VARCHAR(3);  // &lt;학생&gt; 테이블의 '학번' 필드의 데이터 타입과 크기를 VARCHAR(10)으로 // 하고 NULL 값이 입력되지 않도록 변경 ALTER TABLE 학생 ALTER 학번 VARCHAR(10) NOT NULL;       - DROP      스키마, 도메인, 테이블, 뷰, 인덱스, 제약 조건 등을 제거하는 명령문   DROP SCHEMA 스키마명 [CASCADE | RESTRICT]; DROP DOMAIN 도메인명 [CASCADE | RESTRICT]; DROP TABLE 테이플명 [CASCADE | RESTRICT]; DROP VIEW 뷰명 [CASCADE | RESTRICT]; DROP INDEX 인덱스명 [CASCADE | RESTRICT]; DROP CONSTRAINT 제약조건명;      CASCADE : 참조하는 다른 모든 개체를 함께 제거. 참조 무결성 제약 조건을 설정하기 위해 사용   RESTRICTED : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소       3. DCL – C   - DCL 개념      데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어   DB 관리자(DBA)가 데이터 관리를 목적으로 사용   - GRANT / REVOKE      사용자에게 권한을 부여하거나 취소하기 위한 명령어   // 사용자등급 지정 및 해제 GRANT 사용자등급 TO 사용자_ID_리스트 [IDENTIFIED BY 암호]; REVOKE 사용자등급 FROM 사용자_ID_리스트   // ID가 \"NABI\"인 사람에게 DB 및 테이블을 생성할 수 있는 권한 부여 GRANT RESOURCE TO NABI;  // ID가 \"STAR\"인 사람에게 DB 정보를 검색할 수 있는 권한을 부여 GRANT CONNECT TO STAR;   // 테이블 및 속성에 대한 권한 부여 및 취소 GRANT 권한_리스트 ON 개체 TO 사용자 [WITH GRANT OPTION]; REVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [CASCADE];      권한 종류 : ALL, SELECT, INSERT, DELETE, UPDATE, ALTER 등   WITH GRANT OPTION : 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여   GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소   CASCADE : 권한 취소 시 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 취소   // ID가 \"NABI\"인 사람에게 &lt;고객&gt; 테이블에 대한 모든 권한과 다른 사람 // 에게 권한을 부여할 수 있는 권한까지 부여 GRANT ALL ON 고객 TO NABI WITH GRANT OPTION;  // ID가 \"STAR\"인 사람에게 부여한 &lt;고객&gt; 테이블에 대한 권한 중 UPDATE // 권한을 다른 사람에게 부여할 수 있는 권한만 취소 REVOKE GRANT OPTION FOR UPDATE ON 고객 FROM STAR;       - COMMIT      트랜잭션이 성공적으로 끝나면 DB가 새로운 일관성 상태를 가지기 위해 변경된 모든 내용을 반영   COMMIT 명령을 실행하지 않아도 DML문이 성공적으로 완료되면 자동으로 COMMIT 됨   DML이 실패하면 자동으로 ROLLBACK이 되도록 Auto Commit 기능을 설정할 수 있음   - ROLLBACK      아직 COMMIT되지 않은 변경된 모든 내용들을 취소하고 DB를 이전 상태로 되돌리는 명령어   일부분만 완료된 트랜잭션은 ROLLBACK 되어야 함   - SAVEPOINT      트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정하는 명령어   ROLLBACK 시 지정된 SAVEPOINT까지 트랜잭션 처리 내용이 취소됨       4. DML – B   - DML의 개념      DB 사용자가 응용 프로그램이나 질의어를 통해 데이터를 실질적으로 관리하는데 사용되는 언어   사용자와 DBMS 간의 인터페이스를 제공   - 삽입문(INSERT INTO ~ )      기본 테이블에 새로운 튜플을 삽입할 때 사용   INSERT INTO 테이블명([속성명1, 속성명2, ...]) VALUES (데이터1, 데이터2, ...)      대응하는 속성과 데이터는 개수와 데이터 유형이 일치해야 함   기본 테이블의 모든 속성을 사용할 때는 속성명을 생략할 수 있음   SELECT문을 사용하여 다른 테이블의 검색 결과를 삽입할 수 있음   // &lt;사원&gt; 테이블에 (이름 - 홍승현, 부서 - 인터넷)을 삽입 INSERT INTO 사원(이름, 부서) VALUES ('홍승현', '인터넷');  // &lt;사원&gt; 테이블에 (장보고, 기획, 05/03/73, 홍제동, 90)을 삽입 INSERT INTO 사원 VALUES('장보고', '기획', #05/03/73#, '홍제동', 90);  // &lt;사원&gt; 테이블에 있는 편집부의 모든 튜플을 편집부원(이름, 생일, 주소, 기본급) // 테이블에 삽입 INSERT INTO 편집부원(이름, 생일, 주소, 기본급) SELECT 이름, 생일, 주소, 기본급 FROM 사원 WHERE 부서 = '편집';       - 삭제문(DELETE FROM ~ )      기본 테이블에 있는 튜플들 중에서 특정 튜플을 삭제할 때 사용   DELETE FROM 테이블명 [WHERE 조건];      모든 레코드를 삭제할 때는 WHERE절을 생략   모든 레코드를 삭제하더라도 테이블 구조는 남아있기 때문에 DROP과는 다름   // &lt;사원&gt; 테이블에서 \"임꺽정\"에 대한 튜플을 삭제 DELETE FROM 사원 WHERE 이름 = '임꺽정';  // &lt;사원&gt; 테이블에서 \"인터넷\" 부서에 대한 모든 튜플을 삭제 DELETE FROM 사원 WHERE 부서 = '인터넷';  // &lt;사원&gt; 테이블의 모든 레코드를 삭제 DELETE FROM 사원;       - 갱신문(UPDATE ~ SET ~)      기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용   UPDATE 테이블명 SET 속성명 = 데이터[, 속성명=데이터, ...] [WHERE 조건];   // &lt;사원&gt; 테이블에서 \"홍길동\"의 '주소'를 \"수색동\"으로 수정 UPDATE 사원 SET 주소 = '수색동' WHERE 이름 = '홍길동'  // &lt;사원&gt; 테이블에서 \"황진이\"의 '부서'를 \"기획부\"로 변경하고 // '기본급'을 5만원 인상 UPDATE 사원 SET 부서 = '기획', 기본급 = 기본급 + 5 WHERE 이름 = '황진이';       - DML의 4가지 유형      SELECT~ FROM~ WHERE~   INSERT INTO~ VALUES~   DELETE~ FROM~ WHERE~   UPDATE~ SET~ WHERE~       5. DML - SELECT-1 – A   - 일반 형식   SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] FROM 테이블명[, 테이블명, ...] [WHERE 조건] [ORDER BY 속성명 [ASC | DESC]];      SELECT절            PREDICATE : 불러올 튜플 수를 제한할 명령어를 기술                    ALL : 모든 튜플을 검색할 때 지정. 주로 생략           DISTINCT : 중복된 튜플이 있으면 그 중 첫 번째 한 개만 검색           DISTINCTROW : 중복된 튜플을 제거하고 한 개만 검색. 튜플 전체를 대상으로 함                       속성명 : 검색하여 불러올 속성(열) 또는 속성을 이용한 수식을 지정                    모든 속성을 지정할 때는 ‘*‘를 기술           두 개 이상의 테이블을 대상으로 검색할 때는 ‘테이블명.속성명’으로 표현                       AS : 속성 및 연산의 이름을 다른 제목으로 표시하기 위해 사용           FROM절 : 검색될 데이터들을 포함하는 테이블명 기술   WHERE절 : 검색할 조건을 기술   ORDER BY절 : 특정 속성을 기준으로 정렬하여 검색할 때 사용            ASC : 오름차순       DESC : 내림차순       생략 : 오름차순           - 조건 연산자 / 연산자 우선순위      조건 연산자            비교 연산자 : =, &lt;&gt;, &gt;, &lt;, &gt;=, &lt;=       논리 연산자 : NOT, AND, OR       LIKE 연산자 : %(모든 문자 대표), -(문자 하나 대표), #(숫자 하나 대표)           연산자 우선순위            산술 연산자 : x, /, +, -  -&gt; 왼쪽에서 오른쪽으로 갈수록 낮아짐       관계 연산자 : =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=  -&gt; 모두 같음       논리 연산자 : NOT, AND, OR  -&gt; 왼쪽에서 오른쪽으로 갈수록 낮아짐           산술 &gt; 관계 &gt; 논리       6. DML - SELECT-2 – A   - 일반 형식   SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] [, 그룹함수(속성명) [AS 별칭]] [, WINDOW함수 OVER (PARTITION BY 속성명1, 속성명2, ...   ORDER BY 속성명3, 속성명4, ...) [AS 별칭]] FROM 테이블명[, 테이블명, ...] [WHERE 조건] [GROUP BY 속성명, 속성명, ...] [HAVING 조건] [ORDER BY 속성명 [ASC | DESC]];      그룹함수 : GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술   WINDOW 함수 : GROUP BY절을 이용하지 않고 속성의 값을 집계할 함수를 기술            PARTITION BY : WINDOW 함수가 적용될 범위로 사용할 속성을 지정       ORDER BY : PARTITION 안에서 정렬 기준으로 사용할 속성을 지정           GROUP BY절 : 특정 속성을 기준으로 그룹화하여 검색할 때 사용. 그룹 함수와 함께 사용   HAVING절 : GROUP BY와 함꼐 사용되며, 그룹에 대한 조건을 지정   - 집합 연산자를 이용한 통합 질의      집합 연산자를 사용하여 2개 이상의 테이블의 데이터를 하나로 통합   SELECT 속성명1, 속성명2, ... FROM 테이블명 UNION | UNION ALL | INTERSECT | EXCEPT SELECT 속성명1, 속성명2, ... FROM 테이블명 [ORDER BY 속성명 [ASC | DESC]];       7. DML - JOIN – B   - JOIN의 개념      2개의 테이블에 대해 연관된 튜플들을 결합하여 하나의 새로운 릴레이션을 반환   일반적으로 FROM절에 기술하지만, 어느 곳에서나 사용할 수 있음   - INNER JOIN      조건이 없는 INNER JOIN을 수행하면 CROSS JOIN과 동일한 결과를 얻음   EQUI JOIN            JOIN 대상 테이블에서 공통 속성을 기준으로 ‘=’ 비교에 의해 같은 값을 가지는 행을 연결       JOIN 조건이 ‘=’일 때 동일한 속성이 두 번 나타남, 중복된 속성을 제거한 것을 NATURAL JOIN       EQUI JOIN에서 연결 고리가 되는 공통 속성을 JOIN 속성이라고 함           // WHERE절을 이용한 EQUI JOIN의 표기 형식 SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2, ... WHERE 테이블명1.속성명 = 테이블명2.속성명;  // NATURAL JOIN절을 이용한 EQUI JOIN의 표기 형식 SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 NATURAL JOIN 테이블명2;  // JOIN ~ USING절을 이용한 EQUI JOIN 표기 형식 SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 JOIN 테이블명2 USING(속성명);      NON-EQUI JOIN            JOIN 조건에 ‘=’ 조건이 아닌 나머지 비교 연산자를 사용하는 JOIN 방법           SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2, ... WHERE (NON-EQUI JOIN 조건);       - OUTER JOIN      JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 방법   // LEFT OUTER JOIN SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 LEFT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명;  SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2 WHERE 테이블명1.속성명 = 테이블명2.속성명(+);   // RIGHT OUTER JOIN SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 RIGHT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명;  SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2 WHERE 테이블명1.속성명(+) = 테이블명2.속성명;   // FULL OUTER JOIN SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 FULL OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명;       - SELF JOIN      같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN   SELECT [별칭1.]속성명, [별칭1.]속성명, ... FROM 테이블명1 [AS] 별칭1 JOIN 테이블명1 [AS] 별칭2 ON 별칭1.속성명 = 별칭2.속성명;  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp12/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-4. SQL 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 프로시저 – A   - 프로시저의 개요      절차형 SQL을 활용하여 특정 기능을 수행하는 트랜잭션 언어   미리 저장해 놓은 SQL 작업을 수행   여러 프로그램에서 호출하여 사용   스토어드 프로시저라고도 불림   시스템의 일일 마감 작업, 일괄 작업 등에 주로 사용   DECLARE (필수) BEGIN (필수)   CONTROL   SQL   EXCEPTION   TRANSACTION END (필수)      DECLARE : 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의   BEGIN / END : 프로시저의 시작과 종료   CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리   SQL : DML, DCL이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업 수행   EXCEPTION : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의   TRANSACTION : DB에 적용할지 취소할지를 결정하는 처리부   - 프로시저 생성   CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터) [지역변수 선언] BEGIN   프로시저 BODY; END;      OR REPLACE : 선택적인 예약어. 동일한 프로시저 이름이 이미 존재하는 경우, 대체 가능   프로시저명 : 생성하려는 프로시저의 이름 지정   파라미터            IN : 호출 프로그램이 프로시저에게 값을 전달할 때       OUT : 프로시저가 호출 프로그램에게 값을 반환할 때       INOUT : 전달, 반환       매개변수명 : 전달받은 값을 저장할 변수의 이름 지정       자료형 : 변수의 자료형 지정           프로시저 BODY            프로시저의 코드를 기록       BEGIN과 END 사이에는 적어도 하나의 SQL문이 있어야 함           // '사원번호'를 입력받아 해당 사원의 '지급방식'을 \"S\"로 변경하는 프로시저 생성 CREATE OR REPLACE PROCEDURE emp_change_s(i_사원번호 IN INT) IS BEGIN   UPDATE 급여 SET 지급방식 = 'S' WHERE 사원번호 = i_사원번호;   EXCEPTION     WHEN PROGRAM_ERROR THEN       ROLLBACK;   COMMIT; END;       - 프로시저 실행   EXECUTE 프로시저명; EXEC 프로시저명; CALL 프로시저명;       - 프로시저 제거   DROP PROCEDURE 프로시저명;       2. 트리거 – B   - 트리거의 개요      삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL   DB에 저장되며, 데이터 변경 및 무경성 유지, 로그 메시지 출력 등의 목적으로 사용   DCL을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 에러 발생   - 트리거의 구성   DECLARE (필수) EVENT (필수) BEGIN (필수)   CONTROL   SQL   EXCEPTION END (필수)       - 트리거의 생성   CREATE [OR REPLACE] TRIGGER 트리거명 동작시기 동작 ON 테이블명 [REFERENCING NEW | OLD AS 테이블명] [FOR EACH ROW [WHEN 조건식]] BEGIN   트리거 BODY; END;      OR REPLACE : 동일한 트리거 이름이 이미 존재하는 경우, 기존의 트리거를 대체   동작시기 : 트리거가 실행될 때를 지정            AFTER : 테이블이 변경된 후에 트리거 실행       BEFORE : 테이블이 변경되기 전에 트리거 실행           동작 : 트리거가 실행되게 할 작업의 종류를 지정            INSERT : 테이블에 새로운 튜플을 삽입할 때 트리거 실행       DELETE : 테이블의 튜플을 삭제할 때 트리거 실행       UPDATE : 테이블의 튜플을 수정할 때 트리거 실행                                           NEW           OLD : 트리거가 적용될 테이브르이 별칭을 지정                                 NEW : 추가되거나 수정에 참여할 튜플들의 집합       OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합           FOR EACH ROW : 튜플마다 트리거를 적용한다는 의미   WHEN 조건식 : 선택적인 예약어. 트리거를 적용할 튜플의 조건을 지정   트리거 BODY            트리거의 본문 코드를 입력하는 부분       BEGIN ~ END 사이에 적어도 하나 이상의 SQL문이 있어야 함           // &lt;학생&gt; 테이블에 새로운 튜플이 삽입될 때, 삽입되는 튜플에 학년 정보가 누락 // 됐으면 '학년'필드에 \"신입생\"을 치환하는 트리거를 '학년정보_tri' 이름으로 정의 CREATE TRIGGER 학년정보_tri BEFORE INSERT ON 학생 REFERENCING NEW AS new_table FOR EACH ROW WHEN (new_table.학년 IS NULL)   BEGIN     :new_table.학년 := '신입생';   END;   - 트리거의 제거   DROP TRIGGER 트리거명;       3. 사용자 정의 함수 – B   - 사용자 정의 함수의 개요      프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리   종료 시 처리 결과를 단일값으로 반환하는 절차형 SQL   DML문의 호출에 의해 실행됨   예약어 RETURN을 통해 값을 반환하기 때문에 출력 파라미터가 없음   INSERT, DELETE, UPDATE를 통한 테이블 조작은 할 수 없고 SELECT를 통한 조회만 가능   프로시저를 호출하여 사용할 수 없음   DML문에서 반환값을 활용하기 위한 용도로 사용   - 프로시저 vs 사용자 정의 함수                  구분       프로시저       사용자 정의 함수                       반환값       없거나 1개 이상 가능       1개                 파라미터       입출력 가능       입력만 가능                 사용 가능 명령문       DML, DCL       SELECT                 호출       프로시저, 사용자 정의 함수       사용자 정의 함수                 사용 방법       실행문       DML에 포함           - 사용자 정의 함수의 구성   DECLARE (필수) BEGIN (필수)   CONTROL   SQL   EXCEPTION   RETURN (필수) END (필수)      DECLARE : 선언부   BEGIN / END : 시작과 종료   CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리   SQL : SELECT문이 삽입되어 데이터 조회 작업 수행   EXCEPTION : 예외 처리   RETURN : 호출 프로그램에 반환할 값이나 변수를 정의   - 사용자 정의 함수 생성   CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터) [지역변수 선언] BEGIN   사용자 정의 함수 BODY;   RETURN 반환값; END      OR REPLACE : 동일한 사용자 정의 함수의 이름이 존재하는 경우, 기존의 함수 대체   파라미터            IN : 호출 프로그램이 사용자 정의 함수에게 값을 전달할 때 지정       매개변수명 : 전달받은 값을 저장할 변수의 이름 지정       자료형 : 변수의 자료형 지정           사용자 정의 함수 BODY            코드를 기록하는 부분       BEGIN ~ END 사이에는 적어도 하나의 SQL문이 있어야 함           RETURN 반환값 : 반환할 값이나 변수를 호출 프로그램으로 돌려줌   // 'i_성별코드'를 입력받아 1이면 \"남자\"를, 2면 \"여자\"를 반환하는 사용자 정의 // 함수를 'Get_S_성별'이라는 이름으로 정의 CREATE FUNCTION Get_S_성별(i_성별코드 IN INT) RETURN VARCHAR2 IS BEGIN   IF i_성별코드 = 1 THEN     RETURN '남자';   ELSE     RETURN '여자';   END IF END;       - 사용자 정의 함수 실행   SELECT 사용자 정의 함수명 FROM 테이블명; INSERT INTO 테이블명(속성명) VALUES (사용자 정의 함수명); DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명; UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명;       - 사용자 정의 함수 제거   DROP FUNCTION 사용자 정의 함수명;       4. DBMS 접속 기술 – B   - DBMS 접속의 개요      사용자가 데이터를 사용하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것   응용시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달하는 매개체 역할 수행   웹 응용 프로그램은 웹 응용 시스템을 통해 DBMS에 접근   웹 응용 시스템은 웹 서버와 웹 애플리케이션 서버(WAS)로 구성   규모가 작은 경우 웹 서버와 WAS를 통합하여 하나의 서버만으로 운용 가능   - 웹 응용 시스템의 구조      사용자 &lt;-&gt; 웹 서버 &lt;-&gt; WAS &lt;-&gt; DBMS   - DBMS 접속 기술      DBMS에 접근하기 위해 사용하는 API 또는 API의 사용을 편리하게 도와주는 프레임워크   JDBC(Java DataBase Connectivity)            Java 언어로 다양한 DB에 접속하고 SQL문을 수행할 때 사용되는 표준 API       Java SE에 포함. JDBC 클래스는 java.sql, javax.sql에 포함       접속하려는 DBMS에 대한 드라이버 필요           ODBC(Open DataBase Connectivity)            DB에 접근하기 위한 표준 개방형 API. 개발 언어에 관계없이 사용 가능       MS에서 출시       ODBC 문장을 사용하여 SQL을 작성하면 해당 DBMS의 인터페이스에 맞게 연결해 줌           MyBatis            JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈 소스 접속 프레임워크       간소화, 접속 기능 강화       SQL 문장을 분리하여 XML파일 만들고, Mapping을 통해 SQL 실행       SQL을 거의 그대로 사용할 수 있음           - 동적 SQL(Dynamic SQL)      개발 언어에 삽입되는 SQL코드를 문자열 변수에 넣어 처리   SQL문의 일부 또는 전부를 입력받아 실행할 수 있음   값이 입력되지 않을 경우 사용하는 NVL 함수를 사용할 필요가 없음   프리컴파일 할 때 구문 분석, 접근 권한 확인 등을 할 수 없음   정적 SQL에 비해 속도가 느리지만, 유연한 개발이 가능함   - 정적 SQL vs 동적 SQL                  구분       정적 SQL       동적 SQL                       SQL 구성       커서를 통한 정적 처리       문자열 변수에 담아 동적 처리                 개발 패턴       반복문 활용하여 SQL작성       NVL 없이 로직을 통해 SQL 작성                 실행 속도       빠름       느림                 사전 검사       가능       불가능               5. SQL 테스트 – B   - SQL 테스트의 개요      SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증   단문 SQL은 코드를 직접 실행한 후 결과를 확인   절차형 SQL은 테스트 전에 생성을 통해 Syntax Error나 참조 오류의 존재 확인   정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고, 결과를 통해 최종 확인   - 단문 SQL 테스트      직접 실행하여 결과물 확인   오류 발생 시 메시지를 참조하여 문제를 해결   DESCRIBE 명령어로 DDL로 작성된 테이블이나 뷰의 속성, 자료형, 옵션들을 확인 가능   DML로 변경한 데이터는 SELECT문으로 데이터의 정상적인 변경 여부를 확인   DCL로 설정된 사용자 권한은 해당 테이블을 SELECT로 조회하거나, SHOW 명령어로 확인            Oracle : SELECT * FROM ~~~       MySQL : SHOW GRANTS FOR ~~~           // MySQL에서 &lt;학생&gt; 테이블의 정보를 확인하는 SQL문 작성 DESC 학생;  // Oracle에서 'SINAGONG' 사용자의 시스템 권한을 확인하는 SQL문 작성 SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE = 'SINAGONG';  // MySQL에서 localhost 서버의 'SINAGONG' 사용자에 대한 권한을 확인하는 SQL문 작성 SHOW GRANTS FOR 'SINAGONG'@'localhost';       - 절차형 SQL 테스트      디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인   SHOW 명령어를 통해 오류 내용을 확인하고 문제를 수정   DB에 변화를 줄 수 있는 SQL문은 주석으로 처리하고, 출력문을 이용해 확인            Oracle 출력 형식                    DBMS_OUTPUT.ENABLE; : DBMS_OUTPUT 패키지를 불러옴           DBMS_OUTPUT.PUT_LINE(데이터); : ‘데이터’에 넣은 변수나 값을 출력                       MySQL 출력 형식                    SELECT 데이터; : ‘데이터’에 넣은 변수나 값을 출력                           디버깅이 완료되면 출력문을 삭제하고 주석을 제거   // Oracle에서 변수 RESULT를 출력하는 SQL문 작성 DBMS_OUTPUT.ENABLE; DBMS_OUTPUT.PUT_LINE(RESULT);  // MySQL에서 변수 RESULT를 출력하는 SQL문 작성 SELECT RESULT;       6. ORM(Object-Relational Mapping) – B   - ORM의 개요      객체지향 프로그래밍의 객체와 RDB의 데이터를 Mapping하는 기술   가상의 객체지향 DB를 만들어 프로그래밍 코드와 데이터를 연결   재사용 및 유지보수 용이   직관적이고 간단하게 데이터 조작 가능   - ORM 프레임워크      JAVA : JPA, Hibernate, EclipseLink, DataNucleus, Ebean 등   C++ : ODB, QxOrm 등   Python : Django, SQLAlchemy, Strom 등   iOS : DatabaseObjects, Core Data 등   .NET : NHibernate, DatabaseObjects, Dapper 등   PHP : Doctrine, Propel, RedBean 등   - ORM의 한계      의도대로 SQL이 작성되었는지 확인할 필요가 있음   프로젝트가 크고 복잡해질수록 ORM 기술을 적용하기 어려움   ORM에 적합하게 변환하려면 많은 시간과 노력 필요  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp13/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-5. 데이터 전환",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 데이터 전환 – B   - 데이터 전환의 정의      운영 중인 기존 정보 시스템에 축적되어 있는 데이터를 추출하여 새로 개발할 정보 시스템에서 운영 가능하도록 변환한 후, 적재하는 일련의 과정   데이터 전환을 ETL(Extraction, Transformation, Load), 추출, 변환, 적재 과정이라 함   데이터 이행 또는 데이터 이관이라고도 함   - 데이터 전환 계획서      데이터 전환 작업에 필요한 모든 계획을 기록하는 문서  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp14/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 정렬, 전환, 변환",
        "excerpt":"정렬   - display   /* Flex Container의 화면 출력 특성 */ display {   display: flex; 블록 요소와 같이 Flex Container 정의   display: inline-flex; 인라인 요소와 같이 Flex Container 정의 }       - flex-direction   /* 주 축을 설정 */ flex-direction {   기본값: row; 행 축 (좌 -&gt; 우)   flex-direction: row-reverse; 행 축 (우 -&gt; 좌)   flex-direction: column; 열 축 (위 -&gt; 아래)   flex-direction: column-reverse; 열 축 (아래 -&gt; 위) }       - flex-wrap   /* Flex Items 묶음(줄 바꿈) 여부 */ flex-wrap {   기본값: nowrap; 묶음(줄 바꿈) 없음   flex-wrap: wrap; 여러 줄로 묶음   flex-wrap: wrap-reverse; wrap의 반대 방향으로 묶음 }       - justify-content   /* 주 축의 정렬 방법 */ justify-content {   기본값: flex-start; Flex Items를 시작점으로 정렬   justify-content: flex-end; Flex Items를 끝점으로 정렬   justify-content: center; Flex Items를 가운데 정렬   justify-content: space-between; 각 Flex Item 사이를 균등하게 정렬   justify-content: space-around; 각 Flex Item의 외부 여백을 균등하게 정렬 }       - align-content   /* 교차 축의 여러 줄 정렬 방법 */ align-content {   기본값: stretch; Flex Items를 시작점으로 정렬   align-content: flex-start; Flex Items를 시작점으로 정렬   align-content: flex-end; Flex Items를 끝점으로 정렬   align-content: center; Flex Items를 가운데 정렬   align-content: space-between; 각 Flex Item 사이를 균등하게 정렬   align-content: space-around; 각 Flex Item의 외부 여백을 균등하게 정렬 }       - align-items   /* 교차 축의 한 줄 정렬 방법 */ align-items {   기본값: stretch; Flex Items를 교차 축으로 늘림   align-items: flex-start; Flex Items를 각 줄의 시작점으로 정렬   align-items: flex-end; Flex Items를 각 줄의 끝점으로 정렬   align-items: center; Flex Items를 각 줄의 가운데 정렬   align-items: baseline; Flex Items를 각 줄의 문자 기준선에 정렬 }       - order   /* Flex Item의 순서 */ order {   기본값: 0; 순서 없음   숫자: 숫자가 작을 수록 먼저; }       - flex-grow   /* Flex Item의 증가 너비 비율 */ flex-grow {   기본값: 0; 증가 비율 없음   숫자: 증가 비율; }       - flex-shrink   /* Flex Item의 감소 너비 비율 */ flex-shrink {   기본값: 1; Flex Container 너비에 따라 감소 비율 적용   숫자: 감소 비율; }       - flex-basis   /* Flex Item의 공간 배분 전 기본 너비 */ flex-basis {   기본값: auto; 요소의 Content 너비   단위: px, em, rem; }       전환   - transition   /* 요소의 전환(시작과 끝) 효과를 지정하는 단축 속성 */ 태그 {   transition: 속성명 지속시간 타이밍함수 대기시간;   지속시간은 단축형으로 작성할 때, 필수 포함 속성 }       - transition-property   /* 전환 효과를 사용할 속성 이름을 지정 */ transition-property {   기본값: all; 모든 속성에 적용   속성이름: 전환 효과를 사용할 속성 이름 명시; }       - transition-duration   /* 전환 효과의 지속시간을 지정 */ transition-duration {   기본값: 0s; 전환 효과 없음   시간: 지속시간(s)을 지정; }       - transition-timing-function   /* 전환 효과의 타이밍(Easing) 함수를 지정 */ transition-timing-function {   기본값: ease; 느리게-빠르게-느리게   transition-timing-function: linear; 일정하게   transition-timing-function: ease-in; 느리게-빠르게   transition-timing-function: ease-out; 빠르게-느리게   transition-timing-function: ease-in-out; 느리게-빠르게-느리게   transition-timing-function: cubic-bezier(n, n, n, n); 자신만의 값을 정의(0~1)   transition-timing-function: step(n); n번 분할된 애니메이션 }       - transition-delay   /* 전환 효과가 몇 초 뒤에 시작할지 대기시간을 지정 */ transition-delay {   기본값: 0s; 대기시간 없음   시간: 대기시간(s)을 지정; }       변환      요소의 변환 효과   transform: 변환함수1 변환함수2 변환함수3 …   태그 {  transform: 원근법 이동 크기 회전 기울임; }   - 2D 변환 함수   태그 {   transform: translate(x, y); 이동(x축, y축)   transform: translateX(x); 이동(x축)   transform: translateY(y); 이동(y축)   transform: scale(x, y); 크기(x축, y축)   transform: scaleX(x); 크기(x축)   transform: scaleY(y); 크기(x축)   transform: rotate(degree); 회전(각도)   transform: skew(x, y); 기울임(x축, y축)   transform: skewX(x); 기울임(x축)   transform: skewY(y); 기울임(y축)   transform: matrix(n, n, n, n, n, n); 2차원 변환 효과 }       - 3D 변환 함수   태그 {   transform: translateZ(z); 이동(z축)   transform: translate3d(x, y, z); 이동(x축, y축, z축)   transform: scaleZ(z); 크기(z축)   transform: scale3d(x, y, z); 크기(x축, y축, z축)   transform: perspective(n); 원근법(거리)   transform: matrix3d(n, ..... , n); 3차원 변환 효과   transform: rotateX(x); 회전(x축)   transform: rotateY(y); 회전(y축)   transform: rotateZ(z); 회전(z축)   transform: rotate3d(x, y, z, a); 회전(x축, y축, z축, 각도) }       - perspective   /* 하위 요소를 관찰하는 원근 거리를 지정 */ perspective {   단위: px; }       - backface-visibility   /* 3D 변환으로 회전된 요소의 뒷면 숨김 여부 */ backface-visibility {   기본값: visible; 뒷면 보임   backface-visibility: hidden; 뒷면 숨김 }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-fltrtr/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 4-1. 서버 프로그램 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 개발 환경 구축 – B   - 개발 환경 구축의 개요      개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것   응용 소프트웨어가 운영될 환경과 유사한 구조로 구축   개발 프로젝트의 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정   비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축   - 하드웨어 환경      인터페이스 역할을 하는 클라이언트, 클라이언트와 통신하여 서비스를 제공하는 서버로 구성   클라이언트에는 PC, 스마트폰 등이 있음   서버는 사용 목적에 따라 웹 서버, 웹 애플리케이션 서버, DB 서버, 파일 서버 등이 있음   웹 서버(Web Server)            클라이언트로부터 직접 요청을 받아 처리하는 서버. 정적 파일들을 제공       Apache HTTP Server, Microsoft Internet Information Service, Google Web Server 등           웹 애플리케이션 서버(WAS; Web Application Server)            동적 서비스를 제공하기 위해 웹 서버로부터 요청을 받아 데이터 가공 작업을 수행       웹 서버와 DB서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할 수행       Apache Tomcat, IBM WebSphere, Oracle WebLogic 등           DB Server            DB와 이를 관리하는 DBMS를 운영하는 서버       MySQL Server, Oracle Server, Microsoft SQL Server 등           파일 서버(File Server)            DB에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버       AWS S3 등           - Web Server의 기능      HTTP/HTTPS 지원 : 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜   통신 기록 : 처리한 요청들을 로그 파일로 기록하는 기능   정적 파일 관리 : HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능   대역폭 제한 : 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능   가상 호스팅 : 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능   인증 : 사용자가 합법적인 사용자인지를 확인하는 기능   - 소프트웨어 환경      클라이언트 + 서버 운영을 위한 시스템 S/W + 개발에 사용되는 개발 S/W   시스템 S/W : 운영체제, 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등   개발 S/W : 요구사항 관리 도구, 설계/모델링 도구, 구현 도구, 빌드 도구, 테스트 도구, 형상관리 도구            요구사항 관리 도구                    요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 S/W           JIRA, IBM DOORS, inteGREAT, Reqtify, Trello 등                       설계/모델링 도구                    UML을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 S/W           DB Designer, PlantUML, ArgoUML                       구현 도구                    개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 S/W           Eclipse, IntelliJ IDEA, Visual Studio, Netbeans, Node.js 등                       빌드 도구                    구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 S/W           Ant, Graddle, Maven, Jenkins 등                       테스트 도구                    모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 S/W           CppUnit, JUnit, HttpUnit, NUnit, SpringTest 등                       형상 관리 도구                    산출물들을 버전별로 관리하여 품질 향상을 지원하는 S/W           GIT, CVS, Subversion, Mercurial                           - 개발 언어의 선정 기준      적정성, 효율성, 이식성, 친밀성, 범용성       2. 보안 및 API – B   - 소프트웨어 개발 보안의 개요      보안 취약점을 최소화하여 보안 위협으로부터 안전한 S/W를 개발하기 위한 일련의 보안 활동   S/W 개발 보안은 데이터의 기밀성, 무결성, 가용성을 유지하는 것을 목표로 함   S/W 개발 보안 가이드를 참고하여 점검해야 할 보안 항목들을 점검   - 소프트웨어 개발 보안 점검 항목      세션 통제            세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것       보안 약점에는 불충분한 세션 관리, 잘못된 세션에 의한 정보 노출 등           입력 데이터 검증 및 표현            입력 데이터에 대한 유효검 검증체계를 갖추고, 검증 실패 시 이를 처리할 수 있도록 코딩       보안 약점에는 SQL 삽입, 경로 조작 및 자원 삽입, 크로스사이트 스크립팅(XSS) 등           보안 기능            인증, 접근제어, 기밀성, 암호화 등의 기능을 의미       보안 약점에는 적절한 인증 없는 중요기능 허용, 부적절한 인가 등           시간 및 상태            다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원활히 동작되도록 코딩       보안 약점에는 검사 시점과 사용 시점(TOCTOU) 경쟁조건, 종료되지 않는 반복문 또는 재귀함수 등           에러처리            오류들을 사전에 정의하여 에러로 인해 발생할 수 있는 문제들을 예방       오류 메시지를 통한 정보 노출, 오류 상황 대응 부재 등           코드 오류            코딩 중 실수하기 쉬운 Type 변환, 자원의 반환 등을 고려하며 코딩       보안 약점에는 널 포인터 역참조, 부적절한 자원 해제 등           캡슐화            데이터와 데이터를 처리하는 함수를 하나의 객체로 묶어 코딩하는 것       보안 약점에는 잘못된 세션에 의한 데이터 정보 노출, 제거되지 않고 남은 디버그 코드 등           API 오용            API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 고려하여 코딩       보안 약점에는 DNS lookup에 의존한 보안결정, 취약한 API 사용           - API(Application Programming Interface)      운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스   프로그래밍 언어에서 특정한 작업을 수행하기 위해 사용   운영체제의 파일 제어, 화상 처리, 문자 제어 등의 기능을 활용하기 위해 사용   개발에 필요한 여러 도구를 제공. 원하는 기능을 쉽고 효율적으로 구현 가능   공개된 API를 Open API라고 함       3. 배치 프로그램 – B   - 배치 프로그램의 개요      사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리   정기 배치 : 정해진 기간에 정기적으로 수행   이벤트성 배치 : 조건이 충족될 때만 수행   On-Demand 배치 : 사용자 요청 시 수행   필수요소 : 대용량 데이터, 자동화, 견고성, 안정성/신뢰성, 성능   - 배치 스케줄러      일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구   특정 업무를 원하는 시간에 처리할 수 있도록 지원. 잡스케줄러라고도 함   스프링 배치            스프링이 가지고 있는 다양한 기능들을 모두 사용할 수 있음       DB나 파일의 데이터를 교환하는데 필요한 컴포넌트들을 제공       로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등       구성 요소와 역할                    Job : 수행할 작업 정의           Job Launcher : 실행을 위한 인터페이스           Step : Job 처리를 위한 제어 정보           Job Repository : Step의 제어 정보를 포함하여 작업 실행을 위한 모든 정보 저장                           Quartz            응용 프로그램들의 일괄 처리를 위한 다양한 기능 제공. 오픈 소스 라이브러리       요소들을 분리하여 일괄 처리 작업에 유연성 제공       구성 요소와 역할                    Scheduler : 실행 환경 관리           Job : 수행할 작업 정의           JobDetail : Job의 상세 정보           Trigger : Job의 실행 스케줄 정의                          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp15/",
        "teaser": null
      },{
        "title": "[Javascript] 자료형",
        "excerpt":"1. String   // 따옴표 사용 let myName = \"LWW\"; let email = \"plmplmdnjsdn@naver.com\"; let hello = `Hello ${myName}!`;  console.log(myName);  // LWW console.log(email);  // plmplmdnjsdn@naver.com console.log(hello);  // Hello LWW!       2. Number   // 정수 및 부동소수점 숫자를 나타냄 let number = 123; let opacity = 1.57;  console.log(number);  // 123 console.log(opacity);  // 1.57       3. Boolean   // true, false 두 가지 값밖에 없는 논리 데이터 let checked = true; let isShow = false;  console.log(checked);  // true console.log(isShow);  // false       4. Undefined   // 값이 할당되지 않은 상태를 나타냄 let undef; let obj = {abc: 123};  console.log(undef);  // undefined console.log(obj.abc);  // 123 console.log(obj.xyz);  // undefined       5. Null   // 어떤 값이 의도적으로 비어있음을 의미 let empty = null;  console.log(empty);  // null       6. Object   // 여러 데이터를 Key:Value 형태로 저장 { } let user = {   name: 'LWW',   age: 50,   isValid: true };  console.log(user.name);  // LWW console.log(user.age);  // 50 console.log(user.isValid);  // true       7. Array   // 여러 데이터를 순차적으로 저장 [ ] let animals = ['Cat', 'Dog', 'Tiger'];  console.log(animals[0]);  // 'Cat' console.log(animals[1]);  // 'Dog' console.log(animals[2]);  // 'Tiger'  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-datatype/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 4-2. 프로그래밍 언어 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 데이터 타입 – B      변수에 저장될 데이터의 형식   데이터 타입의 유형            Integer : 정수       Floating Poing : 소수점 이하가 있는 실수       Character : 한 문자. ‘ ‘안에 표시       String : 문자열. “ “안에 표시       Boolean : True or False. 기본값은 False       Array : 같은 타입의 데이터 집합. { }안에 ,로 구분           - C/C++의 데이터 타입 크기 및 기억 범위                  종류       데이터 타입       크기       기억 범위                       문자       char       1Byte       -128 ~ 127                 부호없는 문자       unsigned char       1Byte       0 ~ 2^8 - 1                 정수       short       2Byte       -2^15 ~ 2^15 - 1                 ”       int       4Byte       -2^31 ~ 2^31 - 1                 ”       long       4Byte       -2^31 ~ 2^31 - 1                 ”       long long       8Byte       -2^63 ~ 2^63 - 1                 부호없는 정수       unsigned short       2Byte       0 ~ 2^16 - 1                 ”       unsigned int       4Byte       0 ~ 2^32 - 1                 ”       unsigned long       4Byte       0 ~ 2^64 - 1                 실수       float       4Byte       1.2 * 10^-38 ~ 3.4 * 10^38                 ”       double       8Byte       2.2 * 10^-308 ~ 1.8 * 10^308                 ”       long double       8Byte       2.2 * 10^-308 ~ 1.8 * 10^308           - Java의 데이터 타입 크기 및 기억 범위                  종류       데이터 타입       크기       기억 범위                       문자       char       2Byte       0 ~ 2^16 - 1                 정수       byte       1Byte       -2^7 ~ 2^7 - 1                 ”       short       2Byte       -2^15 ~ 2^15 - 1                 ”       int       4Byte       -2^31 ~ 2~31 - 1                 ”       long       8Byte       -2^63 ~ 2^63 - 1                 실수       float       4Byte       1.4 * 10^-45 ~ 3.4 * 10^38                 ”       double       8Byte       4.9 * 10^-324 ~ 1.8 * 10^308                 논리       boolean       1Byte       true or false               2. 변수 – A   - 변수명 작성 규칙      영문자, 숫자, 언더바 사용 가능   첫 글자는 숫자 올 수 없음   글자 수 제한 없음   공백이나 특수문자 사용 불가   대소문자 구분   예약어를 변수명으로 사용할 수 없음   변수 선언 시 문장 끝에 반드시 ; 붙어야 함   - 기억 클래스      기억영역을 결정하는 작업                  종류       기억영역       예약어       생존기간       사용 범위                       자동 변수       메모리(스택)       auto       일시적       지역적                 레지스터 변수       레지스터       register       ”       ”                 정적 변수(내부)       메모리(데이터)       static       영구적       ”                 정적 변수(외부)       ”       ”       ”       전역적                 외부 변수       ”       extern       ”       ”              자동 변수            함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수       함수나 블록을 벗어나면 자동으로 소멸       초기화하지 않으면 쓰레기값이 저장됨           외부 변수            선언된 변수나 함수를 참조하기 위한 변수       함수 밖에서 선언       함수가 종료된 후에도 값이 소멸되지 않음       초기화되지 않으면 자동으로 0으로 초기화       다른 파일에서 선언된 변수를 참조할 경우 초기화 할 수 없음           정적 변수            함수나 블록 내에서 선언하는 내부 정적 변수, 함수 외부에서 선언하는 외부 정적 변수       내부 정적 변수는 함수나 블록 내에서만 사용, 외부 정적 변수는 모든 함수에서 사용       함수나 블록이 종료된 뒤에도 값이 소멸되지 않음       초기화는 변수 선언 시 한 번만 가능. 초기화를 생략하면 자동으로 0으로 초기화           레지스터 변수            메모리가 아닌 CPU 내부의 레지스터에 기억영역을 할당받는 변수       자주 사용하는 변수를 레지스터에 저장하여 처리 속도를 높이기 위해 사용       함수나 블록을 벗어나면 자동으로 소멸       데이터를 저장할 레지스터가 없는 경우 자동 변수로 취급되어 메모리에 할당       변수의 주소를 구하는 주소 연산자(&amp;)를 사용할 수 없음           - 변수의 선언      자료형 변수명 = 값;       3. 연산자 – A   - 산술 연산자      산술 계산에 사용되는 연산자   +, -, *, /, %, ++, –   ++, –            전치 : 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용       후치 : 변수를 연산에 사용한 후 변수의 값을 증감           - 관계 연산자      참, 거짓을 결과로 얻는 연산자   ==, !=, &gt;, &gt;=, &lt;, &lt;=   - 비트 연산자      비트별(0, 1)로 연산하여 결과를 얻는 연산자                                   &amp;, ^,           , ~, «, »                           - 논리 연산자      참, 거짓을 결과로 얻는 연산자                                   &amp;&amp;,                       , !                           - 대입 연산자      연산식을 간략하게 입력할 수 있음   산술, 관계, 비트, 논리 연산자에 모두 적용 가능   +=, -=, *=, /=, %=, «=, »=   - 조건 연산자      조건에 따라 서로 다른 수식을 수행   조건 ? 수식1 : 수식2 : 조건의 수식이 참이면 수식1, 거짓이면 수식2 실행   - 기타 연산자      sizeof : 자료형의 크기를 표시   ,(콤마) : 한 줄에 두 개 이상의 수식을 작성하거나 변수를 정의. 순서 연산자   (자료형) : 형 변환을 위해 사용. cast 연산자   - 연산자 우선순위                  대분류       중분류       연산자       결합규칙       우선 순위                       단항 연산자       단항 연산자       ! ~ ++ – sizeof       ←       1                 이항 연산자       산술 연산자       * / %       →       2                 ”       ”       + -       ”       3                 ”       시프트 연산자       « »       ”       4                 ”       관계 연산자       &lt; &lt;= &gt;= &gt;       ”       5                 ”       ”       == !=       ”       6                 ”       비트 연산자       &amp;       ”       7                 ”       ”       ^       ”       ”                 ”       ”       비트 or       ”       ”                 ”       논리 연산자       &amp;&amp;       ”       8                 ”       ”       논리 or       ”       ”                 삼항 연산자       조건 연산자       ? :       →       9                 대입 연산자       대입 연산자       = += -= *= /= %= «= »= 등       ←       10                 순서 연산자       순서 연산자       ,       →       11               4. 제어문 – A   - 단순 if 문      조건이 한 개 일 때 사용   // 조건이 참일 때만 실행 if (조건)   실행할 문장1;   실행할 문장2;   // 조건이 참일 떄와 거짓 때 실행할 문장이 다름 if (조건)   실행할 문장1; else   실행할 문장2;       - 다중 if 문   // else if if (조건1)   실행할 문장1; else if (조건2)   실행할 문장2; else if (조건3)   실행할 문장3; else   실행할 문장4;   // 중첩 if문 if (조건1)   {     if (조건2)       실행할 문장1;     else       실행할 문장2   } else   실행할 문장3;       - switch문      조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리   switch (수식) {   case 레이블1:     실행할 문장1;     break;   case 레이블2:     실행할 문장2;     break;   default:     실행할 문장3; }       - goto문      현재 위치에서 원하는 다른 문장으로 건너뛰어 수행을 계속하기 위해 사용   많이 사용하면 프로그램의 이해와 유지 보수가 어려워져 거의 사용하지 않음   goto 레이블; 레이블:   실행할 문장       5. 반복문 – A   - for문      초기값, 최종값, 증가값을 지정하는 수식을 이용해 정해진 횟수를 반복   for(식1; 식2; 식3)   실행할 문장;       - while 문      조건이 참인 동안 실행할 문장을 반복   while(조건)   실행할 문장;       - do ~ while문      실행할 문장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여부를 결정   do   실행할 문장; while(조건);       - break, continue      break : switch문이나 반복문 안에서 break가 나오면 블록을 벗어남   continue : continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮김. 반복문에서만 사용       6. 배열과 문자열 – A   - 배열의 개념      개별적인 요소들의 위치는 첨자를 이용하여 지정   변수명 뒤에 []를 붙이고 그 안에 사용할 개수 지정   배열의 위치는 0부터 시작   행 우선으로 데이터가 기억장소에 할당   첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같음   - 1차원 배열   자료형 변수명[개수];       - 2차원 배열   자료형 변수명[행개수][열개수]       - 배열의 초기화      배열 선언 시 초기값을 지정할 수 있음   배열 선언 시 배열의 크기를 생략하는 경우, 반드시 초기값을 지정해야 함   - 배열 형태의 문자열 변수      C에서 “ “로 묶인 글자는 글자 수에 관계없이 문자열로 처리   C에는 문자열을 저장하는 자료형이 없기 때문에 배열, 포인터를 이용하여 처리   배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 널 문자(‘\\0’)가 자동으로 삽입   배열에 문자열을 저장할 때는 배열 선언 시 초기값으로 지정. 선언된 배열에는 문자열 저장 불가   널 문자를 고려하여 배열 크기를 지정해야 함   char 배열이름[크기] = \"문자열\"      Java에는 주소를 컨트롤하는 기능이 없음   하지만 Java는 문자열을 처리할 수 있도록 클래스를 제공       7. 포인터 – A   - 포인터와 포인터 변수      포인터는 변수의 주소를 말함. C에서는 주소를 제어할 수 있는 기능을 제공   변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라 함   포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 * 를 붙임(int *a;)   포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 &amp; 를 붙임(a = &amp;b;)   실행문에서 포인터에 * 를 붙이면 해당 포인터 변수가 가리키는 곳의 값임(c = *a;)   포인터 변수는 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수   포인터 변수의 용도            연결된 자료 구조를 구성하기 위해 사용       동적으로 할당된 자료 구조를 지정하기 위해 사용       배열을 인수로 전달하기 위해 사용       문자열을 표현하기 위해 사용       요소를 효율적으로 저장하기 위해 사용       메모리에 직접 접근하기 위해 사용           - 포인터와 배열      배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근 가능   첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것   배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 &amp; 연산자 사용   배열의 요소가 포인터인 포인터형 배열을 선언할 수 있음   int a[5], *b;       8. 데이터 입출력 – A   - C언어의 표준 입출력 함수의 개요      키보드로 입력받아 화면으로 출력할 때 사용하는 함수   - scanf() 함수      표준 입력함수. 키보드로 입력받아 변수에 저장   // 형식 scanf(서식 문자열, 변수의 주소)  // % : 서식 문자임을 지정 // 3 : 입력 자릿수를 3자리로 지정 // d : 10진수로 입력 // &amp;a : 입력받은 데이터를 변수 a의 주소에 저장 scanf(\"%3d\", &amp;a);      특징            입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있음       여러 개의 데이터를 입력 받을 수 있음       서식 문자열과 변수의 자료형은 일치해야 함           서식 문자열            %d : 정수형 10진수를 입출력       %u : 부호없는 정수형 10진수를 입출력       %o : 정수형 8진수를 입출력       %x : 정수형 16진수를 입출력       %c : 문자를 입출력       %s : 문자열을 입출력       %f : 소수점을 포함하는 실수를 입출력       %e : 지수형 실수를 입출력       %ld : long형 10진수를 입출력       %lo : long형 8진수를 입출력       %lx : long형 16진수를 입출력       %p : 주소를 16진수로 입출력           - Java에서의 표준 입력      Scanner 클래스를 이용해 키보드로부터 값을 입력받는 객체 변수를 생성한 후 사용   // 형식 Scanner scan = new Scanner(System.in); a = scan.nextInt();      객체 변수 생성            Scanner : 입력에 사용할 객체 변수를 생성할 때 사용       scan : 객체 변수명       new : 객체 생성 예약어       Scanner() : 클래스 이름       System.in : 표준 입력장치. 즉 키보드           객체 변수 활용            a : 입력받은 값을 저장할 변수       scan.nextInt()                    scan : 입력에 사용할 객체 변수 이름           nextInt() : 입력받은 값을 정수형으로 반환                           - printf() 함수      C언어의 표준 출력 함수. 인수로 주어진 값을 화면에 출력   // 형식 printf(서식 문자열, 변수)  // % : 서식 문자임을 지정 // - : 왼쪽부터 출력 // 8 : 출력 자리수를 8자리로 지정 // 2 : 소수점 이하를 2자리로 지정 // f : 실수로 출력 printf(\"%-8.2f\", 200.2) // 200.20VV (V는 빈칸을 의미)      주요 제어 문자            \\n : 커서를 다음 줄 앞으로 이동       \\b : 커서를 왼쪽으로 한 칸 이동       \\t : 커서를 일정 간격 띄움       \\r : 커서를 현재 줄의 처음으로 이동       \\0 : 널 문자를 출력       ' : 작은따옴표 출력       \" : 큰따옴표 출력       \\a : 스피커로 벨 소리를 출력       \\ : 역 슬래시를 출력       \\f : 한 페이지를 넘김           - Java에서의 표준 출력      Java에서 값을 화면에 출력할 때는 printf() 메소드 이용   // 형식 System.out.printf(서식 문자열, 변수)      System 클래스의 서브 클래스인 out 클래스의 메소드 printf()를 사용하여 출력   - 기타 표준 입출력 함수      입력            getchar() : 한 문자를 입력받아 변수에 저장       gets() : 문자열을 입력받아 변수로 저장. enter를 누르기 전까지를 하나의 문자열로 인식           출력            putchar() : 한 문자를 화면에 출력       puts() : 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp16/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 4-3. 응용 SW 기초 기술 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 운영체제의 개념 – A   - 운영체제(OS; Operating System)의 정의      시스템의 자원을 효율적으로 관리   컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공   사용자와 하드웨어 간의 인터페이스로서 동작하는 시스템 S/W   응용 프로그램이 유용한 작업을 할 수 있도록 환경 제공   - 운영체제의 목적      처리 능력 : 일정 시간 내에 시스템이 처리하는 일의 양   반환 시간 : 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간   사용 가능도 : 즉시 사용 가능한 정도   신뢰도 : 문제를 정확하게 해결하는 정도   - 운영체제의 기능      프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원 관리   자원의 스케줄링 기능 제공   편리한 인터페이스 제공   각종 하드웨어와 네트워크를 관리 및 제어   데이터를 관리하고 데이터 및 자원의 공유 기능 제공   시스템의 오류를 검사하고 복구   자원 보호 기능 제공   입출력에 대한 보조 기능 제공   가상 계산기 기능 제공   - 운영체제의 주요 자원 관리      프로세스 관리 : 스케줄링 및 동기화 관리, 생성과 제거, 시작과 정지, 메시지 전달   기억장치 관리 : 프로세스에게 메모리 할당 및 회수 관리   주변장치 관리 : 입출력장치 스케줄링 및 전반적인 관리   파일 관리 : 파일의 생성과 삭제, 변경, 유지 등의 관리   - 운영체제의 종류      Windows : MS사 개발. GUI   UNIX : AT&amp;T 벨 연구소, MIT, General Electric 공동 개발. CLI   LINUX : UNIX와 호환이 가능한 커널. 누구나 제한 없이 활용 및 재배포 가능. CLI   MacOS : 애플사가 UNIX를 기반으로 개발. GUI   MS-DOS : Windows 이전에 사용되던 운영체제. CLI   단일 작업 처리 시스템에는 MS-DOS   다중 작업 처리 시스템에는 Windows, UNIX, LINUX, MacOS 등   개인용 운영체제는 Windows, MacOS, MS-DOS   서버용 운영체제는 UNIX, LINUX       2. Windows – C      GUI   선점형 멀티태스킹   PnP(Plug and Play, 자동 감지 기능)   OLE   255자의 긴 파일명   Single-User 시스템       3. UNIX/LINUX/MacOS – A   - UNIX의 개요 및 특징      대화식 운영체제. 소스가 공개된 개방형 시스템   C언어로 작성되어 이식성이 높으며 장치, 프로세스 간의 호환성이 높음   크기가 작고 이해하기 쉬움   Multi-User, Multi-Tasking 지원   많은 네트워킹 기능을 제공하므로 통신망 관리용 운영체제로 적합   트리 구조의 파일 시스템   전문적인 프로그램 개발에 용이   다양한 유틸리티 프로그램 존재   - UNIX 시스템의 구성      커널            컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하며 실행       하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할       프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환           쉘            명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기       시스템과 사용자 간의 인터페이스 역할       DOS의 COMMAND.COM과 같은 기능       주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재       보조 기억장치에서 교체 처리 가능       파이프라인 기능을 지원하고 입출력 재지정을 통해 출력과 입력의 방향을 변경 가능       공용 쉘이나 사용자 자신이 만든 쉘을 사용할 수 있음           Utility Program            일반 사용자가 작성한 응용 프로그램을 처리       DOS에서의 외부 명령어에 해당       에디터, 컴파일러, 인터프리터, 디버거 등           - UNIX에서의 프로세스 간 통신      각 프로세스는 시스템 호출을 통해 커널의 기능을 사용   시그널, 파이프, 소켓 등을 사용   시그널 : 간단한 메시지를 이용하여 통신. 초기 UNIX 시스템에서 사용됨   파이프 : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식   소켓 : 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식   - LINUX의 개요 및 특징      UNIX를 기반으로 개발   프로그램 소스 코드가 무료로 공개되어 원하는 기능을 추가할 수 있음   다양한 플랫폼에 설치하여 사용 가능. 재배포 가능   UNIX와 완벽하게 호환   대부분의 특지잉 UNIX와 동일   - MacOS의 개요 및 특징      애플사가 UNIX를 기반으로 개발   애플 사에서 생산하는 제품에서만 사용 가능   드라이버 설치 및 install과 uninstall의 과정이 단순       4. 기억장치 관리의 개요 – A   - 기억장치 계층 구조의 특징      레지스터 - 캐시 기억장치 - 주기억장치 - 보조기억장치   상위의 기억장치일수록 접근 속도와 접근 시간이 빠르지만, 기억 용량이 적고 고가   주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성. 주소를 이용한 액세스 가능   레지스터, 캐시 기억장치, 주기억장치의 프로그램과 데이터는 CPU가 직접 액세스 할 수 있음   보조기억장치에 있는 프로그램이나 데이터는 CPU가 직접 액세스 할 수 없음   보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스 될 수 있음   - 기억장치 관리 전략의 개요      보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치등을 지정   한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것   @ 반입(Fetch) 전략      보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정   요구반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재   예상반입 : 참조될 프ㅗ그램이나 데이터를 미리 예상하여 적재   @ 배치(Placement) 전략      새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정   최초 적합 : 빈 영역 중에서 첫 번째 분할 영역에 배치   최적 적합 : 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치   최악 적합 : 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치   @ 교체(Replacement) 전략      모든 영역이 이미 사용중인 상태에서, 어느 영역을 교체하여 사용할 것인지를 결정   FIFO, OPT, LRU, LFU, NUR, SCR 등       5. 가상기억장치 구현 기법 / 페이지 교체 알고리즘 – A   - 가상기억장치의 개요      보조기억장치의 일부를 주기억장치처럼 사용하는 것   프로그램을 여러 개의 작은 블록 단위로 나누어서 가상 기억장치에 보관   프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리   주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용   주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음   가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환작업이 필요   연속 할당 방식에서 발생할 수 있는 단편화를 해결   블록의 종류에 따라 페이징 기법과 세그멘테이션 기법으로 나눔   - 페이징(Paging) 기법      가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눔   나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행   프로그램을 일정한 크기로 나눈 단위를 Page라고 함   Page 크기로 일정하게 나누어진 주기억장치의 단위를 Page Frame이라고 함   외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음   주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 Page Map Table이 필요   Page Map Table 사용으로 비용이 증가되고, 처리 속도가 감소   - 세그멘테이션(Segmentation) 기법      가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적 단위로 나눈 후 주기억장치에 적재시켜 실행   프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 Segment라고 함   각 Segment는 고유한 이름과 크기를 가짐   기억장치의 사용자 관점을 보존하는 기억장치 관리 기법   기억공간을 절약하기 위함   주소 변환을 위해서 Segment가 존재하는 위치 정보를 가지고 있는 Segment Map Table 필요   Segment가 주기억장치에 적재될 때 다른 Segment에게 할당된 영역을 침범할 수 없음. 기억장치 보호키 필요   내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있음   - 페이지 교체 알고리즘      페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정   @ OPT(최적 교체)      앞으로 가장 오랫동안 사용하지 않을 페이지를 교체   페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘   @ FIFO      가장 먼저 들어와서 가장 오래 있었던 페이지를 교체   이해하기 쉽고, 프로그래밍 및 설계가 간단   @ LRU(Least Recently Used)      최근에 가장 오랫동안 사용하지 않은 페이지를 교체   각 페이지마다 계수기나 스택을 두어 현 시점에서 가장 오랫동안 사용하지 않은 페이지 교체   @ LFU(Least Frequently Used)      사용 빈도가 가장 적은 페이지를 교체   @ NUR(Not Used Recently)      최근에 사용하지 않은 페이지를 교체   LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음   각 페이지마다 참조 비트와 변형 비트를 사용   @ SCR(Second Chance Replacement, 2차 기회 교체)      가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위함   FIFO기법의 단점을 보완       6. 가상기억장치 기타 관리 사항 – A   - 페이지 크기      페이지 크기가 작을 경우            페이지 단편화가 감소, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬       효율적인 워킹 셋을 유지       기억장치 효율이 높아짐       Page Map Table의 크기가 커지고, Mapping 속도가 늦어짐       전체적인 입출력 시간은 늘어남           페이지 크기가 클 경우            페이지 단편화가 증가, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남       불필요한 내용까지도 주기억장치에 적재       Page Map Table의 크기가 작아지고, Mapping 속도가 빨라짐       전체적인 이불력의 효율성 증가           - Locality      프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질   스래싱을 방지하기 위한 워킹 셋 이론의 기반   프로세스가 집중적으로 사용하는 페이지를 알아내는 방법. 가상기억장치 관리의 이론적 근거   Denning에 의해 구역성의 개념이 증명. 캐시 메모리 시스템의 이론적 근거   시간 구역성            하나의 페이지를 일정 시간 동안 집중적으로 액세스 하는 현상       참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음       Loop, Stack, Sub Routine, Counting, Totaling에 사용되는 변수           공간 구역성            일정 위치의 페이지를 집중적으로 액세스 하는 현상       참조한 페이지 근처의 페이지를 계속 참조할 가능성이 높음       배열 순회, 순차적 코드의 실행, 관련된 변수를 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때           - 워킹 셋(Working Set)      프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합   프로그램의 Locality 특징을 이용   자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정됨   자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경됨   - 페이지 부재 빈도 방식      페이지 부재는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상   페이지 부재 빈도는 페이지 부재가 일어나는 횟수   페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식   운영체제는 임의의 페이지 프레임을 할당하고, 부재율이 상한선을 넘어가면 좀더 많은 페이지 프레임을 할당하고, 부재율이 하한선을 넘어가면 페이지 프레임을 회수   - 프리페이징(Prepaging)      처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 한번에 페이지 프레임에 적재   사용되지 않는 페이지가 많을 수도 있음   - 스래싱(Thrashing)      프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상   자주 페이지 부재가 발생함으로써 나타나는 현상. 시스템의 성능이 저하됨   다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 특정 시점까지는 높아짐   정도가 더욱 커지면 스래싱이 나타나고, CPU 이용률은 급격히 감소   스래싱 현상 방지 방법            다중 프로그래밍의 정도를 적정 수준으로 유지       페이지 부재 빈도를 조절하여 사용       워킹 셋을 유지       부족한 자원을 증설하고, 일부 프로세스를 중단시킴       CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영               7. 프로세스의 개요 – A   - 프로세스의 정의      프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 실행중인 프로그램   작업, 태스크라고도 함   PCB를 가진 프로그램   실기억장치에 저장된 프로그램   프로세서가 할당되는 실체. 디스패치가 가능한 단위   프로시저가 활동중인 것   비동기적 행위를 일으키는 주체   지정된 결과를 얻기 위한 일련의 계통적 동작   목적 또는 결과에 따라 발생되는 사건들의 과정   운영체제가 관리하는 실행 단위   - PCB(Process Control Block, 프로세스 제어 블록)      운영체제가 프로세스에 대한 정요한 정보를 저장해 놓는 곳   각 프로세스가 생성될 때마다 고유의 PCB가 생성. 프로세스가 완료되면 PCB 제거   PCB에 저장된 정보            프로세스의 현재 상태       포인터       프로세스 고유 식별자       스케줄링 및 프로세스의 우선순위       CPU 레지스터 정보       주기억장치 관리 정보       입출력 상태 정보       계정 정보           - 프로세스 상태 전이      프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것   제출(Submit)            작업을 시스템에 제출한 상태           접수(Hold)            제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태           준비(Ready)            프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태       프로세스는 준비상태 큐에서 실행을 준비       접수 상태에서 준비 상태로의 전이는 Job 스케줄러에 의해 수행           실행(Run)            준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태       할당 시간이 종료되면 프로세스는 준비 상태로 전이       입출력 처리가 필요하면 실행중인 프로세스는 대기 상태로 전이       준비 상태에서 실행 상태로의 전이는 CPU 스케줄러에 의해 수행           종료(Terminated, Exit)            프로세스의 실행으 끝나고 프로세스 할당이 해제된 상태           - 프로세스 상태 전이 관련 용어      Dispatch : 준비 상태에서 대기하고 이쓴 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이   Wake Up : 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이   Spooling : 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입출력 데이터를 직접 입출력 장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장   교통량 제어기(Traffic Controller) : 프로세스의 상태에 대한 조사와 통보 담당   - 스레드(Thread)      프로세스 내에서의 작업 단위. 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위   하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드   하나 이상의 스레드가 존재하는 경우에는 다중 스레드   프로세스의 일부 특성을 갖고 있어 경량 프로세스라고도 함   스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할 담당   동일 프로세스 환경에서 서로 독립적인 다중 수행 가능   분류            사용자 수준의 스레드                    사용자가 만든 라이브러리를 사용하여 스레드 운용           속도는 빠르지만 구현이 어려움                       커널 수준의 스레드                    운영체제의 커널에 의해 스레드를 운용           구현이 쉽지만 속도가 느림                           스레드 사용의 장점            하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진       하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상       응용 프로그램의 응답 시간을 단축       실행 환경을 공유시켜 기억장소의 낭비가 줄어듬       프로세스들 간의 통신 향상       공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신함               8. 스케줄링 – B   - 스케줄링의 개요      시스템의 여러 자원을 해당 프로세스에게 할당하는 작업   장기 스케줄링            어떤 프로세스가 시스템의 자원을 차지하게 할 것인가 결정하여 준비상태 큐로 보내는 작업       작업 스케줄링, 상위 스케줄링이라고도 함. 작업 스케줄러에 의해 수행           중기 스케줄링            어떤 프로세스들이 CPU를 할당받을 것인지를 결정하는 작업       할당받으려는 프로세스가 많으면 일시 보류시킨 후 활성화해서 일시적으로 부하 조절           단기 스케줄링            프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업       프로세서 스케줄링, 하위 스케줄링이라고도 함       프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행됨           - 스케줄링의 목적      CPU나 자원을 효율적으로 사용하기 위한 정책   공정성   처리율 증가   CPU 이용률 증가   우선순위 제도   오버헤드 최소화   응답 시간 최소화   반환 시간 최소화   대기 시간 최소화   균형 있는 자원의 사용   무한 연기 회피   - 프로세스 스케줄링의 기법      비선점(Non-Preemptive) 스케줄링            할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 기법       할당되면 해당 프로세스가 완료될 때까지 CPU 사용       모든 프로세스에 대한 요구를 공정하게 처리 가능       응답 시간의 예측이 용이. 일괄 처리 방식에 적합       중요한 작업이 중요하지 않은 작업을 기다리는 경우 발생 가능       FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘 존재           선점(Preemptive) 스케줄링            할당된 CPU를 우선순위가 높은 다른 프로세스가 강제로 빼앗아 사용할 수 있는 기법       우선순위가 높은 프로세스를 빠르게 처리 가능       빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용       많은 오버헤드를 초래       선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요       Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘 존재               9. 운영체제 기본 명령어 – B   - 운영체제 기본 명령어의 개요      CLI : 키보드로 명령어를 직접 입력하여 작업   GUI : 마우스로 아이콘이나 메뉴를 선택하여 작업   - Windows 기본 명령어      CLI 기본 명령어            DIR : 파일 목록 표시       COPY : 파일 복사       TYPE : 파일 내용 표시       REN : 파일 이름 변경       DEL : 파일 삭제       MD : 디렉터리 생성       CD : 디렉터리 위치 변경       CLS : 화면 내용 지움       ATTRIB : 파일 속성 변경       FIND : 파일 찾음       CHKDSK : 디스크 상태 점검       FORMAT : 디스크 표면을 트랙과 섹터로 나누어 초기화       MOVE : 파일 이동           GUI 기본 명령어            마우스로 작업           - UNIX/LINUX 기본 명령어      CLI 기본 명령어            cat : 파일 내용 표시       chdir : 디렉터리 위치 변경       chmod : 파일의 보호모드를 설정하여 파일의 사용 허가를 지정       chown : 소유자 변경       cp : 파일 복사       exec : 새로운 프로세스 수행       find : 파일 참음       fork : 새로운 프로세스를 생성       fsck : 파일 시스템을 검사하고 보수       getpid : 자신의 프로세스 아이디를 얻음       getppid : 부모 프로세스 아이디를 얻음       ls : 디렉터리 내의 파일 목록 확인       mount/unmount : 파일 시스템을 마운팅/마운팅 해제       rm : 파일 삭제       wait : fork후 exec에 의해 실행되는 하위 프로세스 종료 등의 event를 기다림           GUI 기본 명령어            X Window라는 별도의 프로그램을 설치하여 운영 가능               10. 인터넷 – A   - 인터넷의 개요      TCP/IP 프로토콜을 기반으로 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망   미 국방성의 ARPANET에서 시작됨   UNIX 운영체제를 기반으로 함   시간과 장소에 구애받지 않고 정보 교환 가능   모든 컴퓨터는 고유한 IP 주소를 가짐   컴퓨터 또는 네트워크를 서로 연결하기 위해 브리지, 라우더, 게이트웨이가 사용됨   중추적 역할을 하는 네트워크. 인터넷의 주가 되는 기간망을 Backbone라고 함   - IP 주소(Internet Protocol Address)      인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소   8비트씩 4부분, 총 32비트로 구성   네트워크 부분의 길이에 따라 5단계로 구성   A Class : 국가나 대형 통신망에 사용(0~127). 2^24개의 호스트 사용 가능   B Class : 중대형 통신망에 사용(128~191). 2^16개의 호스트 사용 가능   C Class : 소규모 통신망에 사용(192~223). 2^8개의 호스트 사용 가능   D Class : 멀티캐스트 용으로 사용(224~239)   E Class : 실험적 주소이며 공용되지 않음   - 서브네팅(Subnetting)      할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것   4Byte의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용   - IPv6의 개요      현재 사용하고 있는 IPv4의 주소 부족 문제를 해결하기 위해 개발   128비트의 긴 주소 사용. 자료 전송 속도가 빠름   인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결   IPv4와 호환성이 뛰어남   주소의 확장성, 융통성, 연동성이 뛰어남. 실시간 흐름 제어로 향상된 멀티미디어 기능 지원   Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장 용이   - IPv6 구성      16비트씩 8부분, 총 128비트   각 부분을 16진수로 표현하고 : 으로 구분   유니캐스트 : 1:1 통신에 사용   멀티캐스트 : 1:다 통신에 사용   애니캐스트 : 가장 가까이 있는 단일 수산자 간의 통신. 1:1 통신에 사용   - 도메인 네임      숫자로 된 IP주소를 사람이 이해하기 쉬운 문자 형태로 표현   호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관 종류, 국가명 순으로 구성   왼쪽에서 오른쪽으로 갈수록 상위 도메인 의미   문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP주소로 변환하는 시스템을 DNS라 함   이 역할을 하는 서버를 DNS 서버라고 함       11. OSI 참조 모델 – A   - OSI 참조 모델의 개요      다른 시스템 간의 원활한 통신을 위해 ISO에서 제안한 통신 규약   7단계로 표준화하여 규정   1~3 계층을 하위 계층, 4~7 계층을 상위 계층   하위 계층 : 물리 -&gt; 데이터 링크 -&gt; 네트워크   상위 게층 : 전송 -&gt; 세션 -&gt; 표현 -&gt; 응용   - OSI 참조 모델의 목적      서로 다른 시스템 간을 상호 접속하기 위한 개념을 규정   OSI 규격을 개발하기 위한 범위를 정함   관련 규정의 적합성을 조절하기 위한 공통적 기반 제공   - OSI 참조 모델에서의 데이터 단위      프로토콜 데이터 단위(PDU; Protocol Data Unit)            동일 계층 간에 교환되는 정보의 단위       물리 : 비트       데이터 링크 : 프레임       네트워크 : 패킷       전송 : 세그먼트       세션, 표현, 응용 : 메시지           서비스 데이터 단위(SDU; Service Data Unit)            서비스 접근점(SAP)을 통해 상하위 계층끼리 주고받는 정보의 단위           - 물리 계층(Physical Layer)      전송에 필요한 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙 정의   물리적 전송 매체와 전송 신호 방식을 정의   RS-232C, X.21 등의 표준   관련 장비 : 리피터, 허브   - 데이터 링크 계층(Data Link Layer)      인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 함   송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능   프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능   오류의 검출과 회복을 위한 오류 제어 기능   프레임의 순서적 전송을 위한 순서 제어 기능   HDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준   관련 장비 : 랜카드, 브리지, 스위치   - 네트워크 계층(Network Layer, 망 계층)      개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능   네트워크 연결을 설정, 유지, 해제하는 기능   경로 설정, 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송 수행   X.25, IP 등의 표준   관련 장비 : 라우터   - 전송 계층(Transport Layer)      논리적 안정과 균일한 데이터 전송 서비스 제공. 종단 시스템 간에 투명한 테이터 전송 가능   하위 3계층과 상위 3계층의 인터페이스 담당   종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능   주소 설정, 다중화, 오류 제어, 흐름 제어 수행   TCP, UDP 등의 표준   관련 장비 : 게이트웨이   - 세션 계층(Session Layer)      송수신 측 간의 관련성을 유지하고 대화 제어를 담당   대화 구성 및 동기 제어, 데이터 교환 관리 기능   전송하는 정보의 일정한 부분에 체크점을 두어 정보의 수신 상태 체크. 체크점을 동기점이라고 함   동기점은 오류가 있는 데이터의 회복을 위해 사용   - 표현 계층(Presentation Layer)      응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환   세션 계층에서 받은 데이터는 응용 계층에 맞게 변환   서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요   코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥 관리 기능   - 응용 계층(Application Layer)      사용자가 OSI 환경에 접근할 수 있도록 서비스 제공   응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스 제공       12. 네트워크 관련 장비 – B   - 네트워크 인터페이스 카드(NIC)      컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치   정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경   이더넷 카드(LAN 카드) 혹은 네트워크 어댑터라고도 함   - 허브(Hub)      한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치   각 회선을 통합적으로 관리. 신호 증폭 기능을 하는 리피터의 역할도 포함   더미 허브            네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만을 제공       LAN이 보유한 대역폭을 컴퓨터 수만큼 나누어 제공       네트워크에 연결된 각 노드를 물리적인 성형 구조로 연결           스위칭 허브            네트워크상에 흐르는 데이터의 유무 및 흐름을 제어       각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브       최근에 사용되는 허브는 대부분 스위칭 허브           - 리피터(Repeater)      전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할   OSI 참조 모델의 물리 계층에서 동작하는 장비   근접한 네트워크 사이에 신호를 전송하는 역할   전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도   - 브리지(Bridge)      LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연결하는 기능   데이터 링크 계층 중 MAC(Media Access Control) 계층에서 사용됨   트래픽 병목 현상을 줄일 수 있음   네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있음   브리지를 이용한 서브넷 구성 시 전송 가능한 회선 수는 브리지가 n개일 때 n(n-1)/2개   - 스위지(Switch)      LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치   하드웨어를 기반으로 처리하므로 전송 속도가 빠름   포트마다 각기 다른 전송 속도를 지원하도록 제어 가능. 수십에서 수백 개의 포트 제공   OSI 참조 모델의 데이터 링크 계층에서 사용   - 라우터(Router)      LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능 추가.   LAN과 WAN의 연결도 수행   OSI 참조 모델의 네트워크 계층에서 동작하는 장비   접속 가능한 경로에 대한 정보를 라우팅 제어표에 저장하여 보관   프로토콜 변환 기능 수행   - 게이트웨이(Gateway)      전 계층의 프로토콜 구조가 다른 네트워크의 연결을 수행   데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행   LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할   - 네트워크 장비 설치 시 고려 사항      네트워크에 설치된 장비를 최대한 활용   시스템 확장이나 증설 등을 고려하여 설계   최신 버전을 선정   트래픽을 분산시킬 수 있도록 설계   관리나 유지 보수가 용이하게 설계   장애 발생 시 즉시 조치할 수 있도록 여유 포트를 고려하여 설계   신기술 도입 시 연동할 수 있는 미래 지향적인 네트워크 시스템 구축       13. 프로토콜의 개념 – B   - 프로토콜의 정의      서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화한 통신 규약   하드웨어와 소프트웨어, 문서를 모두 규정   - 프로토콜의 기본 요소      구문(Syntax) : 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정   의미(Semantics) : 협조 사항과 오류 관리를 위한 제어 정보 규정   시간(Timing) : 두 기기 간의 통신 속도, 메시지의 순서 제어 등 규정   - 프로토콜의 기능      단편화와 재결합            송싱 측에서 전송할 데이터를 전송에 알맞은 크기의 작은 블록으로 자르는 작업을 단편화       수신 측에서 단편화된 블록을 원래의 데이터로 모으는 것을 재결합       단편화된 데이터 블록을 프로토콜 데이터 단위(PDU)라고 함       단편화하여 전송하면 전송 시간이 빠르고, 통신중의 오류를 효과적으로 제어 가능       너무 작게 단편화할 경우 재결합 시 처리 시간이 길어지고, 부수적인 데이터가 많아져 비효율적           캡슐화            단편화된 데이터에 송수신지 주소, 오류 검출 코드, 프로토콜 기능을 구현하기 위한 프로토콜 제어 정보 등의 정보를 부가하는 것으로 요약화라고도 함       데이터 링크 제어 프로토콜의 HDLC 프레임       정보 데이터를 오류 없이 정확하게 전송하기 위해 캡슐화 수행           흐름 제어            수신 측의 처리 능력에 따라 송신 측에서 송신하는 데이터의 전송량, 속도를 조절하는 기능       정지-대기, 슬라이딩 윈도우 방식을 이용           오류 제어            전송중에 발생하는 오류를 검출하고 정정하여 데이터나 제어 정보의 파손에 대비하는 기능           동기화            송수신 측이 같은 상태를 유지하도록 타이밍을 맞추는 기능           순서 제어            전송되는 PDU에 전송 순서를 부여하는 기능       연결 위주의 데이터 전송 방식에만 사용       데이터들이 순서적으로 전송되도록 하여 흐름 제어 및 오류 제어를 용이하게 함           주소 지정            데이터가 목적지까지 정확하게 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능           다중화            한 개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능           경로 제어            송수신 측 간의 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능           전송 서비스            우선순위 : 우선순위를 부여하여 우선순위가 높은 메시지가 먼저 도착하도록 함       서비스 등급 : 서비스 등급을 부여하여 서비스       보안성 : 액세스 제한과 같은 보안 체제를 구현               14. TCP/IP – A   - TCP/IP의 개요      인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜   ARPANET에서 사용하기 시작   UNIX의 기본 프로토콜로 사용. 현재 인터넷 범용 프로토콜로 사용   TCP 프로토콜 + IP 프로토콜   TCP            전송 계층       신뢰성 있는 연결형 서비스 제공       패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능 제공       스트림 전송 기능 제공           IP            네트워크 계층       데이터그램을 기반으로 하는 비연결형 서비스 제공       패킷의 분해/조립, 주소 지정, 경로 선택 기능 제공       헤더의 길이는 최소 20Byte에서 최대 60Byte           - TCP/IP의 구조                  OSI       TCP/IP       기능                 응용, 표현, 세션       응용       응용 프로그램 간 데이터 송수신                 전송       전송       호스트들 간의 신뢰성 있는 통신                 네트워크       인터넷       데이터 전송을 위한 주소 지정, 경로 설정                 데이터 링크, 물리       네트워크 액세스       실제 데이터(프레임)를 송수신           - 응용 계층의 주요 프로토콜      FTP            파일을 주고받을 수 있도록하는 원격 파일 전송 프로토콜           SMTP            전자 우편을 교환하는 서비스           TELNET            멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용       시스템 관리 작업을 할 수 있는 가상의 터미널 기능을 수행           SNMP            TCP/IP의 네트워크 관리 프로토콜       네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용           DNS            도메인 네임을 IP 주소로 Mapping하는 시스템           HTTP            WWW에서 HTML 문서를 송수신 하기 위한 표준 프로토콜           - 전송 계층의 주요 프로토콜      TCP            양방향 연결형 서비스 제공       가상 회선 연결 형태의 서비스 제공       스트림 위주의 전달(패킷 단위)       신뢰성 있는 경로를 확립하고 메시지 전송 감독       순서 제어, 오류 제어, 흐름 제어       패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할 때 투명성 보장하는 통신 제공           UDP            비연결형 서비스 제공       상대적으로 단순한 헤더 구조를 가져 오버헤드가 적음       빠른 속도, 동시에 여러 사용자에게 데이터 전달, 반복해서 전송할 경우 사용       실시간 전송에 유리       신뢰성보다는 속도가 중요시되는 네트워크에 사용 -RTCP       RTP 패킷의 전송 품질을 제어하기 위한 제어 프로토콜       세션에 참여한 각 참여자들에게 주기적으로 제어 정보 전송       하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화 제공       데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공       RTCP 패킷은 항상 32비트의 경계로 끝남           - 인터넷 계층의 주요 프로토콜      IP            전송할 데이터에 주소를 지정하고 경로를 설정하는 기능       비연결형인 데이터그램 방식을 사용       신뢰성이 보장되지 않음           ICMP            IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리       헤더는 8Byte           IGMP            멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용           ARP            호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC 주소)로 바꿈           RARP            ARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능           - 네트워크 액세스 계층의 주요 프로토콜      Ethernet(IEEE 802.3)            CSMA/CD 방식의 LAN           IEEE 802            LAN을 위한 표준 프로토콜           HDLC            비트 위주의 데이터 링크 제어 프로토콜           X.25            패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공           RS-232C            공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp17/",
        "teaser": null
      },{
        "title": "[Javascript] 변수, 함수",
        "excerpt":"1. 변수      데이터를 저장하고 참조하는 데이터의 이름   var, let, const   - let   // 재사용 가능 let a = 2; let b = 5;  console.log(a + b);  // 7 console.log(a - b);  // -3 console.log(a * b);  // 10 console.log(a / b);  // 0.4   // 값의 재할당 가능 let a = 12; console.log(a);  // 12  a = 999; console.log(a);  // 999       - const   // 값의 재할당 불가 const a = 12; console.log(a);  // 12  a = 999; console.log(a);  // TypeError: Assignment to constant variable       2. 함수      특정 동작을 수행하는 일부 코드의 집합   // 함수 선언 function helloFunc() {   // 실행 코드   console.log('Hello'); }  // 함수 호출 helloFunc();  // Hello      function returnFunc() {   ruturn 777; }  let a = returnFunc(); console.log(a);  // 777       function sum(a, b) { // a, b는 매개변수(Parameters)   return a + b; }  // 재사용 let a = sum(1, 2);  // 1, 2는 인수(Arguments) let b = sum(3, 4); let c = sum(5, 6);  console.log(a, b, c);  // 3, 7, 11       // 기명 함수 function hello() {   console.log('Hello'); }  // 익명함수 let world = function () {   console.log('World'); }  hello();  // Hello world();  // World       // 객체 데이터 const lww = {   name: 'LWW',   age: '50',   // 메소드   getName: function () {     return this.name;   } };  const hisName = lww.getName(); console.log(hisName);  // LWW // 혹은 console.log(lww.getName());  // LWW       3. 예약어      특별한 의미를 가지고 있어, 변수나 함수 이름 등으로 사용할 수 없는 단어   break, case, catch, continue, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, abstract, boolean, byte, char, class, const, debugger, double, enum, export, extends, final, float, goto, implements, import, int, interface, long, native, package, private, protected, public, short, static, super, synchronized, throws, transient, volatile, as, is, namespace, use, arguments, Array, Boolean, Date, decodeURI, decodeURIComponent, encodeURI, Error, escape, eval, EvalError, Function, Infinity, isFinite, isNaN, Math, NaN, Number, Object, parseFloat, parseInt, RangeError, ReferenceError, RegExp, String, SyntaxError, TypeError, undefined, unescape, URIError …   let this = 'Hello!';  // SyntaxError let if = 123;  // SyntaxError let break = true;  // SyntaxEr  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-varifunc/",
        "teaser": null
      },{
        "title": "[Javascript] 조건문, DOM API, 메소드 체이닝",
        "excerpt":"1. 조건문      조건의 결과에 따라 다른 코드를 실행하는 구문   let isShow = true; let checked = false;  if (isShow) {   console.log('Show');  // Show }  if (checked) {   console.log('Checked'); }       let isShow = true;  if (isShow) {   console.log('Show');  // Show } else {   console.log('Hide'); }       2. DOM API   &lt;body&gt;  &lt;div class=\"box\"&gt;Box!!&lt;/div&gt; &lt;/body&gt;   // HTML 요소 1개 검색 const boxEl = document.querySelector('.box');  // HTML 요소에 적용할 수 있는 메소드 boxEl.addEventListener();  // 인수 추가 가능 boxEl.addEventListener(1, 2);  // 1 - 이벤트(Event, 상황) boxEl.addEventListener('click', 2);  // 2 - 핸들러(Handler, 실행할 함수) boxEl.addEventListener('click', function () {   console.log('Click!'); });       // HTML 요소 1개 검색 const boxEl = document.querySelector('.box');  // 요소의 클래스 정보 객체 활용 boxEl.classList.add('active'); let isContains = boxEl.classList.contains('active'); console.log(isContains);  // true  boxEl.classList.remove('active'); isContains = boxEl.classList.contains('active'); console.log(isContains);  // false       // HTML 요소 모두 검색 const boxEls = document.querySelectorAll('.box'); console.log(boxEls);  // 찾은 요소들 반복해서 함수 실행 // 익명 함수를 인수로 추가 boxEls.forEach(function () {});  // 첫 번째 매개변수 : 반복 중인 요소 // 두 번째 매개변수 : 반복 중인 번호 boxEls.forEach(function (boxEl, index) {});  // 출력 boxEls.forEach(function (boxEl, index) {   boxEl.classList.add(`order-${index + 1}`);   console.log(index, boxEl); });       const boxEl = document.querySelector('.box');  // Getter, 값을 얻는 용도 console.log(boxEl.textContent);  // BOX!!  // Setter, 값을 지정하는 용도 boxEl.textContent = 'Change!!'; console.log(boxEl.textContent);  // Change!!       3. 메소드 체이닝   const a = 'Hello!'; // split : 문자를 인수 기준으로 쪼개서 배열로 반환 // reverse : 배열 뒤집기 // join : 배열을 인수 기준으로 문자로 병합해 반환 const b = a.split('').reverse().join('');  // 메소드 체이닝  console.log(a)  // Hello! console.log(b)  // !olleH  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-ifdomchain/",
        "teaser": null
      },{
        "title": "[Git & Github] 버전 관리",
        "excerpt":"1. Git이란?      컴퓨터 파일의 변경사항을 추적   여러 사용자들 간에 해당 파일 작업을 조율   대표적인 버전 관리 시스템(VCS)       2. Git 사용 준비   # 개행 문자(Newline) 설정 # macOS, Linux $ git config --global core.autocrlf input # Windows $ git config --global core.autocrlf true  # 사용자 정보 # commit(버전 생성)을 위한 정보 등록 $ git config --global user.name 'Github 계정 이름' $ git config --global user.email 'Github 이메일'  # 구성 확인 # Q키를 눌러서 종료 $ git config --global --list       3. Git 명령어   # 현재 프로젝트에서 변경사항 추적(버전관리) 시작 $ git init  # 원격 저장소를 로컬 저장소로 복사 $ git clone 원격 저장소 url  # 변경사항을 추적할 특정 파일을 지정 $ git add 파일 이름  # 모든 파일의 변경사항을 추적하도록 지정 $ git add .  # 버전관리 상태 확인 $ git status  # 메시지(-m)와 함께 버전을 생성 $ git commit -m '메시지'  # commit list 확인 $ git log  # 한 버전 뒤로 되돌리기 $ git reset --hard HEAD~1  # N 버전 뒤로 되돌리기 $ git reset --hard HEAD~N  # 되돌린 버전 원상복귀 $ git reset --hard ORIG_HEAD  # origin이라는 별칭으로 원격 저장소를 연결 $ git remote add origin 원격 저장소 url  # origin이란 별칭의 원격 저장소로 버전 내역 전송 $ git push origin master  # 원격 저장소의 master 브랜치 내역 당겨오기 $ git pull origin master  # 병합 없이 원격 저장소의 최신 내용으로 업데이트 $ git fetch  # 파일이 삭제 됐거나 원격 서버에 반영하지 않음 $ git rm 삭제할 파일  # Stage Area에서만 제거하고 Working Directory 상태는 유지 $ git rm --cached  # 아직 add 되지 않은 Working Directory 파일을 스택에 임시 저장 $ git stash  # git stash 목록 확인 $ git stash list  # 가장 최근의 stash 적용 $ git stash apply  ","categories": ["Git"],
        "tags": ["Github","Git"],
        "url": "/git/etc-git-versionmanage/",
        "teaser": null
      },{
        "title": "[Git & Github] Branch",
        "excerpt":"1. Branch란?      독립적인 Working Directory   새로운 작업공간으로 서로 다른 작업과 테스트가 가능       2. Branch Model      master branch            프로젝트의 기본 branch       git init으로 자동 생성       배포용 branch           develop branch            메인 branch       통합 branch           feature branch            topic branch 역할       버그의 수정과 새로운 기능 개발       원격으로 관리하지 않음       개발이 완료되면, develop branch로 merge           release branch            버그 수정 작업 후 정상적으로 동작해 배포 가능하면 master branch로 merge       ‘release-‘를 branch 이름 앞에 붙임           hotfix branch            배포한 버전에 수정이 필요할 경우       ‘hotfix-‘를 branch 이름 앞에 붙임       변경 사항을 develop branch에 merge               3. 명령어   # 원하는 이름의 branch 생성 $ git branch 이름  # 로컬 저장소 branch list 확인 $ git branch  # 원격 저장소 branch list 확인 $ git branch -r  # 로컬, 원격 저장소 branch list 확인 $ git branch -a  # 생성된 branch로 이동 $ git checkout 이름  # 생성과 동시에 branch로 이동 $ git checkout -b 이름  # 원격 저장소에 있는 branch를 가져와서 해당 branch로 이동 $ git checkout -t 이름  # 로컬 저장소에서 branch 삭제 $ git branch -d 이름       4. Branch Working Flow   $ git branch login $ git checkout -b login 개발 $ git add . $ git commit -m 'Add login in new branch' $ git push origin login $ git checkout master $ git pull origin login $ git push origin master $ git branch -d login  ","categories": ["Git"],
        "tags": ["Github","Git"],
        "url": "/git/etc-git-branch/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 5-1. 소프트웨어 개발 방법론 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp18/",
        "teaser": null
      },{
        "title": "[Git & Github] Markdown",
        "excerpt":"1. 제목(Header)      #의 개수에 따라 h1 ~ h6 태그의 크기로 Header이 적용   # 제목1 ## 제목2 ### 제목3 #### 제목4 ##### 제목5 ###### 제목6   제목1(Header)  제목2  제목3  제목4  제목5  제목6       2. 문장(Paragraph)   가나다라 마바사아 자차카타 파하.   가나다라 마바사아 자차카타 파하.       3. 줄바꿈(Line Breaks)   - 띄어쓰기 2회   가나다라 마바사아   자차카타 파하   가나다라 마바사아  자차카타 파하.   - br태그   가나다라 마바사아 &lt;br&gt; 자차카타 파하.   가나다라 마바사아   자차카타 파하.       4. 강조(Emphasis)   - 두껍게   **두껍게**   두껍게   - 이텔릭(기울임)   *이텔릭* _이텔릭_   이텔릭   이텔릭   - 취소선   ~~취소선~~   취소선   - 밑줄      권장되지 않음   &lt;u&gt;밑줄&lt;/u&gt;   밑줄   - 색상   &lt;span style=\"color: red\"&gt;색상&lt;/span&gt;   색상       5. 목록(List)   - 순서가 필요한 목록   1. 순서가 필요한 목록1 2. 순서가 필요한 목록2 3. 순서가 필요한 목록3     1. 순서가 필요한 목록1         1. 순서가 필요한 목록1         2. 순서가 필요한 목록2     2. 순서가 필요한 목록2 4. 순서가 필요한 목록4      순서가 필요한 목록1   순서가 필요한 목록2   순서가 필요한 목록3            순서가 필요한 목록1                    순서가 필요한 목록1           순서가 필요한 목록2                       순서가 필요한 목록2           순서가 필요한 목록4   - 순서가 필요하지 않은 목록   - 순서가 필요하지 않은 목록 - 순서가 필요하지 않은 목록 - 순서가 필요하지 않은 목록     - 순서가 필요하지 않은 목록         - 순서가 필요하지 않은 목록         - 순서가 필요하지 않은 목록     - 순서가 필요하지 않은 목록 - 순서가 필요하지 않은 목록      순서가 필요하지 않은 목록   순서가 필요하지 않은 목록   순서가 필요하지 않은 목록            순서가 필요하지 않은 목록                    순서가 필요하지 않은 목록           순서가 필요하지 않은 목록                       순서가 필요하지 않은 목록           순서가 필요하지 않은 목록       6. 링크(Links)   &lt;a href=\"https://google.com\"&gt;GOOGLE&lt;/a&gt; &lt;br&gt; [GOOGLE](https://google.com)   GOOGLE   GOOGLE          title : 링크에 마우스를 올렸을 때 나타나는 메시지   &lt;a href=\"https://naver.com\" title=\"NAVER로 이동!\"&gt;NAVER&lt;/a&gt; &lt;br&gt; [NAVER](https://naver.com \"NAVER로 이동!\")   NAVER   NAVER          target=”_blank” : 링크를 클릭했을 때 창이 새 탭에 열림   &lt;a href=\"https://naver.com\" title=\"NAVER로 이동!\" target=\"_blank\"&gt;NAVER&lt;/a&gt;   NAVER       7. 이미지(Image)   ![이미지](경로)             이미지에 링크 걸기   [![이미지](경로)](링크 url)      사진 클릭하면 구글로 이동     ","categories": ["Git"],
        "tags": ["Github","Git","Markdown"],
        "url": "/git/etc-git-markdown/",
        "teaser": null
      }]
