var store = [{
        "title": "[Github 블로그] Github Blog 시작!",
        "excerpt":"Github blog를 개설하는 과정을 간단하게 알아봅니다.   주의! Git의 사용법을 어느정도 숙지해야 합니다.   1. Github repository 생성  새 repository 이름을 [자신의 Github ID].github.io 로 설정한다.      2. Import code  원하는 Jekyll 테마를 선택하고 코드를 복사한다. Jekyll 테마를 모아둔 사이트는 다음과 같다.   Jekyll ? Ruby 언어로 만들어져 html, markdown 등의 텍스트를 가공하는 텍스트 변환 엔진    http://jekyllthemes.org/  http://themes.jekyllrc.org/  https://jekyllthemes.io/    나의 경우 minimal-mistakes 의 ‘dark’ 테마가 마음에 들어 선택했다.   코드를 복사한 뒤 생성한 [자신의 Github ID].github.io repository로 돌아와 import 한다.            이때 나와 같이 Import하지 않고 repository를 fork 하거나 파일을 Download해도 된다.   3. git clone  Import한 파일들을 작업하기 위해 vscode 터미널에서 clone한다.   $ git clone https://github.com/Github ID/Github ID.github.io.git   4. Rubby 설치  Jekyll을 설치하기 전에 Ruby를 설치한다.   Linux Ubuntu 환경   $ sudo apt-get install ruby-full $ ruby -v   설치가 잘 되었다면 cmd 창에 버전이 잘 출력될 것이다.       Windows 환경    Ruby 다운로드 사이트 에서 다운받아 설치한다.  설치 과정에서 \"Add Ruby executables to your PATH\" 에 체크하면 자동으로 환경변수 설정이 완료된다.   5. Jekyll, Bundler 설치  본인이 clone한 폴더로 들어가면 Gemfile 이라는 파일이 있을 것이다. cmd를 켜서 이 파일이 있는 경로로 들어간 후, 아래의 명령을 수행한다.   $ gem install jekyll bundler $ bundle $ jekyll -v   Jekyll이 잘 설치되었다면 cmd 창에 버전이 잘 출력될 것이다.  그 다음 아래의 명령어를 통해 로컬 환경에서 자신이 개발하는 블로그를 확인해 볼 수 있다.   $ jekyll serve   정상적으로 설치 되었다면 로컬서버 http://localhost:4000/  에서 확인하자.      6. 불필요한 파일 삭제  Github에 commit하기 전에 본인이 clone한 폴더에서 불필요한 파일을 삭제한다.      docs 폴더 : post 샘플이 들어가 있으므로 백업해 놓는다.  README.md : 다시 작성하기 위해 삭제했다.   7. Github 연동  수정된 사항들을 깃헙에 “add-commit-push” 하여 반영한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master    push가 완료되면 [자신의 Github ID].github.io 에서 블로그를 확인할 수 있다.  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/my-first-post/",
        "teaser": null
      },{
        "title": "[Github 블로그] _config.yml 셋팅",
        "excerpt":"config 수정 공식 사이트   minimal-mistakes _config.yml 설정 공식 사이트    _config.yml 실행   vscode로 루트경로에 있는 _config.yml 을 열어주고 작업한다.  필요없는 부분은 제외하고 작성했다.   _config.yml 수정   minimal_mistakes_skin    : \"dark\" # \"air\", \"aqua\", \"contrast\", \"dark\", \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"  # 사이트 기본 세팅 locale                   : \"ko-KR\" title                    : \"LWW's Tech Blog\" # 타이틀 title_separator          : \"&amp;#124;\" # 구분자 subtitle                 : \"Version 1.0\" # 타이틀 하단 글씨 name                     : \"이원우\" # footer에 찍히는 이름 description              : \"꾸준히 기록하는 블로그\" # 설명 url                      : \"https://LeeWonWoo1.github.io\" # 호스트 주소 repository               : \"LeeWonWoo1/LeeWonWoo1.github.io\" # GitHub 유저이름 / 레포지 이름 teaser                   :  logo                     : # 타이틀 옆 이미지 masthead_title           : \"LWW's Tech Blog\" # 최 상단 타이틀 breadcrumbs              : true # 브래드크럼 사용 여부 words_per_minute         : 200   # 댓글 comments:   provider               : \"disqus\" #   disqus:     shortname            : LWW # disqus에 입력한 Web Site Name   discourse:     server               :   # 구글 Recaptcha reCaptcha:   siteKey                :   secret                 : atom_feed:   path                   :    hide                   :  search                   : true  search_full_content      : true   # Analytics analytics:   provider               : false    # Site Author author:   name             : \"이원우\"   avatar           : \"/assets/images/profile/bear.jpg\" # 프로필 이미지   bio              : \"CS / FrontEnd\"   location         : \"Republic of Korea\"   email            : \"plmplmdnjsdn@naver.com\"   links:     - label: \"Website\"       icon: \"fas fa-fw fa-link\"       url: \"https://LeeWonWoo1.github.io\"     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"   # Site Footer footer:   links:     - label: \"Email\"       icon: \"fab fa-fw fa-envelope-square\"       url: mailto:plmplmdnjsdn@naver.com     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"  # Post에 적용될 default 설정 defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: true       share: true       related: true       popular: false   수정하면서 종종 jekyll 서버로 확인한다.   $ jekyll serve   Github 연동  수정을 완료하면 Github에 연동한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/github-blog-config/",
        "teaser": null
      },{
        "title": "[HTML] 글자와 상자",
        "excerpt":"글자와 상자   요소가 화면에 출력되는 특성. 크게 2가지로 구분됨.   인라인(Inline) 요소 : 글자를 만들기 위한 요소  블록(Block) 요소 : 상자(레이아웃)를 만들기 위한 요소   - Inline 요소   &lt;span&gt;Hello&lt;/span&gt; &lt;span&gt;World!!&lt;/span&gt;  Hello World!! -------------&gt; 요소가 수평으로 쌓임  가로는 포함한 콘텐츠 크기만큼 줄어듬 &lt;---&gt; &lt;-----&gt; Hello World!! ↕ 세로도 포함한 콘텐츠 크기만큼 줄어듬   span은 가장 대표적인 인라인 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Inline 요소는 가로, 세로 너비를 지정할 수 없음   &lt;span style=\"width: 100px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"height: 100px;\"&gt;World!!&lt;/span&gt;  Hello World!!  &lt;-- 반응 없음     외부, 내부 여백을 지정할 수 있지만, 상하 여백은 사용 불가   &lt;span style=\"margin: 20px 20px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"padding: 20px 20px;\"&gt;World!!&lt;/span&gt;  20px         20px   20px     20px &lt;--&gt;『Hello』&lt;--&gt; 『&lt;--&gt;World&lt;--&gt;』      &lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt;    &lt;!-- Inline 요소 안에 Block 요소 사용 불가 --&gt; &lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;  &lt;!-- Inline 요소 안에 Inline 요소 사용 가능 --&gt;       - Block 요소   &lt;div&gt;Hello&lt;/div&gt; &lt;div&gt;World!!&lt;/div&gt;  Hello     ↓ World!!   ↓  요소가 수직으로 쌓임  가로는 부모 요소의 크기만큼 늘어남 &lt;----------------------------------&gt; Hello                              ↕ World!!                            ↕ 세로는 포함한 콘텐츠 크기만큼 줄어듬   div은 가장 대표적인 블록 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Block 요소는 가로, 세로 너비를 지정할 수 있음   &lt;div style=\"width: 100px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"height: 40px;\"&gt;World!!&lt;/div&gt;       100px &lt;--------------&gt; Hello          ↕ World!!                        ↕                                ↕ 40px &lt;------------------------------&gt;     외부, 내부 여백을 지정할 수 있음   &lt;div style=\"margin: 20px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"padding: 20px;\"&gt;World!!&lt;/div&gt;  20px             ↕ 20px          20px &lt;--&gt;『Hello                    』&lt;--&gt;                  ↕ 20px 『               ↕ 20px          20px &lt;--&gt;World!!                      &lt;--&gt;  20px            ↕ 20px             』      &lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;    &lt;!-- Block 요소 안에 Block 요소 사용 불가 --&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;  &lt;!-- Block 요소 안에 Inline 요소 사용 가능 --&gt;   ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-inlineblock/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-1. 요구사항 확인",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 생명 주기(Software Life Cycle) – A   소프트웨어 개발 방법론의 바탕   - 폭포수 모형(Waterfall Model)      고전적 생명 주기 모형   개발의 한 단계가 끝나야 다음 단계로 넘어가는 선형 순차적 모형   메뉴얼 작성   단계가 끝나면 다음 단계 _결과물 명확히 산출_되어야 함   두 개 이상의 과정이 병행 수행 X   타당성 검토 -&gt; 계획 -&gt; 요구 분석 -&gt; 설계 -&gt; 구현(코딩) -&gt; 시험(검사) -&gt; 유지보수   - 프로토타입 모형(Prototype Model)      인터페이스에 중점을 두어 개발   시스템의 일부를 만드는 과정으로 추후 구현 단계에서 사용될 골격 코드   폭포수 모형의 단점 보완   요구 수집 -&gt; 빠른 설계 -&gt; 프로토타입 구축 -&gt; 고객 평가 -&gt; 포로토타입 조정 -&gt; 구현   - 나선형 모형(Spiral Model)      프로토타입 + 위험 분석 기능   여러번의 개발 과정을 거쳐 완벽한 소프트웨어 개발. 점진적 모형   위험의 관리와 최소화 목적   누락되거나 추가된 요구사항 첨가 가능, 정밀   유지보수 과정 필요 없음   계획 및 정의 -&gt; 위험 분석 -&gt; 공학적 개발 -&gt; 고객 평가   - 애자일 모형(Agile Model)      일정 주기 반복 하며 개발   고객과의 소통에 초점   스프린트, 이터레이션의 짧은 개발 주기 반복   결과물에 대한 고객의 평가와 요구를 적극 수용   스크럼(Scrum), XP(eXtreme Programming), 칸반(Kanban), Lean, 크리스탈, ASD, FDD 등   @ 애자일 선언   애자일 개발 4대 핵심 가치      개인과 상호작용에 더 가치를 둠   실행되는 SW에 더 가치를 둠   고객과 협업에 더 가치를 둠   변화에 반응하는 것에 더 가치를 둠   - 폭포수 모형과 애자일의 비교                  구분       폭포수       애자일                       요구사항 반영       어려움       지속적으로 반영                 고객과의 의사소통       적음       지속적                 테스트       마지막에 테스트       반복되는 주기마다 테스트                 개발 중심       계획, 문서(메뉴얼)       고객               2. 스크럼(Scrum) 기법 – A   팀 중심으로 개발 효율성 높임   - 개요      스스로 팀을 구성, 스스로 해결   제품 책임자(PO; Product Owner)            개발 의뢰자나 사용자가 담당       제품 요구사항 작성의 주체       요구사항 백로그 작성, 우선순위 지정           스크럼 마스터(SM; Scrum Master)            객관적인 시각에서 조언       통제가 목표 아님       진행사항 점검, 장애요소 공론화           개발팀(DT; Development Team)            PO, SM을 제외한 개발에 참여하는 모든 사람           - 스크럼 개발 프로세스      제품 백로그 -&gt; 스프린트 계획 회의 -&gt; 스프린트 -&gt; 일일 스크럼 회의 -&gt; 스프린트 검토 회의 -&gt; 스프린트 회고       3. XP(eXtreme Programming) 기법 – A   고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상   - XP      짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적 참여로 S/W를 빠르게 개발   릴리즈 기간을 짧게 반복   릴리즈 테스트마다 고객을 직접 참여시킴   소규모 인원 개발 프로젝트에 효과적   XP의 5대 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백   - XP 개발 프로세스      사용자 스토리 -&gt; 릴리즈 계획 수립 -&gt; 스파이크 -&gt; 이터레이션 -&gt; 승인검사 -&gt; 소규모 릴리즈   - XP 주요 실천 방법      짝 프로그래밍(Pair Programming)            다른 사람과 함께 스행하여 책임을 공동으로 나눔           테스트 주도 개발(Test-Driven Development)            테스트 케이스 먼저 작성       테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구 사용           전체 팀(Whole Team)            모든 구성원들을 각자 자신의 역할이 있고 거기에 책임을 가져야 함           계속적인 통합(Continuous Integration)            모듈 단위로 개발된 코드가 지속적으로 통합           디자인 개선(Design Improvement) 또는 리팩토링(Refactoring)            기능 변경 없이, 단순화, 유연성 강화 등을 통해 시스템 재구성           소규모 릴리즈(Small Releases)            릴리즈 기간을 짧게 반복하여 고객 요구 변화에 신속히 대응               4. 요구사항 정의 – B   - 요구사항 개념 및 특징      요구사항은 소프트웨어가 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약 조건   개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공   개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 도움   요구사항이 잘 정의 되어야 이후 과정의 목표와 계획을 수립할 수 있음   - 요구사항의 유형      기능 요구사항            무엇을 하는지, 어떤 기능을 하는지       입출력에 무엇이 포함되어야 하는지, 어떤 데이터를 저장하거나 연산을 수행해야 하는지       반드시 수행해야 하는 기능       사용자가 제공받기 원하는 기능           비기능 요구사항            시스템 장비 구성       성능       인터페이스       데이터       테스트       보안       품질       제약사항       프로젝트 관리 요구사항       프로젝트 지원 요구사항           사용자 요구사항            사용자 관점에서 본 시스템이 제공해야 할 요구사항       친숙한 표현으로 이해하기 쉽게 작성           시스템 요구사항            개발자 관점에서 본 시스템이 사용자와 다른 시스템에 제공해야 할 요구사항       전문적이고 기술적인 용어로 표현       소프트웨어 요구사항이라고도 함           - 요구사항 개발 프로세스   요구 사항 도출(Elicitation) -&gt; 분석(Analysis) -&gt; 명세(Specification) -&gt; 확인(Validation)       5. UML(Unified Modeling Language) – A   - UML 개요      객체 지향 모델링 언어   Rumbaugh, Booch, Jacobson 등 객체지향 방법론의 장접 통합. OMG에서 표준으로 지정   구조 다이어그램 6개, 행위 다이어그램 7개   사물과 사물 간의 관계를 용도에 맞게 표현   구성요소는 사물, 관계, 다이어그램   - 사물(Things)      관계가 형성될 수 있는 대상   구조 사물(Structural Things)            시스템의 개념적, 물리적 요소       Class, Use Case, Component, Node 등           행동 사물(Behavioral Things)            시간과 공간에 따른 요소들의 행위       Interaction, State Machine           그룹 사물(Grouping Things)            요소들을 그룹으로 묶어서 표현       Package           주해 사물(Annotation Things)            부가적인 설명이나 제약조건       Note           - 관계(Relationships)      사물과 사물 사이의 연관성 표현   연관(Association) 관계            2개 이상의 사물이 서로 관련되어 있음       사물 사이 실선 연결, 방향성은 화살표로       양방향 관계의 경우 화살표 생략하고 실선으로만 연결       다중도를 선 위에 표기           집합(Aggregation) 관계            하나의 사물이 다른 사물에 포함되어 있음       서로 독립적       포함하는 쪽으로 속이 빈 마름모 연결하여 표현           포함(Composition) 관계            포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계       독립될 수 없고 생명주기를 함께 함       포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현           일반화(Generalization) 관계            하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현       일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)       상위 사물 쪽으로 속이 빈 화살표 연결하여 표현           의존(Dependency) 관계            연관은 있으나 짧은 시간 동안만 연관을 유지하는 관계       소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계       영향 받는 쪽으로 점선 화살표 연결하여 표현           실체화(Realization) 관계            할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계       기능 쪽으로 속이 빈 점선 화살표 연결           - 다이어그램(Diagram)      사물과 관계를 도형으로 표현   가시화한 View를 제공하여 의사소통에 도움   정적 모델링에서는 구조적 다이어그램, 동적 모델링에서는 행위 다이어그램 사용   @ 구조적 다이어그램      클래스(Class) 다이어그램   객체(Object) 다이어그램   컴포넌트(Component) 다이어그램   배치(Deployment) 다이어그램   복합체 구조(Composite Structure) 다이어그램   패키지(Package) 다이어그램   @ 행위 다이어그램      유스케이스(Use Case) 다이어그램   시퀀스(Sequence) 다이어그램   커뮤니케이션(Communication) 다이어그램   상태(State) 다이어그램   활동(Activity) 다이어그램   상호작용 개요(Interaction Overview) 다이어그램   타이밍(Timing) 다이어그램  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-2. 화면 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 사용자 인터페이스 – A   - UI 개요      사용자 인터페이스(UI)는 사용자와 시스템 간의 상호작용이 원활하도록 돕는 장치나 S/W   UI의 3가지 분야            정보 제공을 위한 물리적 제어       콘텐츠의 상세적인 표현과 전체적인 구성       모든 사용자가 편리하고 간편하게 사용           - UI 특징      S/W 영역 중 변경이 가장 많이 발생   편리성과 가독성을 높여 작업 시간을 단축시키고 업무에 대한 이해도 높여줌   최소한의 노력으로 원하는 결과 얻을 수 있게 함   오류를 줄임   구체적인 방법 제시   매개 역할   UI를 설계하기 위해서는 S/W 아키텍처 반드시 숙지해야 함   - UI 구분      CLI(Command Line Interface) : 텍스트 형태   GUI(Graphical User Interface) : 그래픽 환경   NUI(Natural User Interface) : 말이나 행동으로 조작   - UI 기본 원칙      직관성   유효성   학습성   유연성   - UI 설계 지침      사용자 중심   일관성   단순성   결과 예측 가능   가시성   표준화   접근성   명확성   오류 발생 해결       2. UI 표준 및 지침 – B      기술의 중립성(웹 표준), 표현 보장성(웹 접근성), 기능의 호환성(웹 호환성) 고려 확인   UI 표준 : 모든 UI에 공통적으로 적용될 내용   UI 지침 : UI 개발 과정에서 꼭 지켜야 할 공통의 조건   - 한국형 웹 콘텐츠 접근성 지침(KWCAG)      인식의 용이성            대체 텍스트       멀티미디어 대체 수단       명료성           운용의 용이성            키보드 접근성       충분한 시간 제공       광과민성 발작 예방       쉬운 내비게이션           이해의 용이성            가독성       예측 가능성       콘텐츠의 논리성       입력 도움           견고성            문법 준수       접근성           - 전자정부 웹 표준 준수 지침      내용의 문법 준수            적절한 문서타입 명시       문법 준수       인코딩 방식 표기           내용과 표현의 분리            마크업 언어를 사용해 웹 문서 구조화       스타일 언어는 표준 문법 준수           동작의 기술 중립성 보장            스크립트의 비표준 문법 확장 배제       대체 텍스트나 정보 제공           플러그인의 호환성            다양한 웹 브라우저에서 호환되는 것 사용           콘텐츠의 보편적 표현            메뉴는 다양한 브라우저에서 접근할 수 있어야 함       웹 사이트를 다양한 인터페이스로 이용할 수 있어야 함           운영체제에 독립적인 콘텐츠 제공            운영체제에 종속적이지 않은 범용적인 포맷을 사용           부가 기능의 호환성 확보            다양한 브라우저에서 사용할 수 있어야 함           다양한 프로그램 제공            다양한 브라우저에서 사용할 수 있어야 함       윈도우, 리눅스, 맥킨토시 중 2개 이상의 운영체제를 지원해야 함               3. UI 설계 도구 – A      UI의 화면 구조나 화면 배치 등을 설계할 때 사용하는 도구   기획단계에서 미리 보여주기 위한 용도   - 와이어프레임(Wireframe)      페이지에 대한 개략적인 레아아웃이나 UI 요소 등에 대한 뼈대 설계   페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계   레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용   툴 : 손그림, PPT, 키노트, 스케치, 일러스트, 포토샵 등   - 목업(Mockup)      와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형   실제로 구현되지는 않음   툴 : 파워 목업, 발사믹 목업 등   - 스토리보드(Story Board)      와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가   최종적으로 참고하는 작업 지침서, 서비스 구축을 위한 모든 정보 포함   상단이나 우측에는 제목, 작성자 기입, 좌측에는 UI화면, 우측에는 Description 기입   Description은 명확하고 세부적으로 작성   툴 : PPT, 키노트, 스케치, Axure 등   - 프로토타입(Prototype)      와이어프레임이나 스토리보드 등에 인터렉션을 적용한 동적인 형태의 모형   작업자 간 서비스 이해를 위해 작성하는 샘플   페이퍼 프로토타입과 디지털 프로토타입으로 나뉨   툴 : HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등   - 유스케이스(Use Case)      사용자 측면에서의 요구사항   사용자의 요구사항을 파악해 초기에 기능적인 요구를 결정하고 그 결과를 문서화할 수 있음   자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것. 다이어그램 형식으로 묘사   유스케이스 다이어그램이 완성되면, 명세서 작성       4. UI 요구사항 확인 – B      새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해서 작성하는 단계   목표 정의 -&gt; 활동사항 정의 -&gt; UI 요구사항 작성 -&gt; 요구사항 요소 확인 -&gt; 정황 시나리오 작성 -&gt; 요구사항 작성       5. 품질 요구사항 – B      요구사항이 얼마나 충족하는가를 나타내는 S/W 특성의 총체   품질은 사용자의 요구사항을 충족시킴으로써 확립   ISO/IEC 9126            품질 특성과 평가를 위한 표준 지침       품질에 대한 요구사항을 기술하거나 품질 평가 등에 사용       기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성           호환성과 보안성을 강화하여 ISO/IEC 25010으로 개정            기능적합성, 신뢰성, 사용성, 실행효율성, 유지보수성, 이식성, 호환성, 보안성           - 기능성(Functionality)      사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부   적절성/정합성(Suitability) : 적절한 기능을 제공   정밀성/정확성(Accuracy) : 결과를 정확하게 산출   상호 운용성(Interoperability) : 서로 어울려 작업   보안성(Security) : 접근을 권한에 따라 허용하거나 차단   준수성(Compliance) : 표준, 관례 및 규정을 준수   - 신뢰성(Reliability)      요구된 기능을 정확하고 일관되게 오류 없이 수행   성숙성(Maturity) : 고장을 피해감   고장 허용성(Fault Tolerance) : 고장 시 규정된 성능 수준을 유지   회복성(Recoverability) : 고장 시 다시 회복하고 데이터를 복구   - 사용성(Usability)      사용자가 정확하게 이해하고 사용하며, 다시 사용하고 싶은 정도   이해성(Understandability) : 사용자가 이해할 수 있는 능력   학습성(Learnability) : S/W를 학습할 수 있도록 하는 능력   운용성(Operability) : 운용하고 제어할 수 있도록 하는 능력   친밀성(Attractiveness) : 다시 사용하고 싶어 하도록 하는 능력   - 효율성(Efficiency)      할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도   시간 효율성(Time Behaviour) : 적절한 반응 시간 및 처리시간, 처리율 제공   자원 효율성(Resource Behaviour) : 적절한 자원의 양과 종류를 제공   - 유지 보수성(Maintainability)      환경의 변화에서 S/W를 개선하거나 확장할 수 있는 정도   분석성(Analyzability) : 수정될 부분의 식별을 가능하게 하는 능력   변경성(Changeability) : 변화로 인한 수정 등을 쉽게 구현   안정성(Stability) : 변경으로 인한 예상치 못한 결과를 최소화하는 능력   시험성(Testability) : 변경이 검증될 수 있는 능력   - 이식성(Portability)      다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도   적용성(Adaptability) : 다른 환경으로 변경될 수 있는 능력   설치성(Installability) : 임의의 환경에 설치할 수 있는 능력   대체성(Replaceability) : 다른 S/W를 대신하여 사용될 수 있는 능력   공존성(Co-existence) : 다른 S/W와 공존할 수 있는 능력       6. UI 프로토타입 제작 및 검토 – A   - UI 프로토타입 개요      프로토타입은 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적 형태의 모형   테스트 가능   간단하게 만들어야 함   핵심 기능만을 제공하지만, 필요한 기능은 반드시 포함   요구사항이 모두 반영될 때까지 개선, 보완   실제 사용자를 대상으로 테스트   - UI 프로토타입 장단점      장점            설득, 이해 쉬움       혼선 예방으로 개발 시간 단축       사전 오류 발견           단점            반복적인 개선작업으로 작업 시간 증가, 필요이상으로 자원 소모       중요한 작업 생략될 수 있음           - 프로토타이핑 종류      페이퍼 프로토타입(Paper Prototype)            아날로그적 방법, 손으로 직접 작성       제작기간이 짧고, 업무 협의가 빠른 경우 사용       장점                    비용 저렴           대화하면서 생성 가능           즉시 변경 가능           고객이 과다한 기대 안함                       단점                    테스트하기 부적당           상호 관계가 많은 경우 나타내기 복잡           여러 사람들에게 나눠주거나 공유하기 어렵다                           디지털 프로토타입(Digital Prototype)            프로그램을 사용하여 작성       재사용이 필요한 경우, 숙련된 전문가가 있을 경우 사용       장점                    최종 제품과 비슷하게 테스트           수정 쉬움           재사용 가능                       단점                    프로그램의 사용법을 알아야 함                           - UI 프로토타입 제작 단계      요구사항 분석   개발할 시스템의 핵심적인 기능을 페이퍼/디지털 방식으로 작성   사용자가 확인하는 단계, 추가 및 수정 의견 제안   수정과 합의가 이루어짐       7. UI 설계서 작성 – B   - UI 설계서 개요      UI 설계를 구체화하여 작성하는 문서. 대표적인 화면들을 설계   원활한 의사소통을 위해 작성   - UI 설계서 표지 작성      혼동되지 않도록 프로젝트명 또는 시스템명을 포함   - UI 설계서 개정 이력 작성      UI 설계서가 수정될 때마다 어떤 부분이 수정되었는지 정리해 놓은 문서   - UI 요구사항 정의서 작성      사용자의 요구사항을 확인하고 정리한 문서   - 시스템 구조 작성      전체 시스템의 구조를 설계한 것   - 사이트 맵 작성      사이트에 표시할 콘텐츠를 한 눈에 알아 볼 수 있도록 메뉴별로 구분하여 설계한 것   - 프로세스 정의서 작성      프로세스들을 작업 진행 순서에 맞춰 정리한 것   UI 전체적인 흐름 파악 가능   - 화면 설계      필요한 화면을 페이지별로 설계   와이어프레임을 대략적으로 스케치   주요 흐름을 스토리보드 형태로 작성   - UI 화면 설계의 기본 구성 요소      윈도우, 메뉴, 아이콘, 포인터       8. UI 상세 설계 – B      실제 구현을 위해 모든 화면에 대한 자세한 설계를 진행하는 단계. 반드시 시나리오 작성   최종 목표를 달성하기 위한 방법이 순차적으로 묘사   - UI 시나리오 문서 작성 원칙      구체적으로 작성. Tree 구조 또는 Flow Chart 표기법으로 작성   공통적으로 적용될 UI 요소와 인터렉션을 일반 규칙으로 정의   레이아웃과 속할 기능 정의   인터렉션의 순서, 분기, 조건, 루프 등을 명시   예외 상황에 대비한 다양한 케이스 정의   기능별 상세 기능 시나리오를 정의   UI 시나리오 규칙을 지정   - UI 시나리오 문서 작성을 위한 일반 규칙      주요 키의 위치와 기능   공통 UI 요소   기본 스크린 레이아웃   기본 인터랙션 규칙   공통 단위 태스크 흐름   케이스 문서   - UI 요소      체크 박스 : 1개 이상의 값을 선택할 수 있는 버튼   라디오 버튼 : 하나만 선택할 수 있는 버튼   텍스트 박스 : 데이터를 입력하고 수정할 수 있는 상자   콤보 상자 : 지정된 목록 상자에 내용을 표시하여 선택하거나 새로 입력할 수 있는 상자   목록 상자 : 콤보 상자와 같이 목록을 표시하지만 새로운 내용을 입력할 수 없음   - UI 시나리오 문서의 요건      완정성(Complete)   일관성(Consistent)   이해성(Understandable)   가독성(Readable)   수정 용이성(Modifiable)   추적 용이성(Traceable)   - UI 시나리오 문서로 인한 기대 효과      오류 감소   재작업 감소, 혼선 최소화   불필요한 기능 최소화   개발 비용 절감   개발 속도 향상  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp2/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-3. 애플리케이션 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 아키텍처 – A   - 소프트웨어 아키텍처의 설계      골격이 되는 기본 구조, 시스템의 구조 또는 구조체   원칙과 지침, 의사소통 도구   비기능적 요구사항의 제약 반영, 기능적 요구사항을 구현하는 방법을 찾는 과정   분할 방법, 모듈에 할당될 기능, 모듈 간의 인터페이스 등 결정   - 모듈화(Modularity)      성능을 향상시키거나 수정 및 재사용, 유지관리 등을 위해 기능들을 모듈 단위로 나누는 것   자주 사용하는 것들을 공통 모듈로 구성하여 재사용성 향상   크기를 작게 나누면 통합 비용이 많이 듦   크기를 크게 나누면 모듈 하나의 개발 비용이 많이 듦   - 추상화(Abstraction)      전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화   유사한 모델을 만들어서 여러 가지 요인들을 테스트   최소의 비용으로 실제 상황에 대처, 구조 및 구성을 대략적으로 파악   과정 추상화            전반적인 흐름만 파악할 수 있게 설계           데이터 추상화            데이터 구조를 대표할 수 있는 표현으로 대체           제어 추상화            이벤트 발생을 대표할 수 있는 표현으로 대체           - 단계적 분해(Stepwise Refinement)      하향식 설계 전략. 상위의 중요 개념으로부터 하위의 개념으로 구체화   추상화의 반복에 의해 세분화   기능에서부터 시작해 알고리즘, 자료구조 등 상세한 내역을 뒤로 미뤄 진행   - 정보 은닉(Information Hiding)      정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법   필요한 정보만 인터페이스를 통해 주고 받음   모듈을 독립적으로 수행할 수 있음   모듈이 변경되더라도 다른 모듈에 영향을 주지 않아 수정, 시험, 유지보수 용이   - 소프트웨어 아키텍처의 품질 속성      시스템 측면            성능, 보안, 가용성, 기능성, 사용성, 변경용이성, 확장성 등           비즈니스 측면            시장 적시성, 비용과 혜택, 예상 시스템 수명 등           아키텍처 측면            개념적 무결성, 정확성, 완결성, 구축 가능성 등           - 소프트웨어 아키텍처 설계 과정      설계 목표 설정 -&gt; 시스템 타입 결정 -&gt; 아키텍처 패턴 적용 -&gt; 서브시스템 구체화 -&gt; 검토       2. 아키텍처 패턴 – A   - 아키텍처 패턴의 개요      아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식   S/W 시스템의 구조를 구성하기 위한 기본적인 윤곽   서브시스템들과 그 역할이 정의, 관계와 여러 규칙, 지침 등이 포함   아키텍처 스타일 또는 표준 아키텍처라고도 함   - 레이어 패턴(Layers pattern)      시스템을 계층으로 구분   상위 계층은 서비스 제공자, 하위 계층은 클라이언트가 됨   마주보는 두 개의 계층 사이에서만 상호작용   변경 작업 용이   특정 계층만을 교체해 시스템을 개선하는 것이 가능   OSI 참조 모델   - 클라이언트-서버 패턴(Client-Server pattern)      하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성   사용자는 클라이언트와만 의사소통   서버는 항상 대기 상태를 유지   클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고 서로 독립적   - 파이프-필터 패턴(Pipe-Filter Pattern)      데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터 전송   재사용성이 좋고, 추가가 쉬워 확장이 용이   재배치하여 다양한 파이프라인 구축 가능   데이터 변환, 버퍼링, 동기화 등에 주로 사용   Unix의 Shell   - 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)      서브시스템을 3개의 부분으로 구조화   모델(Model) : 핵심 기능과 데이터를 보관   뷰(View) : 정보를 표시   컨트롤러(Controller) : 입력을 처리   별도의 컴포넌트로 분리되어 서로 영향을 받지 않고 개발 작업 수행 가능   여러 개의 뷰를 만들 수 있으므로 대화형 어플리케이션에 적합   - 마스터-슬레이브 패턴(Master-Slave Pattern)      장애 허용 시스템, 병렬 컴퓨팅 시스템   - 브로커 패턴(Broker Pattern)      분산 환경 시스템   - 피어-투-피어 패턴(Peer-To-Peer Pattern)      클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용   - 이벤트-버스 패턴(Event-Bus Pattern)      소스, 리스너, 채널, 버스   - 블랙보트 패턴(Blackboard Pattern)      음성 인식, 차량 식별, 신호 해석   - 인터프리터 패턴(Interpreter Pattern)      프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용       3. 객체지향(Object-Oriented) – A   - 객체지향의 개요      S/W를 개발할 때 객체들을 조립해서 작성할 수 있는 기법   재사용 및 확장 용이, 빠르게 개발할 수 있고 유지보수 쉬움   복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리 지원   사용자와 개발자가 쉽게 이해할 수 있음   - 객체(Object)      데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 S/W 모듈   데이터            객체가 가지고 있는 정보. 속성이나 상태, 분류 등       속성, 상태, 변수, 상수, 자료 구조           함수            객체가 수행하는 기능       메소드, 서비스, 동작, 연산           객체의 특성            독립적으로 식별 가능한 이름       상태는 시간에 따라 변함       상호 연관성에 의한 관계 형성       행위의 특징을 나타낼 수 있음       일정한 기억장소를 가지고 있음           - 클래스(Class)      공통된 속성과 연산을 갖는 객체의 집합   객체들이 갖는 속성과 연산을 정의하고 있는 틀   각각의 객체를 인스턴스, 새로운 객체를 생성하는 것을 인스턴스화   최상위 클래스는 상위 클래스를 갖지 않는 클래스   슈퍼 클래스는 특정 클래스의 부모 클래스   서브 클래스는 특정 클래스의 자식 클래스   - 캡슐화(Encapsulation)      데이터와 데이터를 처리하는 함수를 하나로 묶는 것   인터페이스를 제외한 세부 내용이 은폐   외부 모듈의 변경으로 인한 파급 효과가 적음   재사용 용이   인터페이스가 단순해지고, 객체 간 결합도 낮아짐   - 상속(Inheritance)      부모 클래스의 모든 속성과 연산을 자식 클래스가 물려 받는 것   자식 클래스는 속성과 연산을 다시 정의하지 않고 사용 가능   새로운 속성과 연산을 첨가하여 사용 가능   재사용을 높임   - 다형성(Polymorphism)      메시지에 의해 객체가 연산을 수행할 때, 고유한 방법으로 응답할 수 있는 능력   객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함   같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 함       4. 모듈 – A   - 모듈의 개요      모듈화를 통해 분리된 시스템의 각 기능. 서브루틴, 서브시스템 등과 같은 의미로 사용   단독으로 컴파일 가능, 재사용 가능   모듈의 기능적 독립성은 하나의 기능만을 수행하고 과도한 상호작용을 배재함으로써 달성   수정하더라도 다른 모듈에 거의 영향을 미치지 않으며, 오류 발생시 쉽게 발견하고 해결 가능   결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 함   - 결합도(Coupling)      모듈간 상호 의존하는 정도   결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음   결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움   @ 내용 결합도(Content Coupling)      한 모듈이 다른 모듈이 내부 기능 및 그 내부 자료를 직접 참조하거나 수정   제어가 이동하는 경우   @ 공통(공유) 결합도(Common Coupling)      공통 데이터 영역을 여러 모듈이 사용할 때의 결합도   조금의 변경이 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 함   @ 외부 결합도(External Coupling)      선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도   데이터의 범위를 각 모듈에서 제한할 수 있음   @ 제어 결합도(Control Coupling)      다른 모듈 내부의 논리적 흐름을 제어하기 위해 제어신호를 이용하여 통신   다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우   처리 기능이 두 모듈에 분리되어 설계된 경우   하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상 발생   @ 스탬프 결합도(Stamp Coupling)      배열이나 레코드 등의 자료 구조가 전달될 때의 결합도   동일한 자료 구조를 조회하는 경우   @ 자료 결합도(Data Coupling)      자료 요소로만 구성될 때의 결합도   가장 바람직한 결합도   - 응집도(Cohesion)      정보 은닉 개념을 확장한 것   모듈이 독립적인 기능으로 정의되어 있는 정도   응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음   @ 기능적 응집도(Functional Cohesion)      모든 기능 요소들이 단일 문제와 연관되어 수행될 경우   @ 순차적 응집도(Sequential Cohesion)      출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우   @ 교환적 응집도(Communication Cohesion)      동일한 입출력을 사용하여 서로 다른 기능을 수행하는 구성요소들이 모였을 경우   @ 절차적 응집도(Procedural Cohesion)      다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우   @ 시간적 응집도(Temporal Cohesion)      특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우   @ 논리적 응집도(Logical Cohesion)      유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우   @ 우연적 응집도(Coincidental Cohesion)      각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우   - 팬인(Fan-In) / 팬아웃(Fan-Out)      팬인은 모듈을 제어하는 모듈의 수. 팬아웃은 모듈에 의해 제어되는 모듈의 수   시스템의 복잡도를 알 수 있음   팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있으나, 단일 장애점 발생 가능   팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고 단순화할 수 있는지 검토   시스템 복잡도를 최적화하기 위해 팬인을 높게, 팬아웃은 낮게 설계       5. 코드 – B   - 코드의 개요      자료의 추출을 쉽게 하기 위해 사용하는 기호   신속, 정확, 명료하게 정보 전달   일정한 규칙에 따라 작성   식별기능, 분류기능, 배열기능   - 코드의 종류      순차 코드            1, 2, 3 ..           블록 코드            1001~1100 : 총무부           10진 코드            1000 : 공학, 1100 : S/W 공학           그룹 분류 코드            1-01-001 : 본사-총무부-인사계           연상 코드            TV-40 : 40인치 TV           표의 숫자 코드            120-720-1500 : 두께x폭x길이가 120x720x1500인 강판           합성 코드            KE-711 : 대한항공 711기           - 코드 부여 체계      이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식   유일한 코드 부여하여 식별 및 추출을 용이하게 함   각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 함   코드의 자릿수와 구분자, 구조 등을 상세하게 명시       6. 디자인 패턴 – B   - 디자인 패턴의 개요      세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식   재사용할 수 있는 기본형 코드들이 포함   디자인 패턴을 참고하여 적용하는 것이 더 효율적   Don’t reinvent the wheel   유사한 형태의 다른 패턴으로 변화되는 특징   - 아키텍처 패턴 vs 디자인 패턴                  아키택처       디자인                       상위수준 설계       하위수준 설계                 전체 시스템 구조 설계       서브시스템에 속하는 컴포넌트들과 그 관계 설계           - 생성 패턴(Creational Pattern)      객체의 생성과 관련된 패턴   객체의 생성과 참조 과정을 캡슐화하여 프로그램에 유연성을 더해줌   @ 추상 팩토리(Abstract Factory)      인터페이스를 통해 서료 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현   연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능   @ 빌더(Builder)      작게 분리된 인스턴스를 건축 하듯이 조합하여 객체 생성   동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음   @ 팩토리 메소드(Factory Method)      객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화   상위클래스에서는 인터페이스 정의하고 실제 생성은 서브 클래스가 담당   @ 프로토타입(Prototype)      원본 객체를 복제하는 방법으로 객체를 생성   비용이 큰 경우 이용   @ 싱글톤(Singleton)      객체를 생성하면 어디서든 참조할 수 있지만, 여러 프로세스가 동시 참조 불가   클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비 최소화   - 구조 패턴(Structural Pattern)      클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴   구조가 복잡한 시스템을 개발하기 쉽게 도와줌   @ 어댑터(Adapter)      인터페이스를 다른 클래스가 이용할 수 있도록 변환   인터페이스가 일치하지 않을 때 이용   @ 브리지(Bridge)      서로가 독립적으로 확장할 수 있도록 구성한 패턴   기능과 구현을 두 개의 별도 클래스로 구현   @ 컴포지트(Composite)      복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용   객체를 트리구조로 구성   @ 데코레이터(Decorator)      객체 간의 결합을 통해 능동적으로 기능들을 확장   부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식   @ 퍼싸드(Facade)      상위에 인터페이스를 구성함으로써 서브 클래스의 기능을 간편하게 사용할 수 있도록 함   통합 인터페이스를 제공하는 Wrapper 객체가 필요   @ 플라이웨이트(Flyweight)      매번 생성하는 것이 아니고 가능한 한 공유해서 사용해 메모리 절약   다수의 유사 객체를 생성하거나 조작할 때 유용   @ 프록시(Proxy)      접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할   네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용   - 행위 패턴(Behavioral Pattern)      클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의   하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화하도록 도움   @ 책임 연쇄(Chain of Responsibility)      객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태   @ 커맨드(Command)      요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장   추상 클래스와 구체 클래스로 분리하여 단순화   @ 인터프리터(Interpreter)      언어에 문법 표현을 정의하는 패턴   SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용   @ 반복자(Iterator)      접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴   내부 표현 방법의 노출 없이 순차적인 접근이 가능   @ 중재자(Mediator)      복잡한 상호작용을 캡슐화하여 객체로 정의   객체 사이의 의존성을 줄여 결합도 감소시킴   @ 메멘토(Memento)      객체 내부 상태를 객체화함으로써 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공   Ctrl + Z 같은 기능 개발할 때 이용   @ 옵서저(Observer)      객체의 상태가 변화하면 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴   분산 시스템 간에 이벤트를 생성, 발행하고, 이를 수신해야 할 때 이용   @ 상태(State)      동일한 동작을 다르게 처리해야 할 때 사용하는 패턴   객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리   @ 전략(Strategy)      동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴   원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘 변경 가능   @ 템플릿 메소드(Template Method)      상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 패턴   코드의 양을 줄이고 유지보수를 용이하게 해줌   @ 방문자(Visitor)      데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴   분리된 처리 기능은 각 클래스를 방문하여 수행  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp3/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-4. 인터페이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 시스템 인터페이스 요구사항 분석 – B   - 시스템 인터페이스 요구사항 구성      시스템끼리 서로 연동하여 상호작용하기 위한 접속 방법이나 규칙   명세서에는 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 방식, 송신 데이터, 주기 등 포함   - 시스템 인터페이스 요구사항 분석      기능적 요구사항과 비기능적 요구사항으로 분류   요구사항 분석 기법을 적절히 이용   적절한 수준으로 세분화   누락된 요구사항이나 제한조건 추가   상대적 중요도를 평가하여 우선순위를 부여   - 시스템 인터페이스 요구사항 분석 절차      요구사항 선별 -&gt; 요구사항 관련 자료 준비 -&gt; 요구사항 분류 -&gt; 요구사항 분석 및 명세서 구체화 -&gt; 요구사항 명세서 공유       2. 인터페이스 요구사항 검증 – B      요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 베이스라인 설정   검토 계획 수립 -&gt; 검토 및 오류 수정 -&gt; 베이스라인 설정   - 요구사항 검증 방법      요구사항 검토            동료 검토 : 동료들이 결함 발견       워크스루 : 짧은 검토 회의를 통해 결함 발견       인스펙션 : 검토 전문가들이 결함 발견           프로토타이핑   테스트 설계   CASE 도구 활용   - 인터페이스 요구사항 검증의 주요 항목      완전성(Completeness)   일관성(Consistency)   명확성(Unambiguity)   기능성(Functionality)   검증 가능성(Verifiability)   추적 가능성(Traceability)   변경 용이성(Easily Changeable)       3. 인터페이스 방법 명세화 – B   - 시스템 연계 기술      DB Link : DB Link 객체를 이용하는 방식   API/Open API : DB에서 데이터를 읽어 와 제공   연계 솔루션 : EAI 서버와 송수신 시스템에 설치되는 클라이언트 이용   Socket : 서버는 통신을 위한 소켓을 생성하여 포토 할당하여 클라이언트의 통신 요청 시 연결하여 통신   Web Service : WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스   - 인터페이스 통신 유형      단방향 : 요청만 하고 응답이 없는 방식   동기 : 요청하고 응답이 올때까지 대기   비동기 : 요청하고 다른 작업을 수행하다 응답이 오면 처리   - 인터페이스 처리 유형      실시간 방식 : 요청한 내용을 바로 처리   지연 처리 방식 : 매건 단위로 처리할 경우 비용이 많이 발생할 때   배치 방식 : 대량의 데이터를 처리할 때       4. 미들웨어 솔루션 명세 – A   - 미들웨어의 개념 및 종류      운영체제와 응용프로그램 사이에서 추가적인 서비스를 제공하는 소프트웨어   표준화된 인터페이스 제공하여 데이터 교환에 일관성 보장   - DB(DataBase)      클라이언트에서 원격의 DB와 연결하기 위한 미들웨어   DB를 사용해서 시스템 구축하는 경우 2-Tier 아키텍처라고 함   ODBC, IDAPI, Glue   - RPC(Remote Procedure Call)      응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식   Entera, ONC/RPC   - MOM(Message Oriented Middleware)      메시지 기반의 비동기형 메시지를 전달하는 방식   온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 사용됨   MQ, Message Q, JMS   - TP-Monitor(Transaction Processing Monitor)      온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어   빠른 응답 속도를 유지해야 하는 업무에 사용   tuxedo, tmax   - ORB(Object Request Broker)      객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현   트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음   Orbix, CORBA   - WAS(Web Application Server)      동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어   웹 환경을 구현하기 위한 미들웨어   웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현 가능   WebLogic, WebSphere  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp4/",
        "teaser": null
      },{
        "title": "[HTML] HTML 구조 및 태그",
        "excerpt":"HTML 구조   &lt;!DOCTYPE html&gt;  &lt;!-- 문서의 HTML 버전을 지정 --&gt;  &lt;html&gt;       &lt;!-- 문서의 전체 범위 --&gt;    &lt;head&gt;     &lt;!-- 문서의 정보를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보이지 않는 정보를 작성하는 범위 --&gt;   &lt;/head&gt;    &lt;body&gt;     &lt;!-- 문서의 구조를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보여지는 구조를 작성하는 범위 --&gt;   &lt;/body&gt; &lt;/html&gt;   Head 태그 내부   - meta 태그   &lt;meta charset=\"UTF-8\" /&gt;   &lt;!-- 문자 인코딩 방식 --&gt; &lt;meta name=\"viewport\" content=\"width=xxxx...\" /&gt; &lt;!-- 정보의 종류     정보의 값 --&gt;  &lt;meta /&gt;는 HTML 문서의 제작자, 내용, 키워드 등의 정보를 검색엔진이나 브라우저에 제공       - title 태그   &lt;title&gt;Google&lt;/title&gt; &lt;!-- HTML 문서의 제목을 정의. 웹 브라우저 탭에 표시됨--&gt;       - link 태그   &lt;!-- 관계              경로 --&gt; &lt;link rel=\"stylesheet\" href=\"./main.css\" /&gt; &lt;link rel=\"icon\" htrf=\"./favicon.png\" /&gt;  &lt;link /&gt;는 외부 문서를 가져와 연결할 때 사용. 대부분 CSS 파일       - style 태그   &lt;!-- CSS를 HTML 문서 안에서 작성하는 경우에 사용 --&gt; &lt;style&gt;   div {     color : red;   } &lt;/style&gt;       - script 태그   &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;!-- JS파일 가져오는 경우--&gt; &lt;!-- defer : HTML 구조가 준비된 후에 JS를 해석 --&gt;  &lt;!-- JS를 HTML 문서 안에서 작성하는 경우 --&gt; &lt;script&gt;   console.log('Hello World!!') &lt;/script&gt;   Body 태그 내부   - div 태그   &lt;div&gt;&lt;/div&gt;  &lt;!-- Block, 특별한 의미가 없는 구분을 위한 요소 --&gt;       - h 태그   &lt;h1&gt;제목1&lt;/h1&gt;    &lt;!-- Block, 제목을 의미하는 요소 --&gt; &lt;h2&gt;제목2&lt;/h2&gt;    &lt;!-- 숫자가 작을수록 더 중요한 제목--&gt; &lt;h6&gt;제목6&lt;/h6&gt;       - p 태그   &lt;p&gt;가나 다라마&lt;/p&gt;  &lt;!-- Block, 문장을 의미하는 요소 --&gt;       - img 태그   &lt;!-- 경로              대체 텍스트 --&gt; &lt;img src=\"img/xxx.png\" alt=\"xxx\" /&gt; &lt;!-- Inline, 이미지 삽입 요소--&gt;       - ul, li 태그   &lt;ul&gt;  &lt;!-- Block, 순서가 필요 없는 목록의 집합--&gt;   &lt;li&gt;강아지&lt;/li&gt;    &lt;li&gt;고양이&lt;/li&gt;  &lt;!-- 목록 내 각 항목 --&gt;   &lt;li&gt;돼지&lt;/li&gt; &lt;/ul&gt;       - a 태그   &lt;!-- Inline, 다른/같은 페이지로 이동하는 하이퍼링크 지정하는 요소 --&gt; &lt;a href=\"http://www.google.com\" target=\"_blank\"&gt;Google&lt;/a&gt; &lt;!-- URL                       URL의 표시(브라우저 탭) 위치 --&gt;       - span 태그   &lt;span&gt;가나다&lt;/span&gt; &lt;!-- Inline, 특별한 의미가 없는 구분을 위한 요소--&gt;       - br 태그   &lt;p&gt;가나다라&lt;br/&gt;마바사아&lt;/p&gt; &lt;!--Inline, 줄바꿈 요소--&gt;  가나다라 마바사아       - input 태그   &lt;!--Inline-Block, 데이터를 입력하는 요소--&gt; &lt;input type=\"text\" value=\"xxx\" placeholder=\"yyy\" disabled/&gt;  &lt;!--  타입         입력된 값     힌트            비활성화 --&gt;       - label 태그   &lt;label&gt; &lt;!--Inline, 라벨 가능 요소(input)의 제목--&gt;   &lt;input type=\"checkbox\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"checkbox\" checked /&gt; Cat &lt;/label&gt;   &lt;label&gt; &lt;!-- animals 그룹에서 1개만 입력 --&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Cat &lt;/label&gt;        - table, tr, td 태그   &lt;table&gt;  &lt;!-- Table, 표 요소, 행과 열의 집합 --&gt;    &lt;tr&gt;   &lt;!-- Table, 행을 지정하는 요소 --&gt;     &lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt; &lt;!-- Table, 열을 지정하는 요소 --&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;C&lt;/td&gt;&lt;td&gt;D&lt;/td&gt;   &lt;/tr&gt;  &lt;/table&gt;  A B C D  주의! TABLE 요소보다 Grid같은 CSS 기능으로 레이아웃을 작업해야 함   HTML 전역 속성   &lt;태그 title=\"설명\"&gt;&lt;/태그&gt;   &lt;!-- 요소의 정보나 설명을 지정 --&gt; &lt;태그 style=\"스타일\"&gt;&lt;/태그&gt; &lt;!-- 요소에 적용할 스타일 지정 --&gt; &lt;태그 class=\"이름\"&gt;&lt;/태그&gt;   &lt;!-- 요소를 지칭하는 중복 가능한 이름 --&gt; &lt;태그 id=\"이름\"&gt;&lt;/태그&gt;      &lt;!-- 요소를 지칭하는 고유한 이름 --&gt; &lt;태그 data-이름=\"데이터\"&gt;&lt;/태그&gt; &lt;!-- 요소에 데이터를 지정 --&gt;  ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-structure/",
        "teaser": null
      },{
        "title": "[CSS] CSS 개요",
        "excerpt":"CSS 기본 문법   /* 주석 */ 선택자 {   속성 : 값;   속성 : 값; }   CSS 선언 방식   - 내장 방식   style 태그의 내용으로 스타일 작성   &lt;style&gt;   div {     color: red;     margin: 10px;   } &lt;/style&gt;       - 인라인 방식   요쇼의 style 속성에 직접 스타일 작성   &lt;div style=\"color: red; margin: 10px;\"&gt;&lt;/div&gt;       - 링크 방식   링크 태그로 외부 CSS 파일을 가져와서 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ div {   color: red;   margin: 20px; }       - @import 방식   CSS의 @import 규칙으로 CSS문서 안에서 또 다른 CSS문서를 가져와 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ @import url(\"./sub.css\");  div {   color: red;   margin: 20px; }  /* sub.css */ .sub {   width: 10px;   height: 20px; }   CSS 선택자   - 기본   /* 전체 선택자 : 모든 요소 선택 */ * {   color: red; }  /* 태그 선택자 : 태그 이름의 요소 선택 */ div {   color: red; }  /* 클래스 선택자 : class 속성 값의 요소 선택  */ .cat {   color: red; }  /* 아이디 선택자 : id 속성 값의 요소 선택 */ #cat {   color: red; }       - 복합   /* 일치 선택자 : 선택자를 동시에 만족하는 요소 선택 */ div.cat {   color: red; }  /* 자식 선택자 : 자식 요소 선택 */ ul &gt; .cat {   color: red; }  /* 하위(후손) 선택자 : 하위 요소 선택. 띄어쓰기가 선택자의 기호 */ div .cat {   color: red; }  /* 인접 형제 선택자 : 다음 형제 요소 하나를 선택 */ .cat + li {   color: red; }  /* 일반 형제 선택자 : 다음 형제 요소 모두를 선택 */ .cat ~ li {   color: red; }       - 가상 클래스   /* hover : 마우스 커서가 올라가 있는 동안 */ a:hover {   color: red; }  /* active : 마우스를 클릭하고 있는 동안 */ a:active {   color: red; }  /* focus : 포커스되면 선택 */ /* focus가 될 수 있는 요소는 HTML 대화형 콘텐츠가 해당 */ /* input, a, button, label, select 등 여러 요소 */  /* HTML 대화형 콘텐츠 요소가 아니더라도, tabindex 속성을 사용한 요소도 focus가 될 수 있음 */  input:focus {   color: red; }  /* first-child : 형제 요소중 첫째라면 선택*/ .animals div:first-child {   color: red; }  /* last-child : 형제 요소중 막내라면 선택 */ .animals span:last-child {   color: red; }  /* nth-child : 형제 요소중 n째라면 선택 */ .animals *:nth-child(2) {   color: red; } .animals *:nth-child(2n) {   color: red; } .animals *:nth-child(2n+1) {   color: red; }  /* not : 아닌 요소 선택 */ .animals *:not(div) {   color: red; }       - 가상 요소   /* before : 내부 앞에 내용을 삽입 */ .cat::before {   content: \"앞\" }  /* after 내부 뒤에 내용을 삽입 */ .cat::after {   content: \"뒤\" }       - 속성   /* 속성 : 해당 속성을 포함한 요소 선택 */ [disabled] {   color: red; } [type] {   color: red; }  /* 속성-값 : 해당 속성을 포함하고 값이 x인 요소 선택 */ [type=\"password\"] {   color: red; }   스타일 상속   .animals {   color: red; }  &lt;div class=\"ecosystem\"&gt;생태계   &lt;div class=\"animals\"&gt;동물     &lt;div class=\"cat\"&gt;고양이&lt;/div&gt;     &lt;div class=\"dog\"&gt;강아지&lt;/div&gt;     &lt;div class=\"tiger\"&gt;호랑이&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"plant\"&gt;식물&lt;/div&gt; &lt;/div&gt;  생태계   동물     고양이     강아지     호랑이      식물       - 상속되는 CSS 속성들   모두 글자/문자 관련 속성들      font-style   font-weight   font-size   line-height   font-family   color   text-align   …       - 강제 상속      값에 inherit 넣어서 명시하면 상속됨   선택자 우선순위      같은 요소가 여러 선언의 대상이 된 경우, 어떤 선언의 CSS속성을 우선 적용할지 결정하는 방법   점수가 높은 선언 우선   점수가 같으면 마지막에 해석된 선언이 우선   body { color : red; } /* 전체 선택자 : 0점 */ * { color : orange; }  div { color : yellow; } /* 태그 선택자 : 1점 */  .cat { color: green; } /* Class 선택자 : 10점 */  #dog { color: blue; } /* ID 선택자 : 100점 */  &lt;div style=\"color: darkblue;\"&gt;Hi&lt;/div&gt; &lt;!-- 인라인 선언 : 1000점 --&gt;  div { color: purple !important; } /* !important : 999999점 */  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-basic/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 박스모델",
        "excerpt":"박스 모델   단위   px 픽셀 % 상대적 백분율 em 요소의 글꼴 크기 rem 루트 요소(html)의 글꼴 크기 vw 뷰포트 가로 너비의 백분율 vh 뷰포트 세로 너비의 백분율       width, height   /* 요소의 가로/세로 너비 */ width, height {   기본값: auto; 브라우저가 너비를 계산   단위: px, em, vw; }       max-width, max-height   /* 요소가 커질 수 있는 최대 가로/세로 너비 */ max-width, max-height {   기본값: none; 최대 너비 제한 없음   단위: px, em, vw; }       min-width, min-height   /* 요소가 작아질 수 있는 최소 가로/세로 너비 */ min-width, min-height {   기본값: 0; 최소 너비 제한 없음   단위: px, em, vw; }       margin   /* 요소의 외부 여백을 지정하는 단축 속성 */ margin {   기본값: 0;   auto 브라우저가 여백을 계산. 가운데 정렬에 활용   단위: px, em, vw; }   ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-boxmodel/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-1. 데이터 입출력 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 자료구조 – A   - 자료 구조의 정의      자료의 표현과 그것과 관련된 연산   자료들을 조직하고 구조화하는 것   필요한 모든 연산들을 처리할 수 있음   프로그램 실행시간이 달라짐   - 자료 구조의 분류      선형 구조            배열       선형 리스트                    연속 리스트           연결 리스트                       스택       큐       데크           비선형 구조            트리       그래프           - 배열(Array)      동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합   정적인 자료구조   기억장소 추가가 어려움   데이터 삭제 시 데이터가 저장되어 있던 기억장소가 빈 공간으로 남아있어 메모리 낭비 발생   첨자를 이용하여 데이터에 접근   반복적인 데이터 처리 작업에 적합한 구조   동일한 이름의 변수를 사용하여 처리가 간편   첨자의 개수에 따라 n차원 배열이라고 부름   - 선형 리스트(Linear List)      일정한 순서에 의해 나열된 자료 구조   배열을 이용하는 연속 리스트, 포인터를 이용하는 연결 리스트로 구분   @ 연속 리스트(Contiguous List)      연속되는 기억장소에 저장되는 자료 구조   기억장소 이용 효율은 밀도가 1로서 가장 좋음   데이터 삽입, 삭제 시 자료의 이동이 필요   @ 연결 리스트(Linked List)      자료들을 반드시 연속적으로 배열시키지 않고 노드의 포인터 부분을 이용해서 서로 연결   노드의 삽입, 삭제 작업이 용이   기억공간이 연속적으로 놓여있지 않아도 저장 가능   순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않음   포인터를 찾는 시간이 필요해 접근 속도가 느림   중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘듬   - 스택(Stack)      리스트의 한쪽 끝으로만 자료의 삽입, 삭제가 이루어짐   후입선출(LIFO)   기억공간이 꽉 차있는 상태에서 삽입되면 Overflow 발생   기억공간이 비어있는 상태에서 삭제하면 Underflow 발생   삽입(PUSH), 삭제(POP), 마지막 삽입 자료(Top), 밑바닥(Bottom)   - 큐(Queue)      리스트의 한쪽에서는 삽입, 다른 한쪽에서는 삭제가 이루어짐   선입선출(FIFO)   시작과 끝을 표시하는 두 개의 포인터가 있음   프런트(F, Front) 포인터 : 가장 먼저 삽입된 자료의 기억공간을 가리킴. 삭제 작업   리어(R, Rear) 포인터 : 가장 마지막에 삽입된 자료의 기억공간을 가리킴. 삽입작업   운영체제의 작업 스케줄링에 사용   - 트리(Tree)      정점(Node)과 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 형태   하나의 기억공간을 노드(Node), 노드와 노드를 연결하는 선을 링크(Link)   가족의 계보, 조직도 등을 표현하기 적합   노드 : 자료 항목과 다른 항목에 대한 가지를 합친 것   근 노드(Root Node) : 트리의 맨 위에 있는 노드   차수(Degree) : 각 노드에서 뻗어 나온 가지의 수   단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식이 하나도 없는 노드   자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들   부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들   형제 노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들   트리의 차수 : 노드들의 차수 중에서 가장 많은 수       2. 데이터저장소 / 데이터베이스 / DBMS – A   - 데이터저장소      데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것   논리 데이터 저장소 : 데이터 간 연관성, 제약조건을 식별하여 논리적인 구조로 조직화   물리 데이터 저장소 : 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장   데이터베이스를 구축하는 과정과 동일   - 데이터베이스      상호 관련된 데이터들의 모임   통합된 데이터(Integrated Data) : 중복을 배제한 데이터의 모임   저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료   운영 데이터(Operational Data) : 조직의 고유한 업무를 수행하는 데 없어서는 안 될 자료   공용 데이터(Shared Data) : 공동으로 소유하고 유지하는 자료   - DBMS(DataBase Management System)      사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 S/W   데이터의 종속성과 중복성의 문제를 해결   모든 응용 프로그램들이 DB를 공용할 수 있도록 관리   DB의 구성, 접근 방법, 유지관리에 대한 모든 책임을 짐   DBMS의 필수 기능            정의 기능 : 데이터 Type과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시       조작 기능 : 검색, 갱신, 삽입, 삭제 등의 인터페이스 수단을 제공       제어 기능 : 데이터의 무결성이 유지되도록 제어, 보안 유지, 권한 검사, 병행 제어           장점            데이터의 논리적, 물리적 독립성 보장       데이터의 중복을 피할 수 있어 기억 공간 절약       자료를 공동으로 이용할 수 있음       데이터의 일관성을 유지할 수 있음       데이터의 무결성을 유지할 수 있음       보안을 유지할 수 있음       데이터를 표준화 할 수 있음       통합 관리가 가능       최신의 데이터 유지 가능       실시간 처리 가능           단점            DB 전문가 부족       전산화 비용 증가       Overhead 발생       Backup과 Recovery이 어려움       시스템이 복잡           - 데이터의 독립성      데이터의 독립성은 DBMS의 궁극적 목표   논리적 독립성 : 데이터의 논리적 구조를 변경해도 응용 프로그램은 변경되지 않음   물리적 독립성 : 응용 프로그램에는 영향을 주지 않고, 데이터의 물리적 구조만을 변경       3. 데이터 입출력 – B   - 데이터 입출력 개요      DB에 데이터를 입력하거나 출력하는 작업   데이터를 조작하는 모든 행위를 의미. SQL 사용   개발 코드 내에 SQL 코드를 삽입하거나, 객체와 데이터를 연결하는 데이터 접속(Data Mapping)   논리적 기능을 수행하기 위한 작업의 단위 또는 한번에 수행되야 할 연산들을 트랜잭션이라고 함   - SQL(Structured Query Language)      많은 회사에서 관계형 데이터베이스(RDB)를 지원하는 언어로 채택   관계대수와 관계해석을 기초로 한 혼합 데이터   질의어지만 질의 기능뿐만 아니라, 데이터 구조 정의, 조작, 제어기능을 모두 갖춤   데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 구분            DDL : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의, 변경, 삭제       DML : 저장된 데이터를 실질적으로 처리       DCL : 보안, 무결성, 회복, 병행수행 제어 등을 정의하는데 사용           - 데이터 접속(Data Mapping)      프로그래밍 코드와 DB의 데이터를 연결하는 것   SQL Mapping : 코드 내에 SQL을 직접 입력하여 DBMS 객체에 접속. JDBC, ODBC, MyBatis   ORM(Object-Relational Mapping) : 객체와 RDB의 데이터를 연결. JPA, Hibernate, Django   - 트랜잭션(Transaction)      DB 상태를 변환시키는 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행돼야 할 연산   TCL : 트랜잭션을 제어하기 위한 명령어. COMMIT, ROLLBACK, SAVEPOINT            COMMIT : 트랜잭션이 수행한 변경 내용을 DB에 저장       ROLLBACK : 모든 변경 작업을 취소하고 이전 상태로 되돌림       SAVEPOINT(=CHECKPOINT) : ROLLBACK 할 저장점을 지정               4. 절차형 SQL – B   - 절차형 SQL 개요      프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL   프로그래밍 언어에 비해 효율은 떨어지지만, 연속적인 작업들을 처리하는데 적합   다양한 기능을 수행하는 저장 모듈 생성할 수 있음   DBMS 엔진에서 직접 실행돼 입출력 패킷이 적은 편   BEGIN ~ END 형식의 블록 구조로 되어 있어 기능별 모듈화 가능   프로시저 : 트랜잭션 언어, 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업 수행   트리거 : 이벤트가 발생할 때마다 관련 작업이 자동으로 수행   사용자 정의 함수 : 예약어 RETURN을 사용하여 처리 결과를 단일값으로 반환   - 절차형 SQL의 테스트와 디버깅      디버깅을 통해 기능의 적합성 여부를 검증, 실행을 통해 결과를 테스트   테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부 확인   SHOW  명령어를 통해 내용을 확인하고 문제를 수정   디버깅을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인   DB에 변화를 줄 수 있는 삽입 등의 SQL 문을 주석으로 처리하고, 출력문을 이용해 확인   - 쿼리 성능 최적화      데이터 입출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화   성능 측정 도구인 APM을 사용하여 최적화 할 쿼리 선정   옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp5/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-2. 통합 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 단위 모듈 테스트 – B   - 단위 모듈 테스트의 개요      모듈이 정해진 기능을 정확히 수행하는지 검증   단위 테스르라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법 사용   모듈을 단독적으로 실행할 수 있는 환경과 테스트에 필요한 데이터 모두 준비   에러를 쉽게 발견하고 수정할 수 있음   시스템 수준의 오류는 잡아낼 수 없음   - 테스트 케이스      사용자의 요구사항을 정확하게 준수했는지를 확인하기 위함   테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당   직관적인 테스트는 검증이 누락되거나 불필요한 반복으로 인력과 시간을 낭비 할 수 있음   ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스 구성 요소            식별자       테스트 항목       입력 명세       출력 명세       환경 설정       특수 절차 요구       의존성 기술           - 테스트 프로세스      게획 및 제어 -&gt; 분석 밀 설계 -&gt; 구현 및 실현 -&gt; 평가 -&gt; 완료       2. 개발 지원 도구 – B   - 통합 개발 환경(IDE; Integrated Development Environment)      편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공   통합 개발 환경을 제공하는 S/W   코드의 자동 생성 및 컴파일 가능, 추가 기능을 위한 도구를 추가할 수 있음   오류가 발생할 부분을 시각화하므로 수정이 용이   다양한 서비스와 연동하여 개발에 편의를 제공하고 필요한 정보를 공유   이클립스, 비주얼 스튜디오, 엑스 코드, 안드로이드 스튜디오, IDEA 등   - 빌드 도구      빌드는 소스 코드 파일들을 실행할 수 있는 제품 S/W로 변환하는 과정 또는 결과물   전처리, 컴파일 등의 작업들을 수행하는 S/W   Ant            자바 프로젝트의 공식 빌드 도구       XML 기반의 빌드 스크립트, 자유도와 유연성이 높음       개발자가 모든 것을 정의, 스크립트 재사용이 어려움           Maven            Ant의 대안으로 개발됨       규칙이나 표준이 존재하여 예외 사항만 기록, 컴파일과 빌드를 동시에 수행       의존성을 설정하여 라이브러리를 관리           Gradle            Ant와 Mavn을 보완하여 개발       안드로이드 스튜디오의 공식 빌드 도구       의존성을 활용하여 Groovy 기반의 빌드 스크립트 사용           - 기타 협업 도구      서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구   업무 보조 도구 포함   다양한 플랫폼에서 사용할 수 있도록 제공   익숙하지 않거나 이용할 의지가 없으면 오히려 협업의 방해 요소가 될 수 있음   협업 도구 종류            일정 관리 : Google Calendar, Wunderlist, Trello, Jira, Flow       정보 공유 및 커뮤니케이션 : Slack, Jandi, Taskworld       디자인 : Sketch, Zeplin       기타 : Evernote(아이디어 공유), Swagger(API 문서화로 협업도움), Github          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp6/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-3. 제품 소프트웨어 패키징",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 패키징 – B   - 소프트웨어 패키징의 개요      모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것   사용자를 중심으로 진행   모듈화하여 패키징   일반적인 배포 형태로 패키징   사용자의 편의성 및 실행 환경을 우선적으로 고려   - 패키징 시 고려사항      사용자의 시스템 환경에 필요한 최소 환경을 정의   UI는 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 매뉴얼과 일치   하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공   편의성을 고려한 안정적인 배포가 중요   패키징의 변경 및 개선에 대한 관리를 항상 고려   - 패키징 작업 순서      애자일 기법의 경우 2~4주 내에서 지정하며, 각 주기가 끝날 때마다 패키징 수행   주기별로 패키징한 결과물은 테스트 서버에 배포   최종 패키징한 결과물은 사용할 수 있도록 온라인 또는 오프라인으로 배포   기능 식별 -&gt; 모듈화 -&gt; 빌드 -&gt; 사용자 환경 분석 -&gt; 패키징 및 적용시험 -&gt; 패키징 변경 개선 -&gt; 배포       2. 릴리즈 노트 작성 – B   - 릴리즈 노트의 개요      릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서   테스트 진행 방법에 대한 결과와 S/W 사양에 대한 개발팀의 정확한 준수 여부 확인 가능   전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유   버전 관리나 릴리즈 정보를 체계적으로 관리   초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시에 제공   포함된 기능이나 사용 환경에 대한 내용을 확인   개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공   철저한 테스트를 거친 것, 사양에 대한 최종 승인을 얻은 후 문서화 되어 제공   - 릴리즈 노트 초기 버전 작성 시 고려사항      정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성   변경 또는 개선된 항목에 대한 이력 정보들도 작성   표준 형식은 없음   - 릴리즈 노트 추가 버전 작성 시 고려사항      특수한 상황이 발생하는 경우 릴리즈 노트를 추가로 작성   모든 수정된 내용을 담아 릴리즈 노트를 작성   기능 업그레이드를 완료한 경우에는 릴리즈 버전을 출시하고 릴리즈 노트를 작성   요구사항에 의해 추가나 수정된 경우 별도의 릴리즈 버전으로 출시하고 릴리즈 노트 작성   - 릴리즈 노트 작성 순서      모듈 식별 -&gt; 릴리즈 정보 확인 -&gt; 릴리즈 노트 개요 작성 -&gt; 영향도 체크 -&gt; 정식 릴리즈 노트 작성 -&gt; 추가 개선 항목 식별       3. 디지털 저작권 관리(DRM) – A      저작권이란 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한   복제하기 쉬운 저작물에 대해 이를 막기 위한 기술적인 방법을 통칭해 저작권 보호 기술이라 함   - 디지털 저작권 관리(DRM; Digital Right Management)의 개요      디지털 콘텐츠 관리 및 보호 기술   원본 콘텐츠가 아날로그인 경우 디지털로 변환한 후 패키저로 DRM 패키징 수행   크기가 작은 경우 실시간 패키징 수행, 크기가 큰 경우 미리 패키징 수행 후 배포   패키징을 수행하면 암호화된 전자서명이 포함되고 라이선스 정보가 클리어링 하우스에 등록   콘텐츠를 사용하기 위해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인   종량제 방식을 적용한 경우 실제 사용량을 측정하여 이용한 만큼의 요금 부과   - 디지털 저작권 관리의 흐름도      클리어링 하우스 : 저작권에 대한 사용 권한, 라이선스 발급, 결제 관리 등 수행   콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자   패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램   콘텐츠 분배자 : 암호화된 콘텐츠를 유통하는 곳이나 사람   콘텐츠 소비자 : 콘텐츠를 구매해서 사용하는 주체   DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램   보안 컨테이너 : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치   - 디지털 저작권 관리의 기술 요소      암호화(Encryption) : 콘텐츠를 암호화하고 전자 서명을 할 수 있는 기술   키 관리(Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술   암호화 파일 생성(Packager) : 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술   식별 기술(Identification) : 콘텐츠에 대한 식별 체계 표현 기술   저작권 표현(Right Expression) : 라이선스의 내용 표현 기술   정책 관리(Policy Management) : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술   크랙 방지(Tamper Resistance) : 크랙에 의한 콘텐츠 사용 방지 기술   인증(Authentication) : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술       4. 소프트웨어 버전 등록 – B   - 소프트웨어 패키징의 형상 관리      형상관리(SCM)는 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동   S/W 변경의 원인을 알아내고 제어, 적절히 변경되고 있는지 확인하며 해당 담당자에게 통보   S/W 개발의 전 단계에 적용되는 활동. 유지보수 단계에서도 수행   S/W 개발의 전체 비용을 줄이고, 방해 요인이 최소화되도록 보증   - 형상 관리의 중요성      변경 사항을 체계적으로 추적하고 통제할 수 있음   무절제한 변경을 방지할 수 있음   발견된 버그나 수정 사항을 추적할 수 있음   S/W는 형태가 없어 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로 사용   - 형상 관리 기능      형상 식별 : 이름과 관리 번호를 부여, Tree 구조로 구분하여 수정 및 추적이 용이하도록 함   버전 제어 : 다른 버전의 형상 항목을 관리, 특정 절차와 도구를 결합   형상 통제 : 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정   형상 감사 : 기준선의 무결성을 평가하기 위해 공식적으로 승인하는 작업   형상 기록 : 결과를 기록, 관리하고 보고서를 작성하는 작업   - 소프트웨어의 버전 등록 관련 주요 용어      Repository : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장   Import : 아무것도 없는 저장소에 처음으로 파일을 복사   Check-Out : 저장소에서 파일을 받아옴. 버전관리를 위한 파일들도 받아옴   Check-In : 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신   Commit : 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료   Update : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화   - 소프트웨어 버전 등록 과정      Import -&gt; Check-Out -&gt; Commit -&gt; Update -&gt; Diff       5. 소프트웨어 버전 관리 도구 – A   - 공유 폴더 방식      로컬 컴퓨터의 공유 폴더에 저장되어 관리   약속된 공유 폴더에 매일 복사   담당자는 파일을 자기 PC로 복사한 후 컴파일 하여 이상 유무를 확인   파일 오류가 확인되면, 개발자에게 수정 의뢰   이상 없으면 개발자들이 동작 여부 다시 확인   파일의 변경 사항을 DB에 기록하여 관리   SCCS, RCS, PVCS, QVCS   - 클라이언트/서버 방식      버전 관리 자료가 중앙 시스템에 저장되어 관리되는 방식   서버의 자료를 PC로 복사하여 작업한 후 변경된 내용을 서버에 반영   모든 버전 관리는 서버에서 수행   하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력   서버에 문제가 생기면 협업 및 버전 관리 작업 중단   CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce   @ Subversion(서브버전, SVN)      CVS를 개선한 것   서버에는 최신 버전의 파일들과 변경 내역이 관리   서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영   모든 개발 작업은 trunk 디렉터리에서 수행   추가 작업은 branches 디렉터리 안에 별도의 디렉터리 만들어 작업   완료후 trunk 디렉터리와 병합   커밋 할 때마다 리비전이 1씩 증가   서버는 주로 유닉스 사용   소스가 오픈되어 있어 무료로 사용 가능   CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능   - 분산 저장소 방식      하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리   작업한 후 변경된 내용을 로컬에서 우선 반영한 후, 이를 원격 저장소에 반영   원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업할 수 있음   @ Git      로컬 저장소와 원격 저장소 존재   로컬 저장소는 실제 개발을 진행하는 장소로, 버전 관리가 수행   원격 저장소는 버전을 공동 관리하는 곳   버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업 가능   branch를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능   파일의 변화를 스냅샷으로 저장. 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름 파악 가능       6. 빌드 자동화 도구 – B   - 빌드 자동화 도구의 개념      빌드란 소스 코드 파일들을 컴파일한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정   빌드 자동화 도구는 빌드를 포함하여 테스트 및 배포를 자동화하는 도구   애자일 환경같은 지속적인 통합 개발 환경에서 유용하게 활용   - Jenkins      Jenkins는 Java 기반의 오픈소스 형태, 가장 많이 사용되는 빌드 자동화 도구   서블릿 컨테이너에서 실행되는 서버 기반 도구   SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능   친숙한 Web GUI 제공으로 사용이 쉬움   여러 대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능   - Gradle      Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구. 안드로이드 앱 개발 환경에서 사용   플러그인을 설정하면 Java, C/C++, Python 등의 언어도 빌드 가능   Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용   실행할 처리 명령을 모아 Task로 만든 후 Task 단위로 실행   Task를 재사용하거나 공유할 수 있는 빌드 캐시 기능을 지원해 빌드의 속도를 향상시킬 수 있음  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp7/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-4. 애플리케이션 테스트 관리",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 애플리케이션 테스트 – B   - 애플리케이션 테스트의 개념      잠재되어 있는 결함을 찾아내는 일련의 행위   고객의 요구사항을 만족시키는지 확인(Validation)   기능을 정확히 수행하는지 검증(Verrfication)   개발할 소프트웨어의 유형을 분류하고 특성을 정리해서 중점적으로 테스트할 사항을 정리   - 애플리케이션 테스트의 필요성      프로그램 실행 전에 오류를 발견하여 예방   제품의 신뢰도 향상   새로운 오류의 유입 예방   최소한의 시간과 노력으로 많은 결함을 찾아낼 수 있음   - 애플리케이션 테스트의 기본 원리      잠재적인 결함은 줄일 수 있지만 완벽한 소프트웨어 테스팅은 불가능   결함 대부분은 특정 모듈에 집중. 20%의 코드에서 80%의 결함이 발견. 파레토 법칙 적용   동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 살충제 패러독스 발생   정황에 따라 테스트를 다르게 수행   결함을 제거해도 요구사항을 만족시키지 못하면 품질이 높다고 말할 수 없음. 오류 부재의 궤변   테스트와 위험은 반비례   작은 부분에서 시작하여 점점 확대하며 진행   개발자와 관계없는 별도의 팀에서 수행       2. 애플리케이션 테스트의 분류 – B   - 프로그램 실행 여부에 따른 테스트   @ 정적 테스트      프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석   개발 초기에 결함 발견 가능. 개발 비용을 낮출 수 있음   워크스루, 인스펙션, 코드 검사 등   @ 동적 테스트      프로그램을 실행하여 오류를 찾는 테스트. 개발 모든 단계에서 수행 가능   블래박스 테스트, 화이트박스 테스트   - 테스트 기반에 따른 테스트   @ 명세 기반 테스트      요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인   동등 분할, 경계 값 분석 등   @ 구조 기반 테스트      내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인   구문 기반, 결정 기반, 조건 기반 등   @ 경험 기반 테스트      유사 소프트웨어나 기술 등에 대한 경험을 기반으로 함   요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 효과적   에러 추정, 체크 리스트, 탐색적 테스팅   - 시각에 따른 테스트   @ 검증(Verification) 테스트      개발자의 시각에서 명세서대로 완성됐는지 테스트   @ 확인(Validation) 테스트      사용자의 시각에서 요구한대로 제품이 완성됐는지, 정상 동작하는지 테스트   - 목적에 따른 테스트   @ 회복 테스트      결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인   @ 안전 테스트      불법적인 침입으로부터 시스템을 보호할 수 있는지 확인   @ 강도 테스트      과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 정상적으로 실행되는지 확인   @ 성능 테스트      실시간 성능이나 전체적인 효율성을 진단하는 테스트   @ 구조 테스트      내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트   @ 회귀 테스트      변경 또는 수정된 코드에 새로운 결함이 없음을 확인   @ 병행 테스트      기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교       3. 테스트 기법에 따른 애플리케이션 테스트 – A   - 화이트박스 테스트      원시 코드를 오픈시킨 상태에서 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계   구조적 테스트. 프로시저 설계의 제어 구조를 사용하여 테스트 케이스를 설계   테스트 과정의 초기에 적용   모듈 안의 작동을 직접 관찰   모든 문장을 한 번 이상 실행하여 수행   선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어   - 화이트박스 테스트의 종류   @ 기초 경로 검사      대표적인 화이트박스 테스트 기법   절차적 설계의 논리적 복잡성을 측정할 수 있게 해줌   실행 경로의 기초를 정의하는 데 지침으로 사용   @ 제어 구조 검사      조건 검사 : 논리적 조건을 테스트하는 설계 기법   루프 검사 : 반복 구조에 초점을 맞춰 실시하는 설계 기법   데이터 흐름 검사 : 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 설계 기법   - 화이트박스 테스트의 검증 기준      문장 검증 기준 : 모든 구문이 한 번 이상 수행되도록 설계   분기 검증 기준 : 모든 조건문이 한 번 이상 수행되도록 설계   조건 검증 기준 : 모든 조건문에 대해 조건문이 True, False 경우가 한 번 이상 수행되도록 설계   분기/조건 기준 : 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True, False인 경우가 한 번 이상 수행되도록 설계   - 블랙박스 테스트      각 기능이 완전히 작동되는 것을 입증하는 테스트. 기능 테스트   요구사항 명세서를 보면서 테스트하는 것. 구현된 기능을 테스트   인터페이스에서 실시되는 테스트   테스트 과정의 후반부에 적용   - 블랙박스 테스트의 종류   @ 동치 분할 검사      입력 자료에 초점을 맞춰 검사   타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 함. 자료에 맞는 결과가 출력되는지 확인   @ 경계값 분석      동치 분할 기법을 보완하기 위함   중간값보다 경계값에서 오류가 발생될 확률이 높다는 점 이용   입력 조건의 경계값을 테스트 케이스로 선정하여 검사   @ 원인-효과 그래프 검사      입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 후 효용성 높은 케이스 선정하여 검사   @ 오류 예측 검사      과거의 경험이나 확인자의 감각으로 테스트   보충적 검사 기법. 데이터 확인 검사   @ 비교 검사      여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트       4. 개발 단계에 따른 애플리케이션 테스트 – A   - 개발 단계에 따른 애플리케이션 테스트      코드 상의 오류뿐만 아니라 요구 분석의 오류, 설계 인터페이스 오류 등도 발견할 수 있음   애플리케이션 테스트 + 소프트웨어 개발 단계 = V-모델   요구사항 -&gt; 분석 -&gt; 설계 -&gt; 구현 -&gt; // 단위테스트 -&gt; 통합테스트 -&gt; 시스템티스트 -&gt; 인수테스트   - 단위 테스트(Unit Test)      설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트   사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행   구조 기반 테스트와 명세기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행            구조 기반 테스트 : 화이트박스 테스트       명세 기반 테스트 : 블랙박스 테스트           - 통합 테스트(Integration Test)      단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트   모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사   - 시스템 테스트(System Test)      개발된 S/W가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검   실제 사용 환경과 유사하게 만든 테스트 환경에서 수행   기능적 요구사항 : 블랙박스 테스트 시행   비기능적 요구사항 : 화이트박스 테스트 시행   - 인수 테스트(Acceptance Test)      개발한 S/W가 사용자의 요구사항을 충족하는지에 중점   사용자가 직접 테스트   문제가 없으면 사용자는 S/W를 인수하고 프로젝트 종료   사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부 확인   운영상의 인수 테스트 : 시스템 관리자가 수행   계약 인수 테스트 : 계약상의 인수/검수 조건을 준수하는지 여부 확인   규정 인수 테스트 : 규정에 맞게 개발되었는지 확인   알파 테스트            개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트       통제된 환경에서 시행. 문제점을 사용자와 개발자가 함께 확인           베타 테스트            최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트       사용자가 직접 테스트       개발자에 의해 제어되지 않은 상태에서 테스트       오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고               5. 통합 테스트 – A      단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트   비점진적 통합 방식            모든 모둘이 미리 결합되어 있는 프로그램 전체를 테스트. 빅뱅 통합 테스트       규모가 작은 소프트웨어에 유리. 단시간 내에 테스트 가능       오류 발견 및 장애 위치 파악 및 수정이 어려움           점진적 통합 방식            모듈 단위로 단계적으로 통합하면서 테스트. 하향식, 상향식, 혼합식       오류 수정이 용이하고, 인터페이스와 연관된 오류를 완전히 테스트 할 가능성 높음           - 하향식 통합 테스트      상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트   깊이 우선 통합법이나 넓이 우선 통합법 사용   테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음   상위 모듈에서는 테스트 케이스를 사용하기 어려움   절차            주요 제어 모듈은 작성된 프로그램 사용. 종속 모듈은 Stub으로 대체       하위 모듈인 Stub들이 한 번에 하나씩 실제 모듈로 교체됨       모듈이 통합될 때마다 테스트를 실시       새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시           - 상향식 통합 테스트      하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트   Stub은 필요하지 않지만, 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 Cluster가 필요 -절차            하위 모듈들을 Cluster로 결합       더미 모듈인 Driver를 작성       통합된 클러스터 단위로 테스트       테스트가 완료되면 Cluster는 프로그램 구조의 상위로 이동하여 결합하고 Driver는 실제 모듈로 대체           - 테스트 Driver와 Stub의 차이점                  구분       Driver       Stub                       필요시기       상위 모듈 없음       하위 모듈 없음                 테스트방식       상향식       하향식                 공통점       소프트웨어 개발과 테스트를 병행할 경우 이용                         차이점       인터페이스 역할, 원래 모듈로 교체       가짜 모듈의 역할, 작성하기 쉬움           - 혼합식 통합 테스트      하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합. 샌드위치식 통합 테스트 방법   - 회귀 테스팅      이미 테스트된 프로그램의 테스팅을 반복하는 것   변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트   반복해서 테스트 함   변경된 부분을 테스트할 수 있는 테스트 케이스만을 선정하여 수행   대표적인 테스트 케이스를 선정   파급 효과가 높은 부분이 포함된 테스트 케이스를 선정   실제 수정이 발생한 모듈 또는 컴포넌트에서 시행하는 테스트 케이스 선정       6. 애플리케이션 테스트 프로세스 – B   - 애플리케이션 테스트 프로세스      사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트   계획 -&gt; 분석 및 디자인 -&gt; 테스트 케이스 및 시나리오 작성 -&gt; 수행 -&gt; 결과 평가 및 리포팅 -&gt; 결함 추적 및 관리       7. 테스트 케이스 / 테스트 시나리오 / 테스트 오라클 – B   - 테스트 케이스      구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 명세 기반 테스트의 설계 산출물   검토 및 자료확보 -&gt; 위험 평가 및 우선순위 결정 -&gt; 요구사항 정의 -&gt; 구조 설계 및 방법 결정 -&gt; 테스트 케이스 정의 -&gt; 타당성 확인 및 유지 보수   - 테스트 시나리오      테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합. 구체적인 절차를 명세한 문서   테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정   테스트 순서를 미리 정함으로써 테스트 항목을 빠짐없이 수행   작성시 유의사항            여러 개의 시나리오로 분리하여 작성       사용자의 요구사항과 설계 문서 등을 토대로 작성       유스케이스간 업무 흐름이 정상적인지를 테스트 할 수 있도록 작성       개발된 모듈 또는 프로그램 간의 연계가 정상적으로 동작하는지 테스트할 수 있도록 작성           - 테스트 오라클      테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법   결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 게산하거나 확인   특징            제한된 검증 : 모든 테스트 케이스에 적용할 수 없음       수학적 기법 : 수학적 기법을 이용하여 구할 수 있음       자동화 가능 : 실형, 결과 비교, 커버리지 측정 등을 자동화 할 수 있음           종류            참 오라클 : 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공. 모든 오류 검출       샘플링 오라클 : 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과 제공       추정 오라클 : 샘플링 오라클 개선. 나머지 입력 값들에 대해서 추정으로 처리       일관성 검사 : 변경이 있을 때, 수행 전과 후의 결과 값이 동일한지 확인               8. 테스트 자동화 도구 – B   - 테스트 자동화의 개념      반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용한 것   휴먼 에러를 줄이고 테스트 정확성을 유지하면서 품질을 향상시킴   - 테스트 자동화 도구의 장점 / 단점      장점            반복적인 작업을 자동화하여 인력 및 시간을 줄임       향상된 테스트 품질 보장       요구사항 등을 일관성 있게 검증       객관적인 평가 기준을 제공       다양한 표시 형태로 제공       UI가 없는 서비스도 정밀 테스트 가능           단점            도구의 사용 방법에 대한 교육 및 학습 필요       프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요       비공개 상용 도구의 경우 고가의 추가 비용 필요           - 테스트 자동화 수행 시 고려사항      재사용 및 측정이 불가능한 테스트 프로그램은 제외   용도에 맞는 적절한 도구를 선택해서 사용   환경 설정 및 습득 기간을 고려해서 프로젝트 일정을 계획   프로젝트 초기에 테스트 엔지니어의 투입 시기를 계획   - 테스트 자동화 도구의 유형      정적 분석 도구            프로그램을 실행하지 않고 분석       작성된 소스 코드를 이해하고 있어야만 분석 가능           테스트 실행 도구            스크립트 언어를 사용하여 테스트를 실행       데이터 주도 접근 방식       키워드 주도 접근 방식           성능 테스트 도구            인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부 확인           테스트 통제 도구            테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행       형상 관리 도구, 결함 추적/관리 도구 등           테스트 하네스 도구            애플리케이션의 컴포넌트 및 모듈을 테스트하는 환경의 일부분       테스트를 지원하기 위해 생성된 코드와 데이터를 의미       테스트가 실행될 환경을 시뮬레이션 하여 정상적으로 테스트되도록 함       구성 요소                    테스트 드라이버 : 모듈 테스트 수행 후의 결과를 도출           테스트 스텁 : 타 모듈의 기능을 단순히 수행하는 도구           테스트 슈트 : 테스트 케이스의 집합           테스트 케이스 : 테스트 항목의 명세서           테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서           목 오브젝트 : 예정된 행위를 수행하는 객체                               9. 결함 관리 – B   - 결함의 정의      설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것   - 결함 관리 프로세스      계획 -&gt; 기록 -&gt; 검토 -&gt; 수정 -&gt; 재확인 -&gt; 추적 및 모니터링 -&gt; 분석 및 보고서 작성   - 결함 추적 순서      등록 -&gt; 검토 -&gt; 할당 -&gt; 수정 -&gt; 조치 보류 -&gt; 종료 -&gt; 해제   - 결함 관리 도구      Mantis : 단위별 작업 내용 기록하여 결함 추적 가능   Trac : 결함 추적은 물론 결함을 통합하여 관리   Redmine : 프로젝트 관리 및 결함 추적 가능   Bugzilla : 결함을 지속적으로 관리할 수 있는 도구. 결함의 심각도와 우선 순위 지정 가능  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp8/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-5. 인터페이스 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 모듈 연계를 위한 인터페이스 기능 식별 – A   - 모듈 연계의 개요      모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것   @ EAI(Enterprise Application Integration)      기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션   비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확장성을 높임   Point-to-Point            1 : 1 연결       변경 및 재사용이 어려움           Hub &amp; Spoke            허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식       확장 및 유지 보수가 용이       허브 장애 발생 시 시스템 전체에 영향을 미침           Message Bus(ESB 방식)            미들웨어를 두어 처리하는 방식       확장성이 뛰어나며 대용량 처리가 가능           Hybrid            Hub &amp; Spoke와 Message Bus의 혼합 방식       그룹 내에서는 Hub &amp; Spoke, 그룹 간에는 Message Bus 방식 사용       한 가지 방식으로 EAI 구현 가능       데이터 병목 현상을 최소화           @ ESB(Enterprise Service Bus)      애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션   통합 측면에서 EAI와 유사하지만, 애플리케이션 보다는 서비스 중심의 통합을 지향   특정 서비스에 국한되지 않고 범용적으로 사용하기 위해 결합도를 약하게 유지   관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원 가능       2. 인터페이스 기능 구현 정의 – B   - 인터페이스 기능 구현 정의에 대한 개요      인터페이스를 실제로 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술   컴포넌트 명세서 확인 -&gt; 인터페이스 명세서 확인 -&gt; 일관된 인터페이스 기능 구현 정의 -&gt; 정의된 인터페이스 기능 구현 정형화   - 모듈 세부 설계서      모듈의 구성 요소와 세부적인 동작 등을 정의한 설계서   컴포넌트 명세서            컴포넌트의 개요 및 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세 등을 정의           인터페이스 명세서            컴포넌트 명세서의 항목 중 인터페이스 클래스의 세부 조건 및 기능 등을 정의               3. 인터페이스 예외 처리 – B   - 인터페이스 예외 처리의 개요      구현된 인터페이스가 동작하는 과정에서 기능상 예외 상황이 발생 했을 때 이를 처리하는 절차   - 데이터 통신을 이용한 인터페이스 예외 처리      JSON, XML 등 인터페이스 객체를 이용해 구현한 인터페이스 동작이 실패한 경우를 대비   예외 케이스를 정의하고 각 예외 케이스마다 예외 처리 방법을 기술   - 인터페이스 엔티티를 이용한 인터페이스 예외 처리      동작이 실패할 경우를 대비해 해당 엔티티에 인터페이스의 실패 상황과 원인 등을 기록하고 사용자 및 관리자에서 알려주는 방식       4. 인터페이스 보안 – B   - 인터페이스 보안의 개요      보안 취약점을 분석한 후 적절한 보안 기능을 적용   - 인터페이스 보안 기능 적용      네트워크 영역            스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화 설정       IPSec, SSL, S-HTTP 등의 방식으로 적용           애플리케이션 영역            애플리케이션 코드 상의 보안 취약점을 보완하는 방향           데이터베이스 영역            접근 권한과 프로시저, 트리거 등 DB 동작 객체의 보안 취약점에 보안 기능을 적용       암호화나 익명화 등 데이터 자체의 보안 방안도 고려               5. 연계 테스트 – B   - 연계 테스트의 개요      연계 시스템과 구성 요소가 정상적으로 동작하는지 확인하는 활동   연계 테스트 케이스 작성 -&gt; 연계 테스트 환경 구축 -&gt; 수행 -&gt; 검증       6. 인터페이스 구현 검증 – A   - 인터페이스 구현 검증의 개요      인터페이스가 정상적으로 문제없이 작동하는지 확인하는 것   - 인터페이스 구현 검증 도구      검증하기 위해서 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 통합 테스트 필요   테스트 자동화 도구를 이용하면 효율적으로 수행 가능   xUnit            Java, C++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크           STAF            서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원           FItNesse            웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원           NTAF            협업 기능과 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크           Selenium            다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크           watir            Ruby를 사용하는 애플리케이션 테스트 프레임워크           - 인터페이스 구현 감시 도구      인터페이스 동작 상태를 APM을 사용하여 모니터링 할 수 있음   종합적인 정보를 조회하고 분석할 수 있음   Scouter, Jennifer 등   APM            리소스 방식 : Nagios, Zabbix, Cacti 등       End-to-End 방식 : VisualVM, Jennifer, Scouter 등          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp9/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-1. 논리 데이터베이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 데이터베이스 설계 – A   - 데이터베이스 설계의 개념      DB 구조에 맞게 변형한 후 DBMS로 DB를 구현하여 일반 사용자들이 사용하게 하는 것   - 데이터베이스 설계 시 고려사항      무결성 : 저장된 데이터가 정해진 제약 조건을 항상 만족   일관성 : 특정 질의에 대한 응답이 처음부터 끝까지 일정해야 함   회복 : 장애 발생 직전의 상태로 복구할 수 있어야 함   보안 : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호   효율성 : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화   DB 확장 : 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함   - 데이터베이스 설계 순서      요구조건 분석 -&gt; 개념적 설계 -&gt; 논리적 설계 -&gt; 물리적 설계 -&gt; 구현   - 요구 조건 분석      DB를 사용할 사람들로부터 필요한 용도를 파악하는 것   사용자에 따른 수행 업무와 필요 데이터 수집   요구 조건 명세서 작성   - 개념적 설계(정보 모델링, 개념화)      현실 세계에 대한 인식을 추상적 개념으로 표현   개념 스키마 모델링과 트랜잭션 모델링을 병행 수행   DBMS에 독립적인 E-R 다이어그램으로 작성   DBMS에 독립적인 개념 스키마 설계   - 논리적 설계(데이터 모델링)      특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정   논리적 구조의 데이터로 모델화   개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계   트랜잭션의 인터페이스를 설계   RDB라면 테이블을 설계하는 단계   - 물리적 설계(데이터 구조화)      논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환   DB 파일의 저장 구조 및 액세스 경로 결정   데이터가 컴퓨터에 저장되는 방법을 묘사   - 데이터베이스 구현      도출된 데이터베이스 스키마를 파일로 생성하는 과정   DDL을 이용하여 DB 스키마를 기술한 후 컴파일하여 빈 DB 파일 생성   빈 DB 파일에 데이터 입력   응용 프로그램을 위한 트랜잭션 작성   DB 접근을 위한 응용 프로그램 작성       2. 데이터 모델의 개념 – B   - 데이터 모델의 정의      현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형   데이터 모델 구성 요소 : 객체, 속성, 관계   데이터 모델 종류 : 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델   데이터 모델에 표시할 요소 : 구조, 연산, 제약 조건   - 데이터 모델의 구성 요소      개체(Entity) : 현실 세계의 대상체   속성(Attribute) : 데이터의 가장 작은 논리적 단위. 데이터 항목 또는 데이터 필드에 해당   관계(Relationship) : 개체 간의 관계 또는 속성 간의 논리적인 연결   - 개념적 데이터 모델      현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정   타입들 간의 관계를 이용하여 현실 세계를 표현   정보 모델이라고도 함   E-R 모델   - 논리적 데이터 모델      개념적 구조를 컴퓨터가 처리할 수 있도록 변환하는 과정   데이터 타입과 이들간의 관계를 이용하여 현실 세계를 표현   특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용   관계 모델, 계층 모델, 네트워크 모델   - 데이터 모델에 표시할 요소      구조 : 데이터 구조 및 정적 성질   연산 : 실제 데이터를 처리하는 작업에 대한 명세   제약 조건 : 실제 뎅터의 논리적인 제약 조건       3. 데이터 모델의 구성요소 - 개체(Entity) – A   - 개체의 정의 및 특징      DB에 표현하려는 것. 현실 세계의 대상체   어떤 정보를 제공하는 역할   영속적으로 존재하는 개체의 집합   독립적으로 존재하거나 그 자체로서도 구별 가능   유일한 식별자에 의해 식별 가능   업무 프로세스에 의해 이용됨   다른 개체와 하나 이상의 관계가 있음   - 개체명 지정 방법      해당 업무에서 사용하는 용어로 지정   약어 사용은 제한   단수 명사 사용   개체명은 유일해야 함   의미에 따라 이름을 부여       4. 데이터 모델의 구성요소 - 속성(Attribute) – B   - 속성의 정의 및 특징      DB를 구성하는 가장 작은 논리적 단위   데이터 항목 또는 데이터 필드에 해당   개체를 구성하는 항목   개체의 특성을 기술   속성의 추를 Degree 또는 차수라고 함   - 속성의 종류   @ 속성의 특성에 따른 분류      기본 속성            업무 분석을 통해 정의한 속성       가장 많고 일반적       업무상 코드로 정의한 속성은 기본 속성에서 제외           설계 속성            설계 과정에서 도출해내는 속성       데이터 모델링을 위해 업무를 규칙화하려고 새로 만들거나 변형하여 정의하는 속성           파생 속성            다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성       되도록 적은 수를 정의하는 것이 좋음           @ 개체 구성 방식에 따른 분류      기본키 속성 : 개체를 식별할 수 있는 속성   외래키 속성 : 다른 개체와의 관계에서 포함된 속성   일반 속성 : 개체에 포함도어 있고 기본키, 외래키에 포함되지 않은 속성   - 속성 후보 선정 원칙      속성으로 지정할 후보는 최대한 많이 선택하는 것이 좋음   원시 속성으로 판단되는 속성 후보는 버리지 않음   속성 후보군을 만들고 가장 근접한 개체에 할당   - 속성명 지정 원칙      업무에서 사용하는 용어로 지정   서술형으로 지정하지 않음   약어의 사용 제한   개체명은 속성명으로 사용할 수 없음   개체에서 유일하게 식별 가능하도록 지정       5. 데이터 모델의 구성 요소 - 관계(Relationship) – B   - 관계의 정의      개체와 개체 사이의 논리적인 연결   - 관계의 형태      1 : 1   1 : N   N : M   - 관계의 종류      종속 관계   중복 관계   재귀 관계   배타 관계       6. E-R(개체-관계) 모델 – A   - E-R 모델의 개요      개념적 데이터 모델의 대표   개체와 개체간의 관계를 기본 요소로 데이터를 개념적인 논리 데이터로 표현하기 위한 방법   대체 타입과 관계 타입을 이용해 현실 세계를 개념적으로 표현   데이터를 개체, 관계, 속성으로 묘사   특정 DBMS를 고려한 것은 아님   E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음   일반화 계층 같은 복잡한 개념들이 첨가되어 확장된 모델로 발전   - E-R 다이어그램      기호를 사용하여 시각적으로 표현한 그림   역할을 가진 모든 실체들을 표현   뷰들을 하나로 단일화   @ 피터 첸 표기법      개체 : 사각형   관계 : 마름모   속성 : 타원   다중값 속성 : 이중 타원   기본키 속성 : 밑줄 타원   복합 속성 : 복수 타원   1:1, 1:N, N:M 등 개체 간 관계에 대한 대응수를 선 위에 기술 : 관계   개체 타입과 속성을 연결 : 선, 링크   @ 정보 공학 표기법      개체 : 사각형   개체명 : 박스 바깥쪽 위   속성 : 기본키 속성과 일반 속성을 분리하여 표시   관계 : 관계 표기 기호를 사용            필수 : ㅣ       선택적 : ㅇ       다중 : &lt;           @ 바커 표기법      개체 : 모서리가 둥근 박스   개체명 : 박스 안 가장 위   속성            값이 반드시 저장되어야 하는 경우 : *       값이 저장될 수도, 안될 수도 있는 경우 : ㅇ           관계            필수 : ㅡ       선택적 : ………       다중 : &lt;               7. 관계형 데이터베이스의 구조 – A   - 관계형 데이터베이스의 개요      개체나 관계를 모두 릴레이션이라는 표로 표현   개체를 표현하는 개체 릴레이션, 관계를 나타내는 관계 릴레이션으로 구분   장점 : 간결하고 보기 편리하며, 다른 DB로 변환이 용이   단점 : 성능이 다소 떨어짐   - 관계형 데이터베이스의 Relation 구조      구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성   @ 튜플      릴레이션을 구성하는 각각의 행   속성의 모임으로 구성   파일 구조에서 레코드와 같은 의미   튜플의 수를 Cardinality 또는 기수, 대응수라고 함   @ 속성      DB를 구성하는 가장 작은 논리적 단위   파일 구조상의 데이터 항목 또는 데이터 필드에 해당   개체의 특성을 기술   속성의 수를 Degree 또는 차수라고 함   @ 도메인      하나의 Attribute가 취할 수 있는 같은 타입의 Atomic 값들의 집합   값의 합법 여부를 시스템이 검사하는데 이용   - 릴레이션의 특징      한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 튜플들은 모두 상이함   튜플 사이에는 순서가 없음   튜플의 삽입, 삭제 등의 작업으로 릴레이션은 시간에 따라 변함   릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음   속성의 명칭은 유일해야 하지만, 값은 동일한 값이 있을 수 있음   속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장   8. 관계형 데이터베이스의 제약 조건 : Key – A      제약 조건이란 키를 이용하여 입력되는 데이터에 제한을 주는 것.   개체 무결성 제약, 참조 무결성 제약 등이 해당   - Key의 개념 및 종류      키는 조건에 만족하는 튜플을 찾거나 정렬할 때 튜플을 서로 구분할 수 있는 기준이 되는 Attribute   @ 후보키(Candidate Key)      튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합. 즉 기본키로 사용할 수 있는 속성들   모든 릴레이션에는 반드시 하나 이상의 후보키 존재   유일성과 최소성을 만족시켜야 함   유일성 : 하나의 키 값으로 하나의 튜플만을 유일하게 식별   최소성 : 유일하게 식별하는 데 꼭 필요한 속성으로만 구성   @ 기본키(Primary Key)      후보키 중에서 특별히 선정된 주키로 중복된 값을 가질 수 없음   특정 튜플을 유일하게 구별할 수 있는 속성   후보키의 성질을 가짐. 유일성과 최소성을 가지며, 튜플을 식별하기 위해 반드시 필요   NULL 값을 가질 수 없음   @ 대체키(Alternate Key)      후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키. 보조키라고도 함   @ 슈퍼키(Super Key)      속성들의 집합으로 구성된 키   슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음   유일성은 만족시키지만, 최소성은 만족시키지 못함   @ 외래키(Foreign Key)      다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합   참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현   외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음       9. 관계형 데이터베이스의 제약 조건 : 무결성 - B   - 무결성의 개념 및 종류      무결성이란 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성   부정확한 자료가 DB 내에 저장되는 것을 방지하기 위한 제약 조건   @ 개체 무결성(Entity Integrity)      기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정   @ 도메인 무결성(Domain Integrity)      주어진 속성 값이 정의된 도메인에 속한 값이어야 함   @ 참조 무결성(Referential Integrity)      외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함   릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정   외래키와 참조하려는 테이블의 기본키는 도메인과 속성 개수가 같아야 함   @ 사용자 정의 무결성      속성 값들이 사용자가 정의한 제약 조건에 만족해야 하는 규정   - 데이터 무결성 강화      데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 함   DB 구축 과정에서 정의   애플리케이션            데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 추가       복잡한 규칙 등은 애플리케이션 내에서 처리       장점 : 복잡한 무결성 조건의 구현이 가능       단점 : 분산되어 있어 관리가 힘들고, 개별 시행으로 적정성 검토가 어려움           데이터베이스 트리거            트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가       장점 : 통합 관리가 가능하고, 복잡한 요구 조건의 구현이 가능       단점 : 운영 중 변경이 어렵고, 사용상 주의가 필요           제약 조건            제약 조건을 설정하여 무결성을 유지       장점 : 통합 관리 가능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지       단점 : 복잡한 제약 조건의 구현과 예외적인 처리가 불가능           10. 관계대수 및 관계해석 – A   - 관계대수의 개요      RDB에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어   연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션, 결과도 릴레이션   연산의 순서를 명시   순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음   - Select      선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산   행에 해당하는 튜플을 구하는 것. 수평 연산   시그마(σ) 기호를 사용   표기 형식 : σ  (R)   비교 연산이 허용되며, 논리 연산자를 사용하여 여러 조건들을 하나의 조건으로 결합 가능   σ Avg &gt; 90 (성적) :  릴레이션에서 평균 90점 이상인 튜플을 추출하시오   - Project      속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산   중복이 발생하면 제거됨   열에 해당하는 Attribute를 추출 하는 것. 수직 연산자   파이(π) 기호를 사용   표기 형식 : π  (R)   π Name, Avg (성적) :  릴레이션에서 Name과 Avg 속성을 추출하시오   - Join      공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산   차수는 합, Cartesian Product는 곱   Cartesian Product를 수행한 다음 Select를 수행한 것과 같음   ▷◁ 기호를 사용   R ▷◁ 키속성r = 키속성s S   성적 ▷◁ No = No 학적부 :  릴레이션과  릴레이션을 No 속성을 기준으로 합치시오   자연 조인            중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법       자연 조인이 성립되려면 두 릴레이션의 속성명과 도메인이 같아야 함           - Division      X ⊃ Y인 R(X), S(Y)가 있을 때, S가 가진 속성을 제외한 속성만을 구하는 연산   ÷ 기호를 사용   표기 형식 : R [속성r ÷ 속성s] S   - 일반 집합 연산자      집합 이론에서 사용하는 연산자   UNION ∪ : 합집합   INTERSECTION ∩ : 교집합   DIFFERENCE - : 차집합   CARTESIAN PRODUCT X : 교차곱   - 관계 해석      수학의 술어 해석에 기반을 두고 RDB를 위해 제안   관계 데이터의 연산을 표현하는 방법. 계산 수식을 사용   원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성   튜플 관계해석과 도메인 관계해석이 있음   관계해석과 관계대수는 RDB를 처리하는 기능과 능력면에서 동등   관계대수로 표현한 식은 관계해석으로 표현 가능   질의어로 표현       11. 정규화(Normalization) – A   - 정규화의 개요      종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개 바람직한 스키마로 만드는 과정   분해하는 과정   차수가 높아질수록 만족시켜야 할 제약 조건이 늘어남   DB의 논리적 설계 단계에서 수행   논리적 처리 및 품질에 큰 영향을 미침   일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장   정규화 수준이 높을수록 유연한 데이터 구축이 가능. 데이터의 정확성 높아짐   물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하됨   - 정규화의 목적      데이터 구조의 안정성 및 무결성 유지   어떠한 릴레이션이라도 DB 내에서 표현 가능   효과적인 검색 알고리즘을 생성   중복을 배제하여 이상의 발생 방지 및 자료 저장 공간의 최소화 가능   데이터 삽입 시 릴레이션을 재구성할 필요성 줄임   데이터 모형의 단순화 가능   속성의 배열 상태 검증 가능   개체와 속성의 누락 여부 확인이 가능   자료 검색과 추출의 효율성 추구   - 이상의 개념 및 종류      정규화를 거치지 않으면 데이터들이 불필요하게 중복되어 릴레이션 조작시 문제 발생   삽입 이상 : 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입   삭제 이상 : 삭제할 때 의도와는 상관없는 값들도 함께 삭제   갱신 이상 : 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생김   - 정규화의 원칙      정보의 무손실 표현. 정보의 손실이 있어서는 안됨   분리의 원칙. 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현   데이터의 중복성이 감소되어야 함   - 정규화 과정      1NF : 도메인이 원자값만으로 되어 있는 정규형   2NF : 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족   3NF : 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음   BCNF : 결정자가 모두 후보키인 정규형   4NF : 다치 종속이 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족   5NF : 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형   정규화 과정 정리            도메인이 원자값       부분적 함수 종속 제거       이행적 함수 종속 제거       결정자이면서 후보키가 아닌 것 제거       다치 종속 제거       조인 종속성 이용       도부이결다조               12. 반정규화(Denormalization) – B      정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 행위   시스템의 성능이 향상, 관리 효율성 증가   데이터의 일관성 및 정합성이 저하   - 테이블 통합      조인되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행   1:1 관계 테이블 통합, 1:N 관계 테이블 통합, 슈퍼타입/서브타입 테이블 통합   고려사항            검색은 편하지만 레코드 증가로 인해 처리량 증가       통합으로 인해 입력, 수정, 삭제 규칙이 복잡해질 수 있음       Not Null, Default, Check 등의 제약조건을 설계하기 어려움           - 테이블 분할      테이블을 수직 또는 수평으로 분할하는 것   수평 분할            레코드를 기준으로 테이블을 분할       사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할           수직 분할            하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할           - 중복 테이블 추가      여러 테이블에서 데이터를 사용하거나 다른 서버 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 효율성 향상   중복 테이블을 추가하는 경우            정규화로 인해 수행 속도가 느려지는 경우       많은 범위의 데이터를 자주 처리해야 하는 경우       특정 범위의 데이터만 자주 처리해야 하는 경우       처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우           - 중복 속성 추가      조인해서 데이터를 처리할 때 데이터 조회 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가   데이터 무결성 확보가 어렵고, 디스크 공간이 추가로 필요   중복 속성을 추가하는 경우            조인이 자주 발생하는 속성인 경우       접근 경로가 복잡한 속성인 경우       액세스의 조건으로 자주 사용되는 속성인 경우       기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우           고려사항            테이블 중복과 속성의 중복을 고려       데이터 일관성 및 무결성에 유의       SQL 그룹 함수를 이용하여 처리할 수 있어야 함       저장 공간의 지나친 낭비를 고려               13. 시스템 카탈로그 – A   - 시스템 카탈로그의 의미      시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 DB   사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블   카탈로그들이 생성되면 데이터 사전에 저장   - 시스템 카탈로그 저장 정보      시스템 카탈로그에 저장된 정보를 메타 데이터라고 함   메타 데이터의 유형            DB 객체 정보 : Table, Index, View 등의 구조 및 통계 정보       사용자 정보 : 아이디, 패스워드, 접근 권한 등       테이블의 무결성 제약 조건 정보 : 기본키, 외래키, NULL 값 허용 여부 등       함수, 프로시저, 트리거 등에 대한 정보           - 카탈로그 특징      일반 이용자도 SQL을 이용하여 내용 검색할 수 있음   INSERT, DELETE, UPDATE로 카탈로그를 갱신하는 것은 허용되지 않음   DBMS에 따라 상이한 구조   DBMS가 스스로 생성하고 유지함   변화가 있으면 시스템이 자동으로 갱신함   위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 가져야 함   - 카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템      DDL Compiler : 메타 데이터를 갖는 테이블로 변환하여 데이터 사전에 저장   DML Compiler : DML문을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신   Data Directory            데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템       시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있음       데이터 디렉터리는 시스템만 접근할 수 있음           질의 최적화기 : 사용자의 요구를 효율적인 형태로 변환하고 질의를 처리하는 좋은 전략 모색   트랜잭션 처리기 : 트랜잭션 문제를 해결하여, 사용자가 DB 자원을 배타적으로 이용할 수 있도록 함  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp10/",
        "teaser": null
      }]
