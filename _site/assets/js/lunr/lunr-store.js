var store = [{
        "title": "[Github 블로그] Github Blog 시작!",
        "excerpt":"Github blog를 개설하는 과정을 간단하게 알아봅니다.   주의! Git의 사용법을 어느정도 숙지해야 합니다.   1. Github repository 생성  새 repository 이름을 [자신의 Github ID].github.io 로 설정한다.      2. Import code  원하는 Jekyll 테마를 선택하고 코드를 복사한다. Jekyll 테마를 모아둔 사이트는 다음과 같다.   Jekyll ? Ruby 언어로 만들어져 html, markdown 등의 텍스트를 가공하는 텍스트 변환 엔진    http://jekyllthemes.org/  http://themes.jekyllrc.org/  https://jekyllthemes.io/    나의 경우 minimal-mistakes 의 ‘dark’ 테마가 마음에 들어 선택했다.   코드를 복사한 뒤 생성한 [자신의 Github ID].github.io repository로 돌아와 import 한다.            이때 나와 같이 Import하지 않고 repository를 fork 하거나 파일을 Download해도 된다.   3. git clone  Import한 파일들을 작업하기 위해 vscode 터미널에서 clone한다.   $ git clone https://github.com/Github ID/Github ID.github.io.git   4. Rubby 설치  Jekyll을 설치하기 전에 Ruby를 설치한다.   Linux Ubuntu 환경   $ sudo apt-get install ruby-full $ ruby -v   설치가 잘 되었다면 cmd 창에 버전이 잘 출력될 것이다.       Windows 환경    Ruby 다운로드 사이트 에서 다운받아 설치한다.  설치 과정에서 \"Add Ruby executables to your PATH\" 에 체크하면 자동으로 환경변수 설정이 완료된다.   5. Jekyll, Bundler 설치  본인이 clone한 폴더로 들어가면 Gemfile 이라는 파일이 있을 것이다. cmd를 켜서 이 파일이 있는 경로로 들어간 후, 아래의 명령을 수행한다.   $ gem install jekyll bundler $ bundle $ jekyll -v   Jekyll이 잘 설치되었다면 cmd 창에 버전이 잘 출력될 것이다.  그 다음 아래의 명령어를 통해 로컬 환경에서 자신이 개발하는 블로그를 확인해 볼 수 있다.   $ jekyll serve   정상적으로 설치 되었다면 로컬서버 http://localhost:4000/  에서 확인하자.      6. 불필요한 파일 삭제  Github에 commit하기 전에 본인이 clone한 폴더에서 불필요한 파일을 삭제한다.      docs 폴더 : post 샘플이 들어가 있으므로 백업해 놓는다.  README.md : 다시 작성하기 위해 삭제했다.   7. Github 연동  수정된 사항들을 깃헙에 “add-commit-push” 하여 반영한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master    push가 완료되면 [자신의 Github ID].github.io 에서 블로그를 확인할 수 있다.  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/etc-startblog/",
        "teaser": null
      },{
        "title": "[Github 블로그] _config.yml 셋팅",
        "excerpt":"config 수정 공식 사이트   minimal-mistakes _config.yml 설정 공식 사이트    _config.yml 실행   vscode로 루트경로에 있는 _config.yml 을 열어주고 작업한다.  필요없는 부분은 제외하고 작성했다.   _config.yml 수정   minimal_mistakes_skin    : \"dark\" # \"air\", \"aqua\", \"contrast\", \"dark\", \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"  # 사이트 기본 세팅 locale                   : \"ko-KR\" title                    : \"LWW's Tech Blog\" # 타이틀 title_separator          : \"&amp;#124;\" # 구분자 subtitle                 : \"Version 1.0\" # 타이틀 하단 글씨 name                     : \"이원우\" # footer에 찍히는 이름 description              : \"꾸준히 기록하는 블로그\" # 설명 url                      : \"https://LeeWonWoo1.github.io\" # 호스트 주소 repository               : \"LeeWonWoo1/LeeWonWoo1.github.io\" # GitHub 유저이름 / 레포지 이름 teaser                   :  logo                     : # 타이틀 옆 이미지 masthead_title           : \"LWW's Tech Blog\" # 최 상단 타이틀 breadcrumbs              : true # 브래드크럼 사용 여부 words_per_minute         : 200   # 댓글 comments:   provider               : \"disqus\" #   disqus:     shortname            : LWW # disqus에 입력한 Web Site Name   discourse:     server               :   # 구글 Recaptcha reCaptcha:   siteKey                :   secret                 : atom_feed:   path                   :    hide                   :  search                   : true  search_full_content      : true   # Analytics analytics:   provider               : false    # Site Author author:   name             : \"이원우\"   avatar           : \"/assets/images/profile/bear.jpg\" # 프로필 이미지   bio              : \"CS / FrontEnd\"   location         : \"Republic of Korea\"   email            : \"plmplmdnjsdn@naver.com\"   links:     - label: \"Website\"       icon: \"fas fa-fw fa-link\"       url: \"https://LeeWonWoo1.github.io\"     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"   # Site Footer footer:   links:     - label: \"Email\"       icon: \"fab fa-fw fa-envelope-square\"       url: mailto:plmplmdnjsdn@naver.com     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"  # Post에 적용될 default 설정 defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: true       share: true       related: true       popular: false   수정하면서 종종 jekyll 서버로 확인한다.   $ jekyll serve   Github 연동  수정을 완료하면 Github에 연동한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/etc-blog-config/",
        "teaser": null
      },{
        "title": "[HTML] 글자와 상자",
        "excerpt":"글자와 상자   요소가 화면에 출력되는 특성. 크게 2가지로 구분됨.   인라인(Inline) 요소 : 글자를 만들기 위한 요소  블록(Block) 요소 : 상자(레이아웃)를 만들기 위한 요소   - Inline 요소   &lt;span&gt;Hello&lt;/span&gt; &lt;span&gt;World!!&lt;/span&gt;  Hello World!! -------------&gt; 요소가 수평으로 쌓임  가로는 포함한 콘텐츠 크기만큼 줄어듬 &lt;---&gt; &lt;-----&gt; Hello World!! ↕ 세로도 포함한 콘텐츠 크기만큼 줄어듬   span은 가장 대표적인 인라인 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Inline 요소는 가로, 세로 너비를 지정할 수 없음   &lt;span style=\"width: 100px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"height: 100px;\"&gt;World!!&lt;/span&gt;  Hello World!!  &lt;-- 반응 없음     외부, 내부 여백을 지정할 수 있지만, 상하 여백은 사용 불가   &lt;span style=\"margin: 20px 20px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"padding: 20px 20px;\"&gt;World!!&lt;/span&gt;  20px         20px   20px     20px &lt;--&gt;『Hello』&lt;--&gt; 『&lt;--&gt;World&lt;--&gt;』      &lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt;    &lt;!-- Inline 요소 안에 Block 요소 사용 불가 --&gt; &lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;  &lt;!-- Inline 요소 안에 Inline 요소 사용 가능 --&gt;       - Block 요소   &lt;div&gt;Hello&lt;/div&gt; &lt;div&gt;World!!&lt;/div&gt;  Hello     ↓ World!!   ↓  요소가 수직으로 쌓임  가로는 부모 요소의 크기만큼 늘어남 &lt;----------------------------------&gt; Hello                              ↕ World!!                            ↕ 세로는 포함한 콘텐츠 크기만큼 줄어듬   div은 가장 대표적인 블록 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Block 요소는 가로, 세로 너비를 지정할 수 있음   &lt;div style=\"width: 100px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"height: 40px;\"&gt;World!!&lt;/div&gt;       100px &lt;--------------&gt; Hello          ↕ World!!                        ↕                                ↕ 40px &lt;------------------------------&gt;     외부, 내부 여백을 지정할 수 있음   &lt;div style=\"margin: 20px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"padding: 20px;\"&gt;World!!&lt;/div&gt;  20px             ↕ 20px          20px &lt;--&gt;『Hello                    』&lt;--&gt;                  ↕ 20px 『               ↕ 20px          20px &lt;--&gt;World!!                      &lt;--&gt;  20px            ↕ 20px             』      &lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;    &lt;!-- Block 요소 안에 Block 요소 사용 불가 --&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;  &lt;!-- Block 요소 안에 Inline 요소 사용 가능 --&gt;   ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-inlineblock/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-1. 요구사항 확인",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 생명 주기(Software Life Cycle) – A   소프트웨어 개발 방법론의 바탕   - 폭포수 모형(Waterfall Model)      고전적 생명 주기 모형   개발의 한 단계가 끝나야 다음 단계로 넘어가는 선형 순차적 모형   메뉴얼 작성   단계가 끝나면 다음 단계 _결과물 명확히 산출_되어야 함   두 개 이상의 과정이 병행 수행 X   타당성 검토 -&gt; 계획 -&gt; 요구 분석 -&gt; 설계 -&gt; 구현(코딩) -&gt; 시험(검사) -&gt; 유지보수   - 프로토타입 모형(Prototype Model)      인터페이스에 중점을 두어 개발   시스템의 일부를 만드는 과정으로 추후 구현 단계에서 사용될 골격 코드   폭포수 모형의 단점 보완   요구 수집 -&gt; 빠른 설계 -&gt; 프로토타입 구축 -&gt; 고객 평가 -&gt; 포로토타입 조정 -&gt; 구현   - 나선형 모형(Spiral Model)      프로토타입 + 위험 분석 기능   여러번의 개발 과정을 거쳐 완벽한 소프트웨어 개발. 점진적 모형   위험의 관리와 최소화 목적   누락되거나 추가된 요구사항 첨가 가능, 정밀   유지보수 과정 필요 없음   계획 및 정의 -&gt; 위험 분석 -&gt; 공학적 개발 -&gt; 고객 평가   - 애자일 모형(Agile Model)      일정 주기 반복 하며 개발   고객과의 소통에 초점   스프린트, 이터레이션의 짧은 개발 주기 반복   결과물에 대한 고객의 평가와 요구를 적극 수용   스크럼(Scrum), XP(eXtreme Programming), 칸반(Kanban), Lean, 크리스탈, ASD, FDD 등   @ 애자일 선언   애자일 개발 4대 핵심 가치      개인과 상호작용에 더 가치를 둠   실행되는 SW에 더 가치를 둠   고객과 협업에 더 가치를 둠   변화에 반응하는 것에 더 가치를 둠   - 폭포수 모형과 애자일의 비교                  구분       폭포수       애자일                       요구사항 반영       어려움       지속적으로 반영                 고객과의 의사소통       적음       지속적                 테스트       마지막에 테스트       반복되는 주기마다 테스트                 개발 중심       계획, 문서(메뉴얼)       고객               2. 스크럼(Scrum) 기법 – A   팀 중심으로 개발 효율성 높임   - 개요      스스로 팀을 구성, 스스로 해결   제품 책임자(PO; Product Owner)            개발 의뢰자나 사용자가 담당       제품 요구사항 작성의 주체       요구사항 백로그 작성, 우선순위 지정           스크럼 마스터(SM; Scrum Master)            객관적인 시각에서 조언       통제가 목표 아님       진행사항 점검, 장애요소 공론화           개발팀(DT; Development Team)            PO, SM을 제외한 개발에 참여하는 모든 사람           - 스크럼 개발 프로세스      제품 백로그 -&gt; 스프린트 계획 회의 -&gt; 스프린트 -&gt; 일일 스크럼 회의 -&gt; 스프린트 검토 회의 -&gt; 스프린트 회고       3. XP(eXtreme Programming) 기법 – A   고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상   - XP      짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적 참여로 S/W를 빠르게 개발   릴리즈 기간을 짧게 반복   릴리즈 테스트마다 고객을 직접 참여시킴   소규모 인원 개발 프로젝트에 효과적   XP의 5대 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백   - XP 개발 프로세스      사용자 스토리 -&gt; 릴리즈 계획 수립 -&gt; 스파이크 -&gt; 이터레이션 -&gt; 승인검사 -&gt; 소규모 릴리즈   - XP 주요 실천 방법      짝 프로그래밍(Pair Programming)            다른 사람과 함께 스행하여 책임을 공동으로 나눔           테스트 주도 개발(Test-Driven Development)            테스트 케이스 먼저 작성       테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구 사용           전체 팀(Whole Team)            모든 구성원들을 각자 자신의 역할이 있고 거기에 책임을 가져야 함           계속적인 통합(Continuous Integration)            모듈 단위로 개발된 코드가 지속적으로 통합           디자인 개선(Design Improvement) 또는 리팩토링(Refactoring)            기능 변경 없이, 단순화, 유연성 강화 등을 통해 시스템 재구성           소규모 릴리즈(Small Releases)            릴리즈 기간을 짧게 반복하여 고객 요구 변화에 신속히 대응               4. 요구사항 정의 – B   - 요구사항 개념 및 특징      요구사항은 소프트웨어가 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약 조건   개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공   개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 도움   요구사항이 잘 정의 되어야 이후 과정의 목표와 계획을 수립할 수 있음   - 요구사항의 유형      기능 요구사항            무엇을 하는지, 어떤 기능을 하는지       입출력에 무엇이 포함되어야 하는지, 어떤 데이터를 저장하거나 연산을 수행해야 하는지       반드시 수행해야 하는 기능       사용자가 제공받기 원하는 기능           비기능 요구사항            시스템 장비 구성       성능       인터페이스       데이터       테스트       보안       품질       제약사항       프로젝트 관리 요구사항       프로젝트 지원 요구사항           사용자 요구사항            사용자 관점에서 본 시스템이 제공해야 할 요구사항       친숙한 표현으로 이해하기 쉽게 작성           시스템 요구사항            개발자 관점에서 본 시스템이 사용자와 다른 시스템에 제공해야 할 요구사항       전문적이고 기술적인 용어로 표현       소프트웨어 요구사항이라고도 함           - 요구사항 개발 프로세스   요구 사항 도출(Elicitation) -&gt; 분석(Analysis) -&gt; 명세(Specification) -&gt; 확인(Validation)       5. UML(Unified Modeling Language) – A   - UML 개요      객체 지향 모델링 언어   Rumbaugh, Booch, Jacobson 등 객체지향 방법론의 장접 통합. OMG에서 표준으로 지정   구조 다이어그램 6개, 행위 다이어그램 7개   사물과 사물 간의 관계를 용도에 맞게 표현   구성요소는 사물, 관계, 다이어그램   - 사물(Things)      관계가 형성될 수 있는 대상   구조 사물(Structural Things)            시스템의 개념적, 물리적 요소       Class, Use Case, Component, Node 등           행동 사물(Behavioral Things)            시간과 공간에 따른 요소들의 행위       Interaction, State Machine           그룹 사물(Grouping Things)            요소들을 그룹으로 묶어서 표현       Package           주해 사물(Annotation Things)            부가적인 설명이나 제약조건       Note           - 관계(Relationships)      사물과 사물 사이의 연관성 표현   연관(Association) 관계            2개 이상의 사물이 서로 관련되어 있음       사물 사이 실선 연결, 방향성은 화살표로       양방향 관계의 경우 화살표 생략하고 실선으로만 연결       다중도를 선 위에 표기           집합(Aggregation) 관계            하나의 사물이 다른 사물에 포함되어 있음       서로 독립적       포함하는 쪽으로 속이 빈 마름모 연결하여 표현           포함(Composition) 관계            포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계       독립될 수 없고 생명주기를 함께 함       포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현           일반화(Generalization) 관계            하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현       일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)       상위 사물 쪽으로 속이 빈 화살표 연결하여 표현           의존(Dependency) 관계            연관은 있으나 짧은 시간 동안만 연관을 유지하는 관계       소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계       영향 받는 쪽으로 점선 화살표 연결하여 표현           실체화(Realization) 관계            할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계       기능 쪽으로 속이 빈 점선 화살표 연결           - 다이어그램(Diagram)      사물과 관계를 도형으로 표현   가시화한 View를 제공하여 의사소통에 도움   정적 모델링에서는 구조적 다이어그램, 동적 모델링에서는 행위 다이어그램 사용   @ 구조적 다이어그램      클래스(Class) 다이어그램   객체(Object) 다이어그램   컴포넌트(Component) 다이어그램   배치(Deployment) 다이어그램   복합체 구조(Composite Structure) 다이어그램   패키지(Package) 다이어그램   @ 행위 다이어그램      유스케이스(Use Case) 다이어그램   시퀀스(Sequence) 다이어그램   커뮤니케이션(Communication) 다이어그램   상태(State) 다이어그램   활동(Activity) 다이어그램   상호작용 개요(Interaction Overview) 다이어그램   타이밍(Timing) 다이어그램  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-2. 화면 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 사용자 인터페이스 – A   - UI 개요      사용자 인터페이스(UI)는 사용자와 시스템 간의 상호작용이 원활하도록 돕는 장치나 S/W   UI의 3가지 분야            정보 제공을 위한 물리적 제어       콘텐츠의 상세적인 표현과 전체적인 구성       모든 사용자가 편리하고 간편하게 사용           - UI 특징      S/W 영역 중 변경이 가장 많이 발생   편리성과 가독성을 높여 작업 시간을 단축시키고 업무에 대한 이해도 높여줌   최소한의 노력으로 원하는 결과 얻을 수 있게 함   오류를 줄임   구체적인 방법 제시   매개 역할   UI를 설계하기 위해서는 S/W 아키텍처 반드시 숙지해야 함   - UI 구분      CLI(Command Line Interface) : 텍스트 형태   GUI(Graphical User Interface) : 그래픽 환경   NUI(Natural User Interface) : 말이나 행동으로 조작   - UI 기본 원칙      직관성   유효성   학습성   유연성   - UI 설계 지침      사용자 중심   일관성   단순성   결과 예측 가능   가시성   표준화   접근성   명확성   오류 발생 해결       2. UI 표준 및 지침 – B      기술의 중립성(웹 표준), 표현 보장성(웹 접근성), 기능의 호환성(웹 호환성) 고려 확인   UI 표준 : 모든 UI에 공통적으로 적용될 내용   UI 지침 : UI 개발 과정에서 꼭 지켜야 할 공통의 조건   - 한국형 웹 콘텐츠 접근성 지침(KWCAG)      인식의 용이성            대체 텍스트       멀티미디어 대체 수단       명료성           운용의 용이성            키보드 접근성       충분한 시간 제공       광과민성 발작 예방       쉬운 내비게이션           이해의 용이성            가독성       예측 가능성       콘텐츠의 논리성       입력 도움           견고성            문법 준수       접근성           - 전자정부 웹 표준 준수 지침      내용의 문법 준수            적절한 문서타입 명시       문법 준수       인코딩 방식 표기           내용과 표현의 분리            마크업 언어를 사용해 웹 문서 구조화       스타일 언어는 표준 문법 준수           동작의 기술 중립성 보장            스크립트의 비표준 문법 확장 배제       대체 텍스트나 정보 제공           플러그인의 호환성            다양한 웹 브라우저에서 호환되는 것 사용           콘텐츠의 보편적 표현            메뉴는 다양한 브라우저에서 접근할 수 있어야 함       웹 사이트를 다양한 인터페이스로 이용할 수 있어야 함           운영체제에 독립적인 콘텐츠 제공            운영체제에 종속적이지 않은 범용적인 포맷을 사용           부가 기능의 호환성 확보            다양한 브라우저에서 사용할 수 있어야 함           다양한 프로그램 제공            다양한 브라우저에서 사용할 수 있어야 함       윈도우, 리눅스, 맥킨토시 중 2개 이상의 운영체제를 지원해야 함               3. UI 설계 도구 – A      UI의 화면 구조나 화면 배치 등을 설계할 때 사용하는 도구   기획단계에서 미리 보여주기 위한 용도   - 와이어프레임(Wireframe)      페이지에 대한 개략적인 레아아웃이나 UI 요소 등에 대한 뼈대 설계   페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계   레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용   툴 : 손그림, PPT, 키노트, 스케치, 일러스트, 포토샵 등   - 목업(Mockup)      와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형   실제로 구현되지는 않음   툴 : 파워 목업, 발사믹 목업 등   - 스토리보드(Story Board)      와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가   최종적으로 참고하는 작업 지침서, 서비스 구축을 위한 모든 정보 포함   상단이나 우측에는 제목, 작성자 기입, 좌측에는 UI화면, 우측에는 Description 기입   Description은 명확하고 세부적으로 작성   툴 : PPT, 키노트, 스케치, Axure 등   - 프로토타입(Prototype)      와이어프레임이나 스토리보드 등에 인터렉션을 적용한 동적인 형태의 모형   작업자 간 서비스 이해를 위해 작성하는 샘플   페이퍼 프로토타입과 디지털 프로토타입으로 나뉨   툴 : HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등   - 유스케이스(Use Case)      사용자 측면에서의 요구사항   사용자의 요구사항을 파악해 초기에 기능적인 요구를 결정하고 그 결과를 문서화할 수 있음   자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것. 다이어그램 형식으로 묘사   유스케이스 다이어그램이 완성되면, 명세서 작성       4. UI 요구사항 확인 – B      새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해서 작성하는 단계   목표 정의 -&gt; 활동사항 정의 -&gt; UI 요구사항 작성 -&gt; 요구사항 요소 확인 -&gt; 정황 시나리오 작성 -&gt; 요구사항 작성       5. 품질 요구사항 – B      요구사항이 얼마나 충족하는가를 나타내는 S/W 특성의 총체   품질은 사용자의 요구사항을 충족시킴으로써 확립   ISO/IEC 9126            품질 특성과 평가를 위한 표준 지침       품질에 대한 요구사항을 기술하거나 품질 평가 등에 사용       기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성           호환성과 보안성을 강화하여 ISO/IEC 25010으로 개정            기능적합성, 신뢰성, 사용성, 실행효율성, 유지보수성, 이식성, 호환성, 보안성           - 기능성(Functionality)      사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부   적절성/정합성(Suitability) : 적절한 기능을 제공   정밀성/정확성(Accuracy) : 결과를 정확하게 산출   상호 운용성(Interoperability) : 서로 어울려 작업   보안성(Security) : 접근을 권한에 따라 허용하거나 차단   준수성(Compliance) : 표준, 관례 및 규정을 준수   - 신뢰성(Reliability)      요구된 기능을 정확하고 일관되게 오류 없이 수행   성숙성(Maturity) : 고장을 피해감   고장 허용성(Fault Tolerance) : 고장 시 규정된 성능 수준을 유지   회복성(Recoverability) : 고장 시 다시 회복하고 데이터를 복구   - 사용성(Usability)      사용자가 정확하게 이해하고 사용하며, 다시 사용하고 싶은 정도   이해성(Understandability) : 사용자가 이해할 수 있는 능력   학습성(Learnability) : S/W를 학습할 수 있도록 하는 능력   운용성(Operability) : 운용하고 제어할 수 있도록 하는 능력   친밀성(Attractiveness) : 다시 사용하고 싶어 하도록 하는 능력   - 효율성(Efficiency)      할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도   시간 효율성(Time Behaviour) : 적절한 반응 시간 및 처리시간, 처리율 제공   자원 효율성(Resource Behaviour) : 적절한 자원의 양과 종류를 제공   - 유지 보수성(Maintainability)      환경의 변화에서 S/W를 개선하거나 확장할 수 있는 정도   분석성(Analyzability) : 수정될 부분의 식별을 가능하게 하는 능력   변경성(Changeability) : 변화로 인한 수정 등을 쉽게 구현   안정성(Stability) : 변경으로 인한 예상치 못한 결과를 최소화하는 능력   시험성(Testability) : 변경이 검증될 수 있는 능력   - 이식성(Portability)      다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도   적용성(Adaptability) : 다른 환경으로 변경될 수 있는 능력   설치성(Installability) : 임의의 환경에 설치할 수 있는 능력   대체성(Replaceability) : 다른 S/W를 대신하여 사용될 수 있는 능력   공존성(Co-existence) : 다른 S/W와 공존할 수 있는 능력       6. UI 프로토타입 제작 및 검토 – A   - UI 프로토타입 개요      프로토타입은 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적 형태의 모형   테스트 가능   간단하게 만들어야 함   핵심 기능만을 제공하지만, 필요한 기능은 반드시 포함   요구사항이 모두 반영될 때까지 개선, 보완   실제 사용자를 대상으로 테스트   - UI 프로토타입 장단점      장점            설득, 이해 쉬움       혼선 예방으로 개발 시간 단축       사전 오류 발견           단점            반복적인 개선작업으로 작업 시간 증가, 필요이상으로 자원 소모       중요한 작업 생략될 수 있음           - 프로토타이핑 종류      페이퍼 프로토타입(Paper Prototype)            아날로그적 방법, 손으로 직접 작성       제작기간이 짧고, 업무 협의가 빠른 경우 사용       장점                    비용 저렴           대화하면서 생성 가능           즉시 변경 가능           고객이 과다한 기대 안함                       단점                    테스트하기 부적당           상호 관계가 많은 경우 나타내기 복잡           여러 사람들에게 나눠주거나 공유하기 어렵다                           디지털 프로토타입(Digital Prototype)            프로그램을 사용하여 작성       재사용이 필요한 경우, 숙련된 전문가가 있을 경우 사용       장점                    최종 제품과 비슷하게 테스트           수정 쉬움           재사용 가능                       단점                    프로그램의 사용법을 알아야 함                           - UI 프로토타입 제작 단계      요구사항 분석   개발할 시스템의 핵심적인 기능을 페이퍼/디지털 방식으로 작성   사용자가 확인하는 단계, 추가 및 수정 의견 제안   수정과 합의가 이루어짐       7. UI 설계서 작성 – B   - UI 설계서 개요      UI 설계를 구체화하여 작성하는 문서. 대표적인 화면들을 설계   원활한 의사소통을 위해 작성   - UI 설계서 표지 작성      혼동되지 않도록 프로젝트명 또는 시스템명을 포함   - UI 설계서 개정 이력 작성      UI 설계서가 수정될 때마다 어떤 부분이 수정되었는지 정리해 놓은 문서   - UI 요구사항 정의서 작성      사용자의 요구사항을 확인하고 정리한 문서   - 시스템 구조 작성      전체 시스템의 구조를 설계한 것   - 사이트 맵 작성      사이트에 표시할 콘텐츠를 한 눈에 알아 볼 수 있도록 메뉴별로 구분하여 설계한 것   - 프로세스 정의서 작성      프로세스들을 작업 진행 순서에 맞춰 정리한 것   UI 전체적인 흐름 파악 가능   - 화면 설계      필요한 화면을 페이지별로 설계   와이어프레임을 대략적으로 스케치   주요 흐름을 스토리보드 형태로 작성   - UI 화면 설계의 기본 구성 요소      윈도우, 메뉴, 아이콘, 포인터       8. UI 상세 설계 – B      실제 구현을 위해 모든 화면에 대한 자세한 설계를 진행하는 단계. 반드시 시나리오 작성   최종 목표를 달성하기 위한 방법이 순차적으로 묘사   - UI 시나리오 문서 작성 원칙      구체적으로 작성. Tree 구조 또는 Flow Chart 표기법으로 작성   공통적으로 적용될 UI 요소와 인터렉션을 일반 규칙으로 정의   레이아웃과 속할 기능 정의   인터렉션의 순서, 분기, 조건, 루프 등을 명시   예외 상황에 대비한 다양한 케이스 정의   기능별 상세 기능 시나리오를 정의   UI 시나리오 규칙을 지정   - UI 시나리오 문서 작성을 위한 일반 규칙      주요 키의 위치와 기능   공통 UI 요소   기본 스크린 레이아웃   기본 인터랙션 규칙   공통 단위 태스크 흐름   케이스 문서   - UI 요소      체크 박스 : 1개 이상의 값을 선택할 수 있는 버튼   라디오 버튼 : 하나만 선택할 수 있는 버튼   텍스트 박스 : 데이터를 입력하고 수정할 수 있는 상자   콤보 상자 : 지정된 목록 상자에 내용을 표시하여 선택하거나 새로 입력할 수 있는 상자   목록 상자 : 콤보 상자와 같이 목록을 표시하지만 새로운 내용을 입력할 수 없음   - UI 시나리오 문서의 요건      완정성(Complete)   일관성(Consistent)   이해성(Understandable)   가독성(Readable)   수정 용이성(Modifiable)   추적 용이성(Traceable)   - UI 시나리오 문서로 인한 기대 효과      오류 감소   재작업 감소, 혼선 최소화   불필요한 기능 최소화   개발 비용 절감   개발 속도 향상  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp2/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-3. 애플리케이션 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 아키텍처 – A   - 소프트웨어 아키텍처의 설계      골격이 되는 기본 구조, 시스템의 구조 또는 구조체   원칙과 지침, 의사소통 도구   비기능적 요구사항의 제약 반영, 기능적 요구사항을 구현하는 방법을 찾는 과정   분할 방법, 모듈에 할당될 기능, 모듈 간의 인터페이스 등 결정   - 모듈화(Modularity)      성능을 향상시키거나 수정 및 재사용, 유지관리 등을 위해 기능들을 모듈 단위로 나누는 것   자주 사용하는 것들을 공통 모듈로 구성하여 재사용성 향상   크기를 작게 나누면 통합 비용이 많이 듦   크기를 크게 나누면 모듈 하나의 개발 비용이 많이 듦   - 추상화(Abstraction)      전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화   유사한 모델을 만들어서 여러 가지 요인들을 테스트   최소의 비용으로 실제 상황에 대처, 구조 및 구성을 대략적으로 파악   과정 추상화            전반적인 흐름만 파악할 수 있게 설계           데이터 추상화            데이터 구조를 대표할 수 있는 표현으로 대체           제어 추상화            이벤트 발생을 대표할 수 있는 표현으로 대체           - 단계적 분해(Stepwise Refinement)      하향식 설계 전략. 상위의 중요 개념으로부터 하위의 개념으로 구체화   추상화의 반복에 의해 세분화   기능에서부터 시작해 알고리즘, 자료구조 등 상세한 내역을 뒤로 미뤄 진행   - 정보 은닉(Information Hiding)      정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법   필요한 정보만 인터페이스를 통해 주고 받음   모듈을 독립적으로 수행할 수 있음   모듈이 변경되더라도 다른 모듈에 영향을 주지 않아 수정, 시험, 유지보수 용이   - 소프트웨어 아키텍처의 품질 속성      시스템 측면            성능, 보안, 가용성, 기능성, 사용성, 변경용이성, 확장성 등           비즈니스 측면            시장 적시성, 비용과 혜택, 예상 시스템 수명 등           아키텍처 측면            개념적 무결성, 정확성, 완결성, 구축 가능성 등           - 소프트웨어 아키텍처 설계 과정      설계 목표 설정 -&gt; 시스템 타입 결정 -&gt; 아키텍처 패턴 적용 -&gt; 서브시스템 구체화 -&gt; 검토       2. 아키텍처 패턴 – A   - 아키텍처 패턴의 개요      아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식   S/W 시스템의 구조를 구성하기 위한 기본적인 윤곽   서브시스템들과 그 역할이 정의, 관계와 여러 규칙, 지침 등이 포함   아키텍처 스타일 또는 표준 아키텍처라고도 함   - 레이어 패턴(Layers pattern)      시스템을 계층으로 구분   상위 계층은 서비스 제공자, 하위 계층은 클라이언트가 됨   마주보는 두 개의 계층 사이에서만 상호작용   변경 작업 용이   특정 계층만을 교체해 시스템을 개선하는 것이 가능   OSI 참조 모델   - 클라이언트-서버 패턴(Client-Server pattern)      하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성   사용자는 클라이언트와만 의사소통   서버는 항상 대기 상태를 유지   클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고 서로 독립적   - 파이프-필터 패턴(Pipe-Filter Pattern)      데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터 전송   재사용성이 좋고, 추가가 쉬워 확장이 용이   재배치하여 다양한 파이프라인 구축 가능   데이터 변환, 버퍼링, 동기화 등에 주로 사용   Unix의 Shell   - 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)      서브시스템을 3개의 부분으로 구조화   모델(Model) : 핵심 기능과 데이터를 보관   뷰(View) : 정보를 표시   컨트롤러(Controller) : 입력을 처리   별도의 컴포넌트로 분리되어 서로 영향을 받지 않고 개발 작업 수행 가능   여러 개의 뷰를 만들 수 있으므로 대화형 어플리케이션에 적합   - 마스터-슬레이브 패턴(Master-Slave Pattern)      장애 허용 시스템, 병렬 컴퓨팅 시스템   - 브로커 패턴(Broker Pattern)      분산 환경 시스템   - 피어-투-피어 패턴(Peer-To-Peer Pattern)      클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용   - 이벤트-버스 패턴(Event-Bus Pattern)      소스, 리스너, 채널, 버스   - 블랙보트 패턴(Blackboard Pattern)      음성 인식, 차량 식별, 신호 해석   - 인터프리터 패턴(Interpreter Pattern)      프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용       3. 객체지향(Object-Oriented) – A   - 객체지향의 개요      S/W를 개발할 때 객체들을 조립해서 작성할 수 있는 기법   재사용 및 확장 용이, 빠르게 개발할 수 있고 유지보수 쉬움   복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리 지원   사용자와 개발자가 쉽게 이해할 수 있음   - 객체(Object)      데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 S/W 모듈   데이터            객체가 가지고 있는 정보. 속성이나 상태, 분류 등       속성, 상태, 변수, 상수, 자료 구조           함수            객체가 수행하는 기능       메소드, 서비스, 동작, 연산           객체의 특성            독립적으로 식별 가능한 이름       상태는 시간에 따라 변함       상호 연관성에 의한 관계 형성       행위의 특징을 나타낼 수 있음       일정한 기억장소를 가지고 있음           - 클래스(Class)      공통된 속성과 연산을 갖는 객체의 집합   객체들이 갖는 속성과 연산을 정의하고 있는 틀   각각의 객체를 인스턴스, 새로운 객체를 생성하는 것을 인스턴스화   최상위 클래스는 상위 클래스를 갖지 않는 클래스   슈퍼 클래스는 특정 클래스의 부모 클래스   서브 클래스는 특정 클래스의 자식 클래스   - 캡슐화(Encapsulation)      데이터와 데이터를 처리하는 함수를 하나로 묶는 것   인터페이스를 제외한 세부 내용이 은폐   외부 모듈의 변경으로 인한 파급 효과가 적음   재사용 용이   인터페이스가 단순해지고, 객체 간 결합도 낮아짐   - 상속(Inheritance)      부모 클래스의 모든 속성과 연산을 자식 클래스가 물려 받는 것   자식 클래스는 속성과 연산을 다시 정의하지 않고 사용 가능   새로운 속성과 연산을 첨가하여 사용 가능   재사용을 높임   - 다형성(Polymorphism)      메시지에 의해 객체가 연산을 수행할 때, 고유한 방법으로 응답할 수 있는 능력   객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함   같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 함       4. 모듈 – A   - 모듈의 개요      모듈화를 통해 분리된 시스템의 각 기능. 서브루틴, 서브시스템 등과 같은 의미로 사용   단독으로 컴파일 가능, 재사용 가능   모듈의 기능적 독립성은 하나의 기능만을 수행하고 과도한 상호작용을 배재함으로써 달성   수정하더라도 다른 모듈에 거의 영향을 미치지 않으며, 오류 발생시 쉽게 발견하고 해결 가능   결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 함   - 결합도(Coupling)      모듈간 상호 의존하는 정도   결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음   결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움   @ 내용 결합도(Content Coupling)      한 모듈이 다른 모듈이 내부 기능 및 그 내부 자료를 직접 참조하거나 수정   제어가 이동하는 경우   @ 공통(공유) 결합도(Common Coupling)      공통 데이터 영역을 여러 모듈이 사용할 때의 결합도   조금의 변경이 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 함   @ 외부 결합도(External Coupling)      선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도   데이터의 범위를 각 모듈에서 제한할 수 있음   @ 제어 결합도(Control Coupling)      다른 모듈 내부의 논리적 흐름을 제어하기 위해 제어신호를 이용하여 통신   다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우   처리 기능이 두 모듈에 분리되어 설계된 경우   하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상 발생   @ 스탬프 결합도(Stamp Coupling)      배열이나 레코드 등의 자료 구조가 전달될 때의 결합도   동일한 자료 구조를 조회하는 경우   @ 자료 결합도(Data Coupling)      자료 요소로만 구성될 때의 결합도   가장 바람직한 결합도   - 응집도(Cohesion)      정보 은닉 개념을 확장한 것   모듈이 독립적인 기능으로 정의되어 있는 정도   응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음   @ 기능적 응집도(Functional Cohesion)      모든 기능 요소들이 단일 문제와 연관되어 수행될 경우   @ 순차적 응집도(Sequential Cohesion)      출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우   @ 교환적 응집도(Communication Cohesion)      동일한 입출력을 사용하여 서로 다른 기능을 수행하는 구성요소들이 모였을 경우   @ 절차적 응집도(Procedural Cohesion)      다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우   @ 시간적 응집도(Temporal Cohesion)      특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우   @ 논리적 응집도(Logical Cohesion)      유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우   @ 우연적 응집도(Coincidental Cohesion)      각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우   - 팬인(Fan-In) / 팬아웃(Fan-Out)      팬인은 모듈을 제어하는 모듈의 수. 팬아웃은 모듈에 의해 제어되는 모듈의 수   시스템의 복잡도를 알 수 있음   팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있으나, 단일 장애점 발생 가능   팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고 단순화할 수 있는지 검토   시스템 복잡도를 최적화하기 위해 팬인을 높게, 팬아웃은 낮게 설계       5. 코드 – B   - 코드의 개요      자료의 추출을 쉽게 하기 위해 사용하는 기호   신속, 정확, 명료하게 정보 전달   일정한 규칙에 따라 작성   식별기능, 분류기능, 배열기능   - 코드의 종류      순차 코드            1, 2, 3 ..           블록 코드            1001~1100 : 총무부           10진 코드            1000 : 공학, 1100 : S/W 공학           그룹 분류 코드            1-01-001 : 본사-총무부-인사계           연상 코드            TV-40 : 40인치 TV           표의 숫자 코드            120-720-1500 : 두께x폭x길이가 120x720x1500인 강판           합성 코드            KE-711 : 대한항공 711기           - 코드 부여 체계      이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식   유일한 코드 부여하여 식별 및 추출을 용이하게 함   각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 함   코드의 자릿수와 구분자, 구조 등을 상세하게 명시       6. 디자인 패턴 – B   - 디자인 패턴의 개요      세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식   재사용할 수 있는 기본형 코드들이 포함   디자인 패턴을 참고하여 적용하는 것이 더 효율적   Don’t reinvent the wheel   유사한 형태의 다른 패턴으로 변화되는 특징   - 아키텍처 패턴 vs 디자인 패턴                  아키택처       디자인                       상위수준 설계       하위수준 설계                 전체 시스템 구조 설계       서브시스템에 속하는 컴포넌트들과 그 관계 설계           - 생성 패턴(Creational Pattern)      객체의 생성과 관련된 패턴   객체의 생성과 참조 과정을 캡슐화하여 프로그램에 유연성을 더해줌   @ 추상 팩토리(Abstract Factory)      인터페이스를 통해 서료 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현   연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능   @ 빌더(Builder)      작게 분리된 인스턴스를 건축 하듯이 조합하여 객체 생성   동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음   @ 팩토리 메소드(Factory Method)      객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화   상위클래스에서는 인터페이스 정의하고 실제 생성은 서브 클래스가 담당   @ 프로토타입(Prototype)      원본 객체를 복제하는 방법으로 객체를 생성   비용이 큰 경우 이용   @ 싱글톤(Singleton)      객체를 생성하면 어디서든 참조할 수 있지만, 여러 프로세스가 동시 참조 불가   클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비 최소화   - 구조 패턴(Structural Pattern)      클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴   구조가 복잡한 시스템을 개발하기 쉽게 도와줌   @ 어댑터(Adapter)      인터페이스를 다른 클래스가 이용할 수 있도록 변환   인터페이스가 일치하지 않을 때 이용   @ 브리지(Bridge)      서로가 독립적으로 확장할 수 있도록 구성한 패턴   기능과 구현을 두 개의 별도 클래스로 구현   @ 컴포지트(Composite)      복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용   객체를 트리구조로 구성   @ 데코레이터(Decorator)      객체 간의 결합을 통해 능동적으로 기능들을 확장   부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식   @ 퍼싸드(Facade)      상위에 인터페이스를 구성함으로써 서브 클래스의 기능을 간편하게 사용할 수 있도록 함   통합 인터페이스를 제공하는 Wrapper 객체가 필요   @ 플라이웨이트(Flyweight)      매번 생성하는 것이 아니고 가능한 한 공유해서 사용해 메모리 절약   다수의 유사 객체를 생성하거나 조작할 때 유용   @ 프록시(Proxy)      접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할   네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용   - 행위 패턴(Behavioral Pattern)      클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의   하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화하도록 도움   @ 책임 연쇄(Chain of Responsibility)      객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태   @ 커맨드(Command)      요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장   추상 클래스와 구체 클래스로 분리하여 단순화   @ 인터프리터(Interpreter)      언어에 문법 표현을 정의하는 패턴   SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용   @ 반복자(Iterator)      접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴   내부 표현 방법의 노출 없이 순차적인 접근이 가능   @ 중재자(Mediator)      복잡한 상호작용을 캡슐화하여 객체로 정의   객체 사이의 의존성을 줄여 결합도 감소시킴   @ 메멘토(Memento)      객체 내부 상태를 객체화함으로써 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공   Ctrl + Z 같은 기능 개발할 때 이용   @ 옵서저(Observer)      객체의 상태가 변화하면 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴   분산 시스템 간에 이벤트를 생성, 발행하고, 이를 수신해야 할 때 이용   @ 상태(State)      동일한 동작을 다르게 처리해야 할 때 사용하는 패턴   객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리   @ 전략(Strategy)      동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴   원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘 변경 가능   @ 템플릿 메소드(Template Method)      상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 패턴   코드의 양을 줄이고 유지보수를 용이하게 해줌   @ 방문자(Visitor)      데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴   분리된 처리 기능은 각 클래스를 방문하여 수행  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp3/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-4. 인터페이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 시스템 인터페이스 요구사항 분석 – B   - 시스템 인터페이스 요구사항 구성      시스템끼리 서로 연동하여 상호작용하기 위한 접속 방법이나 규칙   명세서에는 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 방식, 송신 데이터, 주기 등 포함   - 시스템 인터페이스 요구사항 분석      기능적 요구사항과 비기능적 요구사항으로 분류   요구사항 분석 기법을 적절히 이용   적절한 수준으로 세분화   누락된 요구사항이나 제한조건 추가   상대적 중요도를 평가하여 우선순위를 부여   - 시스템 인터페이스 요구사항 분석 절차      요구사항 선별 -&gt; 요구사항 관련 자료 준비 -&gt; 요구사항 분류 -&gt; 요구사항 분석 및 명세서 구체화 -&gt; 요구사항 명세서 공유       2. 인터페이스 요구사항 검증 – B      요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 베이스라인 설정   검토 계획 수립 -&gt; 검토 및 오류 수정 -&gt; 베이스라인 설정   - 요구사항 검증 방법      요구사항 검토            동료 검토 : 동료들이 결함 발견       워크스루 : 짧은 검토 회의를 통해 결함 발견       인스펙션 : 검토 전문가들이 결함 발견           프로토타이핑   테스트 설계   CASE 도구 활용   - 인터페이스 요구사항 검증의 주요 항목      완전성(Completeness)   일관성(Consistency)   명확성(Unambiguity)   기능성(Functionality)   검증 가능성(Verifiability)   추적 가능성(Traceability)   변경 용이성(Easily Changeable)       3. 인터페이스 방법 명세화 – B   - 시스템 연계 기술      DB Link : DB Link 객체를 이용하는 방식   API/Open API : DB에서 데이터를 읽어 와 제공   연계 솔루션 : EAI 서버와 송수신 시스템에 설치되는 클라이언트 이용   Socket : 서버는 통신을 위한 소켓을 생성하여 포토 할당하여 클라이언트의 통신 요청 시 연결하여 통신   Web Service : WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스   - 인터페이스 통신 유형      단방향 : 요청만 하고 응답이 없는 방식   동기 : 요청하고 응답이 올때까지 대기   비동기 : 요청하고 다른 작업을 수행하다 응답이 오면 처리   - 인터페이스 처리 유형      실시간 방식 : 요청한 내용을 바로 처리   지연 처리 방식 : 매건 단위로 처리할 경우 비용이 많이 발생할 때   배치 방식 : 대량의 데이터를 처리할 때       4. 미들웨어 솔루션 명세 – A   - 미들웨어의 개념 및 종류      운영체제와 응용프로그램 사이에서 추가적인 서비스를 제공하는 소프트웨어   표준화된 인터페이스 제공하여 데이터 교환에 일관성 보장   - DB(DataBase)      클라이언트에서 원격의 DB와 연결하기 위한 미들웨어   DB를 사용해서 시스템 구축하는 경우 2-Tier 아키텍처라고 함   ODBC, IDAPI, Glue   - RPC(Remote Procedure Call)      응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식   Entera, ONC/RPC   - MOM(Message Oriented Middleware)      메시지 기반의 비동기형 메시지를 전달하는 방식   온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 사용됨   MQ, Message Q, JMS   - TP-Monitor(Transaction Processing Monitor)      온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어   빠른 응답 속도를 유지해야 하는 업무에 사용   tuxedo, tmax   - ORB(Object Request Broker)      객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현   트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음   Orbix, CORBA   - WAS(Web Application Server)      동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어   웹 환경을 구현하기 위한 미들웨어   웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현 가능   WebLogic, WebSphere  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp4/",
        "teaser": null
      },{
        "title": "[HTML] HTML 구조 및 태그",
        "excerpt":"HTML 구조   &lt;!DOCTYPE html&gt;  &lt;!-- 문서의 HTML 버전을 지정 --&gt;  &lt;html&gt;       &lt;!-- 문서의 전체 범위 --&gt;    &lt;head&gt;     &lt;!-- 문서의 정보를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보이지 않는 정보를 작성하는 범위 --&gt;   &lt;/head&gt;    &lt;body&gt;     &lt;!-- 문서의 구조를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보여지는 구조를 작성하는 범위 --&gt;   &lt;/body&gt; &lt;/html&gt;   Head 태그 내부   - meta 태그   &lt;meta charset=\"UTF-8\" /&gt;   &lt;!-- 문자 인코딩 방식 --&gt; &lt;meta name=\"viewport\" content=\"width=xxxx...\" /&gt; &lt;!-- 정보의 종류     정보의 값 --&gt;  &lt;meta /&gt;는 HTML 문서의 제작자, 내용, 키워드 등의 정보를 검색엔진이나 브라우저에 제공       - title 태그   &lt;title&gt;Google&lt;/title&gt; &lt;!-- HTML 문서의 제목을 정의. 웹 브라우저 탭에 표시됨--&gt;       - link 태그   &lt;!-- 관계              경로 --&gt; &lt;link rel=\"stylesheet\" href=\"./main.css\" /&gt; &lt;link rel=\"icon\" htrf=\"./favicon.png\" /&gt;  &lt;link /&gt;는 외부 문서를 가져와 연결할 때 사용. 대부분 CSS 파일       - style 태그   &lt;!-- CSS를 HTML 문서 안에서 작성하는 경우에 사용 --&gt; &lt;style&gt;   div {     color : red;   } &lt;/style&gt;       - script 태그   &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;!-- JS파일 가져오는 경우--&gt; &lt;!-- defer : HTML 구조가 준비된 후에 JS를 해석 --&gt;  &lt;!-- JS를 HTML 문서 안에서 작성하는 경우 --&gt; &lt;script&gt;   console.log('Hello World!!') &lt;/script&gt;   Body 태그 내부   - div 태그   &lt;div&gt;&lt;/div&gt;  &lt;!-- Block, 특별한 의미가 없는 구분을 위한 요소 --&gt;       - h 태그   &lt;h1&gt;제목1&lt;/h1&gt;    &lt;!-- Block, 제목을 의미하는 요소 --&gt; &lt;h2&gt;제목2&lt;/h2&gt;    &lt;!-- 숫자가 작을수록 더 중요한 제목--&gt; &lt;h6&gt;제목6&lt;/h6&gt;       - p 태그   &lt;p&gt;가나 다라마&lt;/p&gt;  &lt;!-- Block, 문장을 의미하는 요소 --&gt;       - img 태그   &lt;!-- 경로              대체 텍스트 --&gt; &lt;img src=\"img/xxx.png\" alt=\"xxx\" /&gt; &lt;!-- Inline, 이미지 삽입 요소--&gt;       - ul, li 태그   &lt;ul&gt;  &lt;!-- Block, 순서가 필요 없는 목록의 집합--&gt;   &lt;li&gt;강아지&lt;/li&gt;    &lt;li&gt;고양이&lt;/li&gt;  &lt;!-- 목록 내 각 항목 --&gt;   &lt;li&gt;돼지&lt;/li&gt; &lt;/ul&gt;       - a 태그   &lt;!-- Inline, 다른/같은 페이지로 이동하는 하이퍼링크 지정하는 요소 --&gt; &lt;a href=\"http://www.google.com\" target=\"_blank\"&gt;Google&lt;/a&gt; &lt;!-- URL                       URL의 표시(브라우저 탭) 위치 --&gt;       - span 태그   &lt;span&gt;가나다&lt;/span&gt; &lt;!-- Inline, 특별한 의미가 없는 구분을 위한 요소--&gt;       - br 태그   &lt;p&gt;가나다라&lt;br/&gt;마바사아&lt;/p&gt; &lt;!--Inline, 줄바꿈 요소--&gt;  가나다라 마바사아       - input 태그   &lt;!--Inline-Block, 데이터를 입력하는 요소--&gt; &lt;input type=\"text\" value=\"xxx\" placeholder=\"yyy\" disabled/&gt;  &lt;!--  타입         입력된 값     힌트            비활성화 --&gt;       - label 태그   &lt;label&gt; &lt;!--Inline, 라벨 가능 요소(input)의 제목--&gt;   &lt;input type=\"checkbox\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"checkbox\" checked /&gt; Cat &lt;/label&gt;   &lt;label&gt; &lt;!-- animals 그룹에서 1개만 입력 --&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Cat &lt;/label&gt;        - table, tr, td 태그   &lt;table&gt;  &lt;!-- Table, 표 요소, 행과 열의 집합 --&gt;    &lt;tr&gt;   &lt;!-- Table, 행을 지정하는 요소 --&gt;     &lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt; &lt;!-- Table, 열을 지정하는 요소 --&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;C&lt;/td&gt;&lt;td&gt;D&lt;/td&gt;   &lt;/tr&gt;  &lt;/table&gt;  A B C D  주의! TABLE 요소보다 Grid같은 CSS 기능으로 레이아웃을 작업해야 함   HTML 전역 속성   &lt;태그 title=\"설명\"&gt;&lt;/태그&gt;   &lt;!-- 요소의 정보나 설명을 지정 --&gt; &lt;태그 style=\"스타일\"&gt;&lt;/태그&gt; &lt;!-- 요소에 적용할 스타일 지정 --&gt; &lt;태그 class=\"이름\"&gt;&lt;/태그&gt;   &lt;!-- 요소를 지칭하는 중복 가능한 이름 --&gt; &lt;태그 id=\"이름\"&gt;&lt;/태그&gt;      &lt;!-- 요소를 지칭하는 고유한 이름 --&gt; &lt;태그 data-이름=\"데이터\"&gt;&lt;/태그&gt; &lt;!-- 요소에 데이터를 지정 --&gt;  ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-structure/",
        "teaser": null
      },{
        "title": "[CSS] CSS 개요",
        "excerpt":"CSS 기본 문법   /* 주석 */ 선택자 {   속성 : 값;   속성 : 값; }   CSS 선언 방식   - 내장 방식   style 태그의 내용으로 스타일 작성   &lt;style&gt;   div {     color: red;     margin: 10px;   } &lt;/style&gt;       - 인라인 방식   요쇼의 style 속성에 직접 스타일 작성   &lt;div style=\"color: red; margin: 10px;\"&gt;&lt;/div&gt;       - 링크 방식   링크 태그로 외부 CSS 파일을 가져와서 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ div {   color: red;   margin: 20px; }       - @import 방식   CSS의 @import 규칙으로 CSS문서 안에서 또 다른 CSS문서를 가져와 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ @import url(\"./sub.css\");  div {   color: red;   margin: 20px; }  /* sub.css */ .sub {   width: 10px;   height: 20px; }   CSS 선택자   - 기본   /* 전체 선택자 : 모든 요소 선택 */ * {   color: red; }  /* 태그 선택자 : 태그 이름의 요소 선택 */ div {   color: red; }  /* 클래스 선택자 : class 속성 값의 요소 선택  */ .cat {   color: red; }  /* 아이디 선택자 : id 속성 값의 요소 선택 */ #cat {   color: red; }       - 복합   /* 일치 선택자 : 선택자를 동시에 만족하는 요소 선택 */ div.cat {   color: red; }  /* 자식 선택자 : 자식 요소 선택 */ ul &gt; .cat {   color: red; }  /* 하위(후손) 선택자 : 하위 요소 선택. 띄어쓰기가 선택자의 기호 */ div .cat {   color: red; }  /* 인접 형제 선택자 : 다음 형제 요소 하나를 선택 */ .cat + li {   color: red; }  /* 일반 형제 선택자 : 다음 형제 요소 모두를 선택 */ .cat ~ li {   color: red; }       - 가상 클래스   /* hover : 마우스 커서가 올라가 있는 동안 */ a:hover {   color: red; }  /* active : 마우스를 클릭하고 있는 동안 */ a:active {   color: red; }  /* focus : 포커스되면 선택 */ /* focus가 될 수 있는 요소는 HTML 대화형 콘텐츠가 해당 */ /* input, a, button, label, select 등 여러 요소 */  /* HTML 대화형 콘텐츠 요소가 아니더라도, tabindex 속성을 사용한 요소도 focus가 될 수 있음 */  input:focus {   color: red; }  /* first-child : 형제 요소중 첫째라면 선택*/ .animals div:first-child {   color: red; }  /* last-child : 형제 요소중 막내라면 선택 */ .animals span:last-child {   color: red; }  /* nth-child : 형제 요소중 n째라면 선택 */ .animals *:nth-child(2) {   color: red; } .animals *:nth-child(2n) {   color: red; } .animals *:nth-child(2n+1) {   color: red; }  /* not : 아닌 요소 선택 */ .animals *:not(div) {   color: red; }       - 가상 요소   /* before : 내부 앞에 내용을 삽입 */ .cat::before {   content: \"앞\" }  /* after 내부 뒤에 내용을 삽입 */ .cat::after {   content: \"뒤\" }       - 속성   /* 속성 : 해당 속성을 포함한 요소 선택 */ [disabled] {   color: red; } [type] {   color: red; }  /* 속성-값 : 해당 속성을 포함하고 값이 x인 요소 선택 */ [type=\"password\"] {   color: red; }   스타일 상속   .animals {   color: red; }  &lt;div class=\"ecosystem\"&gt;생태계   &lt;div class=\"animals\"&gt;동물     &lt;div class=\"cat\"&gt;고양이&lt;/div&gt;     &lt;div class=\"dog\"&gt;강아지&lt;/div&gt;     &lt;div class=\"tiger\"&gt;호랑이&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"plant\"&gt;식물&lt;/div&gt; &lt;/div&gt;  생태계   동물     고양이     강아지     호랑이      식물       - 상속되는 CSS 속성들   모두 글자/문자 관련 속성들      font-style   font-weight   font-size   line-height   font-family   color   text-align   …       - 강제 상속      값에 inherit 넣어서 명시하면 상속됨   선택자 우선순위      같은 요소가 여러 선언의 대상이 된 경우, 어떤 선언의 CSS속성을 우선 적용할지 결정하는 방법   점수가 높은 선언 우선   점수가 같으면 마지막에 해석된 선언이 우선   body { color : red; } /* 전체 선택자 : 0점 */ * { color : orange; }  div { color : yellow; } /* 태그 선택자 : 1점 */  .cat { color: green; } /* Class 선택자 : 10점 */  #dog { color: blue; } /* ID 선택자 : 100점 */  &lt;div style=\"color: darkblue;\"&gt;Hi&lt;/div&gt; &lt;!-- 인라인 선언 : 1000점 --&gt;  div { color: purple !important; } /* !important : 999999점 */  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-basic/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 박스모델",
        "excerpt":"박스 모델   - 단위   px 픽셀 % 상대적 백분율 em 요소의 글꼴 크기 rem 루트 요소(html)의 글꼴 크기 vw 뷰포트 가로 너비의 백분율 vh 뷰포트 세로 너비의 백분율       - 색상 표현   이름 : red, royalblue, tomato // 브라우저에서 제공하는 색 이름 Hex 색상코드 : #000, #FFFFFF // 16진수 색상 RGB : rgb(255, 255, 255) // 빛의 삼원색 RGBA : rgba(0, 0, 0, 0.5) // 빛의 삼원색 + 투명도 HSL : hsl(120, 100%, 50%) // 색상, 채도, 명도 HSLA : hsla(120, 100%, 50%, 0.5) // 색상, 채도, 명도 + 투명도       - width, height   /* 요소의 가로/세로 너비 */ width, height {   기본값: auto; 브라우저가 너비를 계산   단위: px, em, vw; }       - max-width, max-height   /* 요소가 커질 수 있는 최대 가로/세로 너비 */ max-width, max-height {   기본값: none; 최대 너비 제한 없음   단위: px, em, vw; }       - min-width, min-height   /* 요소가 작아질 수 있는 최소 가로/세로 너비 */ min-width, min-height {   기본값: 0; 최소 너비 제한 없음   단위: px, em, vw; }       - margin   /* 요소의 외부 여백을 지정하는 단축 속성 */ margin {   기본값: 0; 외부 여백 없음   auto 브라우저가 여백을 계산. 가운데 정렬에 활용   단위: px, em, vw;   음수 사용 가능 }  적용 {   margin: 10px;  /* top, right, bottom, left*/   margin: 10px 20px;  /* top, bottom / left, right */   margin: 10px 20px 30px;  /* top / left, right / bottom */   margin: 10px 20px 30px 40px;  /* top / right / bottom / left */ }  개별 속성 {   margin-top: 10px;   margin-bottom: 10px;   margin-left: 10px;   margin-right: 10px; }       - padding   /* 요소의 내부 여백을 지정하는 단축 속성 */ padding {   기본값: 0; 내부 여백 없음   단위: px, em, vw;   %: 부모 요소의 가로 너비에 대한 비율로 지정   요소의 크기가 커짐 }  적용 {   padding: 10px;  /* top, right, bottom, left*/   padding: 10px 20px;  /* top, bottom / left, right */   padding: 10px 20px 30px;  /* top / left, right / bottom */   padding: 10px 20px 30px 40px;  /* top / right / bottom / left */ }  개별 속성 {   padding-top: 10px;   padding-bottom: 10px;   padding-left: 10px;   padding-right: 10px; }       - border   /* 요소의 테두리 선을 지정하는 단축 속성 */ border {   border: 두께 종류 색상;   요소의 크기가 커짐 }  적용 {   border: 4px solid black; }  두께 {   border-width: px, em, %; }  종류 {   기본값: none; 선 없음   border-style: solid; 실선   border-style: dashed; 파선   border-style: dotted; 점선   border-style: double; 두줄선   border-style: groove; 홈이 파여있는 모양   border-style: ridge; 솟은 모양(groove 반대)   border-style: inset; 요소 전체가 들어간 모양   border-style: outset; 요소 전체가 나온 모양 }  색상 {   기본값: black;   투명: transparent; }  모서리 {   /* 둥글게 깎기 */   기본값: 0;   border-radius: px, em, vw; }       - box-sizing   /* 요소의 크기 계산 기준을 지정 */ box-sizing {   기본값: content-box; 요소의 내용으로 크기 계산   box-sizing: border-box; 요소의 내용 + padding + border로 크기 계산 }       - overflow   /* 내용이 넘쳤을 때, 보여짐을 제어 */ overflow {   기본값: visible; 넘친 내용을 그대로 보여줌   overflow: hidden; 넘친 내용을 잘라냄   overflow: scroll; 넘친 내용을 잘라내고 스크롤바 생성   overflow: auto; 넘친 내용이 있는 경우에만 잘라내고 스크롤바 생성 }  개별속성 {   overflow-x   overflow-y }       - display   /* 화면 출력 특성 */ display {   기본값: block;   기본값: inline;   기본값: inline-block; 각 요소에 이미 지정되어 있는 값   display: flex; 플렉스 박스 (1차원 레이아웃)   display: grid; 그리드 (2차원 레이아웃)   display: none; 보여짐 특성 없음, 화면에서 사라짐   기타: table, table-row, table-cell 등; }       - opacity   /* 요소 투명도 */ opacity {   기본값: 1; 불투명   opacity: 0~1; 0부터 1사이의 소수점 숫자 }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-boxmodel/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-1. 데이터 입출력 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 자료구조 – A   - 자료 구조의 정의      자료의 표현과 그것과 관련된 연산   자료들을 조직하고 구조화하는 것   필요한 모든 연산들을 처리할 수 있음   프로그램 실행시간이 달라짐   - 자료 구조의 분류      선형 구조            배열       선형 리스트                    연속 리스트           연결 리스트                       스택       큐       데크           비선형 구조            트리       그래프           - 배열(Array)      동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합   정적인 자료구조   기억장소 추가가 어려움   데이터 삭제 시 데이터가 저장되어 있던 기억장소가 빈 공간으로 남아있어 메모리 낭비 발생   첨자를 이용하여 데이터에 접근   반복적인 데이터 처리 작업에 적합한 구조   동일한 이름의 변수를 사용하여 처리가 간편   첨자의 개수에 따라 n차원 배열이라고 부름   - 선형 리스트(Linear List)      일정한 순서에 의해 나열된 자료 구조   배열을 이용하는 연속 리스트, 포인터를 이용하는 연결 리스트로 구분   @ 연속 리스트(Contiguous List)      연속되는 기억장소에 저장되는 자료 구조   기억장소 이용 효율은 밀도가 1로서 가장 좋음   데이터 삽입, 삭제 시 자료의 이동이 필요   @ 연결 리스트(Linked List)      자료들을 반드시 연속적으로 배열시키지 않고 노드의 포인터 부분을 이용해서 서로 연결   노드의 삽입, 삭제 작업이 용이   기억공간이 연속적으로 놓여있지 않아도 저장 가능   순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않음   포인터를 찾는 시간이 필요해 접근 속도가 느림   중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘듬   - 스택(Stack)      리스트의 한쪽 끝으로만 자료의 삽입, 삭제가 이루어짐   후입선출(LIFO)   기억공간이 꽉 차있는 상태에서 삽입되면 Overflow 발생   기억공간이 비어있는 상태에서 삭제하면 Underflow 발생   삽입(PUSH), 삭제(POP), 마지막 삽입 자료(Top), 밑바닥(Bottom)   - 큐(Queue)      리스트의 한쪽에서는 삽입, 다른 한쪽에서는 삭제가 이루어짐   선입선출(FIFO)   시작과 끝을 표시하는 두 개의 포인터가 있음   프런트(F, Front) 포인터 : 가장 먼저 삽입된 자료의 기억공간을 가리킴. 삭제 작업   리어(R, Rear) 포인터 : 가장 마지막에 삽입된 자료의 기억공간을 가리킴. 삽입작업   운영체제의 작업 스케줄링에 사용   - 트리(Tree)      정점(Node)과 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 형태   하나의 기억공간을 노드(Node), 노드와 노드를 연결하는 선을 링크(Link)   가족의 계보, 조직도 등을 표현하기 적합   노드 : 자료 항목과 다른 항목에 대한 가지를 합친 것   근 노드(Root Node) : 트리의 맨 위에 있는 노드   차수(Degree) : 각 노드에서 뻗어 나온 가지의 수   단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식이 하나도 없는 노드   자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들   부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들   형제 노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들   트리의 차수 : 노드들의 차수 중에서 가장 많은 수       2. 데이터저장소 / 데이터베이스 / DBMS – A   - 데이터저장소      데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것   논리 데이터 저장소 : 데이터 간 연관성, 제약조건을 식별하여 논리적인 구조로 조직화   물리 데이터 저장소 : 물리적 특성을 고려하여 하드웨어적인 저장장치에 저장   데이터베이스를 구축하는 과정과 동일   - 데이터베이스      상호 관련된 데이터들의 모임   통합된 데이터(Integrated Data) : 중복을 배제한 데이터의 모임   저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료   운영 데이터(Operational Data) : 조직의 고유한 업무를 수행하는 데 없어서는 안 될 자료   공용 데이터(Shared Data) : 공동으로 소유하고 유지하는 자료   - DBMS(DataBase Management System)      사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 S/W   데이터의 종속성과 중복성의 문제를 해결   모든 응용 프로그램들이 DB를 공용할 수 있도록 관리   DB의 구성, 접근 방법, 유지관리에 대한 모든 책임을 짐   DBMS의 필수 기능            정의 기능 : 데이터 Type과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시       조작 기능 : 검색, 갱신, 삽입, 삭제 등의 인터페이스 수단을 제공       제어 기능 : 데이터의 무결성이 유지되도록 제어, 보안 유지, 권한 검사, 병행 제어           장점            데이터의 논리적, 물리적 독립성 보장       데이터의 중복을 피할 수 있어 기억 공간 절약       자료를 공동으로 이용할 수 있음       데이터의 일관성을 유지할 수 있음       데이터의 무결성을 유지할 수 있음       보안을 유지할 수 있음       데이터를 표준화 할 수 있음       통합 관리가 가능       최신의 데이터 유지 가능       실시간 처리 가능           단점            DB 전문가 부족       전산화 비용 증가       Overhead 발생       Backup과 Recovery이 어려움       시스템이 복잡           - 데이터의 독립성      데이터의 독립성은 DBMS의 궁극적 목표   논리적 독립성 : 데이터의 논리적 구조를 변경해도 응용 프로그램은 변경되지 않음   물리적 독립성 : 응용 프로그램에는 영향을 주지 않고, 데이터의 물리적 구조만을 변경       3. 데이터 입출력 – B   - 데이터 입출력 개요      DB에 데이터를 입력하거나 출력하는 작업   데이터를 조작하는 모든 행위를 의미. SQL 사용   개발 코드 내에 SQL 코드를 삽입하거나, 객체와 데이터를 연결하는 데이터 접속(Data Mapping)   논리적 기능을 수행하기 위한 작업의 단위 또는 한번에 수행되야 할 연산들을 트랜잭션이라고 함   - SQL(Structured Query Language)      많은 회사에서 관계형 데이터베이스(RDB)를 지원하는 언어로 채택   관계대수와 관계해석을 기초로 한 혼합 데이터   질의어지만 질의 기능뿐만 아니라, 데이터 구조 정의, 조작, 제어기능을 모두 갖춤   데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 구분            DDL : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의, 변경, 삭제       DML : 저장된 데이터를 실질적으로 처리       DCL : 보안, 무결성, 회복, 병행수행 제어 등을 정의하는데 사용           - 데이터 접속(Data Mapping)      프로그래밍 코드와 DB의 데이터를 연결하는 것   SQL Mapping : 코드 내에 SQL을 직접 입력하여 DBMS 객체에 접속. JDBC, ODBC, MyBatis   ORM(Object-Relational Mapping) : 객체와 RDB의 데이터를 연결. JPA, Hibernate, Django   - 트랜잭션(Transaction)      DB 상태를 변환시키는 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행돼야 할 연산   TCL : 트랜잭션을 제어하기 위한 명령어. COMMIT, ROLLBACK, SAVEPOINT            COMMIT : 트랜잭션이 수행한 변경 내용을 DB에 저장       ROLLBACK : 모든 변경 작업을 취소하고 이전 상태로 되돌림       SAVEPOINT(=CHECKPOINT) : ROLLBACK 할 저장점을 지정               4. 절차형 SQL – B   - 절차형 SQL 개요      프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL   프로그래밍 언어에 비해 효율은 떨어지지만, 연속적인 작업들을 처리하는데 적합   다양한 기능을 수행하는 저장 모듈 생성할 수 있음   DBMS 엔진에서 직접 실행돼 입출력 패킷이 적은 편   BEGIN ~ END 형식의 블록 구조로 되어 있어 기능별 모듈화 가능   프로시저 : 트랜잭션 언어, 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업 수행   트리거 : 이벤트가 발생할 때마다 관련 작업이 자동으로 수행   사용자 정의 함수 : 예약어 RETURN을 사용하여 처리 결과를 단일값으로 반환   - 절차형 SQL의 테스트와 디버깅      디버깅을 통해 기능의 적합성 여부를 검증, 실행을 통해 결과를 테스트   테스트 전에 생성을 통해 구문 오류나 참조 오류의 존재 여부 확인   SHOW  명령어를 통해 내용을 확인하고 문제를 수정   디버깅을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인   DB에 변화를 줄 수 있는 삽입 등의 SQL 문을 주석으로 처리하고, 출력문을 이용해 확인   - 쿼리 성능 최적화      데이터 입출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화   성능 측정 도구인 APM을 사용하여 최적화 할 쿼리 선정   옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp5/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-2. 통합 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 단위 모듈 테스트 – B   - 단위 모듈 테스트의 개요      모듈이 정해진 기능을 정확히 수행하는지 검증   단위 테스르라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법 사용   모듈을 단독적으로 실행할 수 있는 환경과 테스트에 필요한 데이터 모두 준비   에러를 쉽게 발견하고 수정할 수 있음   시스템 수준의 오류는 잡아낼 수 없음   - 테스트 케이스      사용자의 요구사항을 정확하게 준수했는지를 확인하기 위함   테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당   직관적인 테스트는 검증이 누락되거나 불필요한 반복으로 인력과 시간을 낭비 할 수 있음   ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스 구성 요소            식별자       테스트 항목       입력 명세       출력 명세       환경 설정       특수 절차 요구       의존성 기술           - 테스트 프로세스      게획 및 제어 -&gt; 분석 밀 설계 -&gt; 구현 및 실현 -&gt; 평가 -&gt; 완료       2. 개발 지원 도구 – B   - 통합 개발 환경(IDE; Integrated Development Environment)      편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합하여 제공   통합 개발 환경을 제공하는 S/W   코드의 자동 생성 및 컴파일 가능, 추가 기능을 위한 도구를 추가할 수 있음   오류가 발생할 부분을 시각화하므로 수정이 용이   다양한 서비스와 연동하여 개발에 편의를 제공하고 필요한 정보를 공유   이클립스, 비주얼 스튜디오, 엑스 코드, 안드로이드 스튜디오, IDEA 등   - 빌드 도구      빌드는 소스 코드 파일들을 실행할 수 있는 제품 S/W로 변환하는 과정 또는 결과물   전처리, 컴파일 등의 작업들을 수행하는 S/W   Ant            자바 프로젝트의 공식 빌드 도구       XML 기반의 빌드 스크립트, 자유도와 유연성이 높음       개발자가 모든 것을 정의, 스크립트 재사용이 어려움           Maven            Ant의 대안으로 개발됨       규칙이나 표준이 존재하여 예외 사항만 기록, 컴파일과 빌드를 동시에 수행       의존성을 설정하여 라이브러리를 관리           Gradle            Ant와 Mavn을 보완하여 개발       안드로이드 스튜디오의 공식 빌드 도구       의존성을 활용하여 Groovy 기반의 빌드 스크립트 사용           - 기타 협업 도구      서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구   업무 보조 도구 포함   다양한 플랫폼에서 사용할 수 있도록 제공   익숙하지 않거나 이용할 의지가 없으면 오히려 협업의 방해 요소가 될 수 있음   협업 도구 종류            일정 관리 : Google Calendar, Wunderlist, Trello, Jira, Flow       정보 공유 및 커뮤니케이션 : Slack, Jandi, Taskworld       디자인 : Sketch, Zeplin       기타 : Evernote(아이디어 공유), Swagger(API 문서화로 협업도움), Github          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp6/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-3. 제품 소프트웨어 패키징",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 패키징 – B   - 소프트웨어 패키징의 개요      모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것   사용자를 중심으로 진행   모듈화하여 패키징   일반적인 배포 형태로 패키징   사용자의 편의성 및 실행 환경을 우선적으로 고려   - 패키징 시 고려사항      사용자의 시스템 환경에 필요한 최소 환경을 정의   UI는 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 매뉴얼과 일치   하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공   편의성을 고려한 안정적인 배포가 중요   패키징의 변경 및 개선에 대한 관리를 항상 고려   - 패키징 작업 순서      애자일 기법의 경우 2~4주 내에서 지정하며, 각 주기가 끝날 때마다 패키징 수행   주기별로 패키징한 결과물은 테스트 서버에 배포   최종 패키징한 결과물은 사용할 수 있도록 온라인 또는 오프라인으로 배포   기능 식별 -&gt; 모듈화 -&gt; 빌드 -&gt; 사용자 환경 분석 -&gt; 패키징 및 적용시험 -&gt; 패키징 변경 개선 -&gt; 배포       2. 릴리즈 노트 작성 – B   - 릴리즈 노트의 개요      릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서   테스트 진행 방법에 대한 결과와 S/W 사양에 대한 개발팀의 정확한 준수 여부 확인 가능   전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유   버전 관리나 릴리즈 정보를 체계적으로 관리   초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시에 제공   포함된 기능이나 사용 환경에 대한 내용을 확인   개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공   철저한 테스트를 거친 것, 사양에 대한 최종 승인을 얻은 후 문서화 되어 제공   - 릴리즈 노트 초기 버전 작성 시 고려사항      정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성   변경 또는 개선된 항목에 대한 이력 정보들도 작성   표준 형식은 없음   - 릴리즈 노트 추가 버전 작성 시 고려사항      특수한 상황이 발생하는 경우 릴리즈 노트를 추가로 작성   모든 수정된 내용을 담아 릴리즈 노트를 작성   기능 업그레이드를 완료한 경우에는 릴리즈 버전을 출시하고 릴리즈 노트를 작성   요구사항에 의해 추가나 수정된 경우 별도의 릴리즈 버전으로 출시하고 릴리즈 노트 작성   - 릴리즈 노트 작성 순서      모듈 식별 -&gt; 릴리즈 정보 확인 -&gt; 릴리즈 노트 개요 작성 -&gt; 영향도 체크 -&gt; 정식 릴리즈 노트 작성 -&gt; 추가 개선 항목 식별       3. 디지털 저작권 관리(DRM) – A      저작권이란 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한   복제하기 쉬운 저작물에 대해 이를 막기 위한 기술적인 방법을 통칭해 저작권 보호 기술이라 함   - 디지털 저작권 관리(DRM; Digital Right Management)의 개요      디지털 콘텐츠 관리 및 보호 기술   원본 콘텐츠가 아날로그인 경우 디지털로 변환한 후 패키저로 DRM 패키징 수행   크기가 작은 경우 실시간 패키징 수행, 크기가 큰 경우 미리 패키징 수행 후 배포   패키징을 수행하면 암호화된 전자서명이 포함되고 라이선스 정보가 클리어링 하우스에 등록   콘텐츠를 사용하기 위해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인   종량제 방식을 적용한 경우 실제 사용량을 측정하여 이용한 만큼의 요금 부과   - 디지털 저작권 관리의 흐름도      클리어링 하우스 : 저작권에 대한 사용 권한, 라이선스 발급, 결제 관리 등 수행   콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자   패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램   콘텐츠 분배자 : 암호화된 콘텐츠를 유통하는 곳이나 사람   콘텐츠 소비자 : 콘텐츠를 구매해서 사용하는 주체   DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램   보안 컨테이너 : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치   - 디지털 저작권 관리의 기술 요소      암호화(Encryption) : 콘텐츠를 암호화하고 전자 서명을 할 수 있는 기술   키 관리(Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술   암호화 파일 생성(Packager) : 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술   식별 기술(Identification) : 콘텐츠에 대한 식별 체계 표현 기술   저작권 표현(Right Expression) : 라이선스의 내용 표현 기술   정책 관리(Policy Management) : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술   크랙 방지(Tamper Resistance) : 크랙에 의한 콘텐츠 사용 방지 기술   인증(Authentication) : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술       4. 소프트웨어 버전 등록 – B   - 소프트웨어 패키징의 형상 관리      형상관리(SCM)는 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동   S/W 변경의 원인을 알아내고 제어, 적절히 변경되고 있는지 확인하며 해당 담당자에게 통보   S/W 개발의 전 단계에 적용되는 활동. 유지보수 단계에서도 수행   S/W 개발의 전체 비용을 줄이고, 방해 요인이 최소화되도록 보증   - 형상 관리의 중요성      변경 사항을 체계적으로 추적하고 통제할 수 있음   무절제한 변경을 방지할 수 있음   발견된 버그나 수정 사항을 추적할 수 있음   S/W는 형태가 없어 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로 사용   - 형상 관리 기능      형상 식별 : 이름과 관리 번호를 부여, Tree 구조로 구분하여 수정 및 추적이 용이하도록 함   버전 제어 : 다른 버전의 형상 항목을 관리, 특정 절차와 도구를 결합   형상 통제 : 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정   형상 감사 : 기준선의 무결성을 평가하기 위해 공식적으로 승인하는 작업   형상 기록 : 결과를 기록, 관리하고 보고서를 작성하는 작업   - 소프트웨어의 버전 등록 관련 주요 용어      Repository : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장   Import : 아무것도 없는 저장소에 처음으로 파일을 복사   Check-Out : 저장소에서 파일을 받아옴. 버전관리를 위한 파일들도 받아옴   Check-In : 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신   Commit : 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료   Update : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화   - 소프트웨어 버전 등록 과정      Import -&gt; Check-Out -&gt; Commit -&gt; Update -&gt; Diff       5. 소프트웨어 버전 관리 도구 – A   - 공유 폴더 방식      로컬 컴퓨터의 공유 폴더에 저장되어 관리   약속된 공유 폴더에 매일 복사   담당자는 파일을 자기 PC로 복사한 후 컴파일 하여 이상 유무를 확인   파일 오류가 확인되면, 개발자에게 수정 의뢰   이상 없으면 개발자들이 동작 여부 다시 확인   파일의 변경 사항을 DB에 기록하여 관리   SCCS, RCS, PVCS, QVCS   - 클라이언트/서버 방식      버전 관리 자료가 중앙 시스템에 저장되어 관리되는 방식   서버의 자료를 PC로 복사하여 작업한 후 변경된 내용을 서버에 반영   모든 버전 관리는 서버에서 수행   하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력   서버에 문제가 생기면 협업 및 버전 관리 작업 중단   CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce   @ Subversion(서브버전, SVN)      CVS를 개선한 것   서버에는 최신 버전의 파일들과 변경 내역이 관리   서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영   모든 개발 작업은 trunk 디렉터리에서 수행   추가 작업은 branches 디렉터리 안에 별도의 디렉터리 만들어 작업   완료후 trunk 디렉터리와 병합   커밋 할 때마다 리비전이 1씩 증가   서버는 주로 유닉스 사용   소스가 오픈되어 있어 무료로 사용 가능   CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능   - 분산 저장소 방식      하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리   작업한 후 변경된 내용을 로컬에서 우선 반영한 후, 이를 원격 저장소에 반영   원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업할 수 있음   @ Git      로컬 저장소와 원격 저장소 존재   로컬 저장소는 실제 개발을 진행하는 장소로, 버전 관리가 수행   원격 저장소는 버전을 공동 관리하는 곳   버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업 가능   branch를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅 가능   파일의 변화를 스냅샷으로 저장. 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름 파악 가능       6. 빌드 자동화 도구 – B   - 빌드 자동화 도구의 개념      빌드란 소스 코드 파일들을 컴파일한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정   빌드 자동화 도구는 빌드를 포함하여 테스트 및 배포를 자동화하는 도구   애자일 환경같은 지속적인 통합 개발 환경에서 유용하게 활용   - Jenkins      Jenkins는 Java 기반의 오픈소스 형태, 가장 많이 사용되는 빌드 자동화 도구   서블릿 컨테이너에서 실행되는 서버 기반 도구   SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능   친숙한 Web GUI 제공으로 사용이 쉬움   여러 대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능   - Gradle      Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구. 안드로이드 앱 개발 환경에서 사용   플러그인을 설정하면 Java, C/C++, Python 등의 언어도 빌드 가능   Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용   실행할 처리 명령을 모아 Task로 만든 후 Task 단위로 실행   Task를 재사용하거나 공유할 수 있는 빌드 캐시 기능을 지원해 빌드의 속도를 향상시킬 수 있음  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp7/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-4. 애플리케이션 테스트 관리",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 애플리케이션 테스트 – B   - 애플리케이션 테스트의 개념      잠재되어 있는 결함을 찾아내는 일련의 행위   고객의 요구사항을 만족시키는지 확인(Validation)   기능을 정확히 수행하는지 검증(Verrfication)   개발할 소프트웨어의 유형을 분류하고 특성을 정리해서 중점적으로 테스트할 사항을 정리   - 애플리케이션 테스트의 필요성      프로그램 실행 전에 오류를 발견하여 예방   제품의 신뢰도 향상   새로운 오류의 유입 예방   최소한의 시간과 노력으로 많은 결함을 찾아낼 수 있음   - 애플리케이션 테스트의 기본 원리      잠재적인 결함은 줄일 수 있지만 완벽한 소프트웨어 테스팅은 불가능   결함 대부분은 특정 모듈에 집중. 20%의 코드에서 80%의 결함이 발견. 파레토 법칙 적용   동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 살충제 패러독스 발생   정황에 따라 테스트를 다르게 수행   결함을 제거해도 요구사항을 만족시키지 못하면 품질이 높다고 말할 수 없음. 오류 부재의 궤변   테스트와 위험은 반비례   작은 부분에서 시작하여 점점 확대하며 진행   개발자와 관계없는 별도의 팀에서 수행       2. 애플리케이션 테스트의 분류 – B   - 프로그램 실행 여부에 따른 테스트   @ 정적 테스트      프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석   개발 초기에 결함 발견 가능. 개발 비용을 낮출 수 있음   워크스루, 인스펙션, 코드 검사 등   @ 동적 테스트      프로그램을 실행하여 오류를 찾는 테스트. 개발 모든 단계에서 수행 가능   블래박스 테스트, 화이트박스 테스트   - 테스트 기반에 따른 테스트   @ 명세 기반 테스트      요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인   동등 분할, 경계 값 분석 등   @ 구조 기반 테스트      내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인   구문 기반, 결정 기반, 조건 기반 등   @ 경험 기반 테스트      유사 소프트웨어나 기술 등에 대한 경험을 기반으로 함   요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 효과적   에러 추정, 체크 리스트, 탐색적 테스팅   - 시각에 따른 테스트   @ 검증(Verification) 테스트      개발자의 시각에서 명세서대로 완성됐는지 테스트   @ 확인(Validation) 테스트      사용자의 시각에서 요구한대로 제품이 완성됐는지, 정상 동작하는지 테스트   - 목적에 따른 테스트   @ 회복 테스트      결함을 주어 실패하도록 한 후 올바르게 복구되는지 확인   @ 안전 테스트      불법적인 침입으로부터 시스템을 보호할 수 있는지 확인   @ 강도 테스트      과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 정상적으로 실행되는지 확인   @ 성능 테스트      실시간 성능이나 전체적인 효율성을 진단하는 테스트   @ 구조 테스트      내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트   @ 회귀 테스트      변경 또는 수정된 코드에 새로운 결함이 없음을 확인   @ 병행 테스트      기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교       3. 테스트 기법에 따른 애플리케이션 테스트 – A   - 화이트박스 테스트      원시 코드를 오픈시킨 상태에서 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계   구조적 테스트. 프로시저 설계의 제어 구조를 사용하여 테스트 케이스를 설계   테스트 과정의 초기에 적용   모듈 안의 작동을 직접 관찰   모든 문장을 한 번 이상 실행하여 수행   선택, 반복 등의 분기점 부분들을 수행함으로써 논리적 경로를 제어   - 화이트박스 테스트의 종류   @ 기초 경로 검사      대표적인 화이트박스 테스트 기법   절차적 설계의 논리적 복잡성을 측정할 수 있게 해줌   실행 경로의 기초를 정의하는 데 지침으로 사용   @ 제어 구조 검사      조건 검사 : 논리적 조건을 테스트하는 설계 기법   루프 검사 : 반복 구조에 초점을 맞춰 실시하는 설계 기법   데이터 흐름 검사 : 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 설계 기법   - 화이트박스 테스트의 검증 기준      문장 검증 기준 : 모든 구문이 한 번 이상 수행되도록 설계   분기 검증 기준 : 모든 조건문이 한 번 이상 수행되도록 설계   조건 검증 기준 : 모든 조건문에 대해 조건문이 True, False 경우가 한 번 이상 수행되도록 설계   분기/조건 기준 : 모든 조건문과 각 조건문에 포함된 개별 조건식의 결과가 True, False인 경우가 한 번 이상 수행되도록 설계   - 블랙박스 테스트      각 기능이 완전히 작동되는 것을 입증하는 테스트. 기능 테스트   요구사항 명세서를 보면서 테스트하는 것. 구현된 기능을 테스트   인터페이스에서 실시되는 테스트   테스트 과정의 후반부에 적용   - 블랙박스 테스트의 종류   @ 동치 분할 검사      입력 자료에 초점을 맞춰 검사   타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 함. 자료에 맞는 결과가 출력되는지 확인   @ 경계값 분석      동치 분할 기법을 보완하기 위함   중간값보다 경계값에서 오류가 발생될 확률이 높다는 점 이용   입력 조건의 경계값을 테스트 케이스로 선정하여 검사   @ 원인-효과 그래프 검사      입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 후 효용성 높은 케이스 선정하여 검사   @ 오류 예측 검사      과거의 경험이나 확인자의 감각으로 테스트   보충적 검사 기법. 데이터 확인 검사   @ 비교 검사      여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트       4. 개발 단계에 따른 애플리케이션 테스트 – A   - 개발 단계에 따른 애플리케이션 테스트      코드 상의 오류뿐만 아니라 요구 분석의 오류, 설계 인터페이스 오류 등도 발견할 수 있음   애플리케이션 테스트 + 소프트웨어 개발 단계 = V-모델   요구사항 -&gt; 분석 -&gt; 설계 -&gt; 구현 -&gt; // 단위테스트 -&gt; 통합테스트 -&gt; 시스템티스트 -&gt; 인수테스트   - 단위 테스트(Unit Test)      설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트   사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행   구조 기반 테스트와 명세기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행            구조 기반 테스트 : 화이트박스 테스트       명세 기반 테스트 : 블랙박스 테스트           - 통합 테스트(Integration Test)      단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트   모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사   - 시스템 테스트(System Test)      개발된 S/W가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검   실제 사용 환경과 유사하게 만든 테스트 환경에서 수행   기능적 요구사항 : 블랙박스 테스트 시행   비기능적 요구사항 : 화이트박스 테스트 시행   - 인수 테스트(Acceptance Test)      개발한 S/W가 사용자의 요구사항을 충족하는지에 중점   사용자가 직접 테스트   문제가 없으면 사용자는 S/W를 인수하고 프로젝트 종료   사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부 확인   운영상의 인수 테스트 : 시스템 관리자가 수행   계약 인수 테스트 : 계약상의 인수/검수 조건을 준수하는지 여부 확인   규정 인수 테스트 : 규정에 맞게 개발되었는지 확인   알파 테스트            개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트       통제된 환경에서 시행. 문제점을 사용자와 개발자가 함께 확인           베타 테스트            최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트       사용자가 직접 테스트       개발자에 의해 제어되지 않은 상태에서 테스트       오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고               5. 통합 테스트 – A      단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트   비점진적 통합 방식            모든 모둘이 미리 결합되어 있는 프로그램 전체를 테스트. 빅뱅 통합 테스트       규모가 작은 소프트웨어에 유리. 단시간 내에 테스트 가능       오류 발견 및 장애 위치 파악 및 수정이 어려움           점진적 통합 방식            모듈 단위로 단계적으로 통합하면서 테스트. 하향식, 상향식, 혼합식       오류 수정이 용이하고, 인터페이스와 연관된 오류를 완전히 테스트 할 가능성 높음           - 하향식 통합 테스트      상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트   깊이 우선 통합법이나 넓이 우선 통합법 사용   테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음   상위 모듈에서는 테스트 케이스를 사용하기 어려움   절차            주요 제어 모듈은 작성된 프로그램 사용. 종속 모듈은 Stub으로 대체       하위 모듈인 Stub들이 한 번에 하나씩 실제 모듈로 교체됨       모듈이 통합될 때마다 테스트를 실시       새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시           - 상향식 통합 테스트      하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트   Stub은 필요하지 않지만, 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 Cluster가 필요 -절차            하위 모듈들을 Cluster로 결합       더미 모듈인 Driver를 작성       통합된 클러스터 단위로 테스트       테스트가 완료되면 Cluster는 프로그램 구조의 상위로 이동하여 결합하고 Driver는 실제 모듈로 대체           - 테스트 Driver와 Stub의 차이점                  구분       Driver       Stub                       필요시기       상위 모듈 없음       하위 모듈 없음                 테스트방식       상향식       하향식                 공통점       소프트웨어 개발과 테스트를 병행할 경우 이용                         차이점       인터페이스 역할, 원래 모듈로 교체       가짜 모듈의 역할, 작성하기 쉬움           - 혼합식 통합 테스트      하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합. 샌드위치식 통합 테스트 방법   - 회귀 테스팅      이미 테스트된 프로그램의 테스팅을 반복하는 것   변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트   반복해서 테스트 함   변경된 부분을 테스트할 수 있는 테스트 케이스만을 선정하여 수행   대표적인 테스트 케이스를 선정   파급 효과가 높은 부분이 포함된 테스트 케이스를 선정   실제 수정이 발생한 모듈 또는 컴포넌트에서 시행하는 테스트 케이스 선정       6. 애플리케이션 테스트 프로세스 – B   - 애플리케이션 테스트 프로세스      사용자의 요구대로 만들어졌는지, 결함은 없는지 등을 테스트   계획 -&gt; 분석 및 디자인 -&gt; 테스트 케이스 및 시나리오 작성 -&gt; 수행 -&gt; 결과 평가 및 리포팅 -&gt; 결함 추적 및 관리       7. 테스트 케이스 / 테스트 시나리오 / 테스트 오라클 – B   - 테스트 케이스      구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 명세 기반 테스트의 설계 산출물   검토 및 자료확보 -&gt; 위험 평가 및 우선순위 결정 -&gt; 요구사항 정의 -&gt; 구조 설계 및 방법 결정 -&gt; 테스트 케이스 정의 -&gt; 타당성 확인 및 유지 보수   - 테스트 시나리오      테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스들을 묶은 집합. 구체적인 절차를 명세한 문서   테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정   테스트 순서를 미리 정함으로써 테스트 항목을 빠짐없이 수행   작성시 유의사항            여러 개의 시나리오로 분리하여 작성       사용자의 요구사항과 설계 문서 등을 토대로 작성       유스케이스간 업무 흐름이 정상적인지를 테스트 할 수 있도록 작성       개발된 모듈 또는 프로그램 간의 연계가 정상적으로 동작하는지 테스트할 수 있도록 작성           - 테스트 오라클      테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법   결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 게산하거나 확인   특징            제한된 검증 : 모든 테스트 케이스에 적용할 수 없음       수학적 기법 : 수학적 기법을 이용하여 구할 수 있음       자동화 가능 : 실형, 결과 비교, 커버리지 측정 등을 자동화 할 수 있음           종류            참 오라클 : 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공. 모든 오류 검출       샘플링 오라클 : 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과 제공       추정 오라클 : 샘플링 오라클 개선. 나머지 입력 값들에 대해서 추정으로 처리       일관성 검사 : 변경이 있을 때, 수행 전과 후의 결과 값이 동일한지 확인               8. 테스트 자동화 도구 – B   - 테스트 자동화의 개념      반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용한 것   휴먼 에러를 줄이고 테스트 정확성을 유지하면서 품질을 향상시킴   - 테스트 자동화 도구의 장점 / 단점      장점            반복적인 작업을 자동화하여 인력 및 시간을 줄임       향상된 테스트 품질 보장       요구사항 등을 일관성 있게 검증       객관적인 평가 기준을 제공       다양한 표시 형태로 제공       UI가 없는 서비스도 정밀 테스트 가능           단점            도구의 사용 방법에 대한 교육 및 학습 필요       프로세스 단계별로 적용하기 위한 시간, 비용, 노력이 필요       비공개 상용 도구의 경우 고가의 추가 비용 필요           - 테스트 자동화 수행 시 고려사항      재사용 및 측정이 불가능한 테스트 프로그램은 제외   용도에 맞는 적절한 도구를 선택해서 사용   환경 설정 및 습득 기간을 고려해서 프로젝트 일정을 계획   프로젝트 초기에 테스트 엔지니어의 투입 시기를 계획   - 테스트 자동화 도구의 유형      정적 분석 도구            프로그램을 실행하지 않고 분석       작성된 소스 코드를 이해하고 있어야만 분석 가능           테스트 실행 도구            스크립트 언어를 사용하여 테스트를 실행       데이터 주도 접근 방식       키워드 주도 접근 방식           성능 테스트 도구            인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부 확인           테스트 통제 도구            테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행       형상 관리 도구, 결함 추적/관리 도구 등           테스트 하네스 도구            애플리케이션의 컴포넌트 및 모듈을 테스트하는 환경의 일부분       테스트를 지원하기 위해 생성된 코드와 데이터를 의미       테스트가 실행될 환경을 시뮬레이션 하여 정상적으로 테스트되도록 함       구성 요소                    테스트 드라이버 : 모듈 테스트 수행 후의 결과를 도출           테스트 스텁 : 타 모듈의 기능을 단순히 수행하는 도구           테스트 슈트 : 테스트 케이스의 집합           테스트 케이스 : 테스트 항목의 명세서           테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서           목 오브젝트 : 예정된 행위를 수행하는 객체                               9. 결함 관리 – B   - 결함의 정의      설계한 것과 다르게 동작하거나 다른 결과가 발생되는 것   - 결함 관리 프로세스      계획 -&gt; 기록 -&gt; 검토 -&gt; 수정 -&gt; 재확인 -&gt; 추적 및 모니터링 -&gt; 분석 및 보고서 작성   - 결함 추적 순서      등록 -&gt; 검토 -&gt; 할당 -&gt; 수정 -&gt; 조치 보류 -&gt; 종료 -&gt; 해제   - 결함 관리 도구      Mantis : 단위별 작업 내용 기록하여 결함 추적 가능   Trac : 결함 추적은 물론 결함을 통합하여 관리   Redmine : 프로젝트 관리 및 결함 추적 가능   Bugzilla : 결함을 지속적으로 관리할 수 있는 도구. 결함의 심각도와 우선 순위 지정 가능  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp8/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-5. 인터페이스 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 모듈 연계를 위한 인터페이스 기능 식별 – A   - 모듈 연계의 개요      모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것   @ EAI(Enterprise Application Integration)      기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션   비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확장성을 높임   Point-to-Point            1 : 1 연결       변경 및 재사용이 어려움           Hub &amp; Spoke            허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식       확장 및 유지 보수가 용이       허브 장애 발생 시 시스템 전체에 영향을 미침           Message Bus(ESB 방식)            미들웨어를 두어 처리하는 방식       확장성이 뛰어나며 대용량 처리가 가능           Hybrid            Hub &amp; Spoke와 Message Bus의 혼합 방식       그룹 내에서는 Hub &amp; Spoke, 그룹 간에는 Message Bus 방식 사용       한 가지 방식으로 EAI 구현 가능       데이터 병목 현상을 최소화           @ ESB(Enterprise Service Bus)      애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션   통합 측면에서 EAI와 유사하지만, 애플리케이션 보다는 서비스 중심의 통합을 지향   특정 서비스에 국한되지 않고 범용적으로 사용하기 위해 결합도를 약하게 유지   관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원 가능       2. 인터페이스 기능 구현 정의 – B   - 인터페이스 기능 구현 정의에 대한 개요      인터페이스를 실제로 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술   컴포넌트 명세서 확인 -&gt; 인터페이스 명세서 확인 -&gt; 일관된 인터페이스 기능 구현 정의 -&gt; 정의된 인터페이스 기능 구현 정형화   - 모듈 세부 설계서      모듈의 구성 요소와 세부적인 동작 등을 정의한 설계서   컴포넌트 명세서            컴포넌트의 개요 및 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세 등을 정의           인터페이스 명세서            컴포넌트 명세서의 항목 중 인터페이스 클래스의 세부 조건 및 기능 등을 정의               3. 인터페이스 예외 처리 – B   - 인터페이스 예외 처리의 개요      구현된 인터페이스가 동작하는 과정에서 기능상 예외 상황이 발생 했을 때 이를 처리하는 절차   - 데이터 통신을 이용한 인터페이스 예외 처리      JSON, XML 등 인터페이스 객체를 이용해 구현한 인터페이스 동작이 실패한 경우를 대비   예외 케이스를 정의하고 각 예외 케이스마다 예외 처리 방법을 기술   - 인터페이스 엔티티를 이용한 인터페이스 예외 처리      동작이 실패할 경우를 대비해 해당 엔티티에 인터페이스의 실패 상황과 원인 등을 기록하고 사용자 및 관리자에서 알려주는 방식       4. 인터페이스 보안 – B   - 인터페이스 보안의 개요      보안 취약점을 분석한 후 적절한 보안 기능을 적용   - 인터페이스 보안 기능 적용      네트워크 영역            스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화 설정       IPSec, SSL, S-HTTP 등의 방식으로 적용           애플리케이션 영역            애플리케이션 코드 상의 보안 취약점을 보완하는 방향           데이터베이스 영역            접근 권한과 프로시저, 트리거 등 DB 동작 객체의 보안 취약점에 보안 기능을 적용       암호화나 익명화 등 데이터 자체의 보안 방안도 고려               5. 연계 테스트 – B   - 연계 테스트의 개요      연계 시스템과 구성 요소가 정상적으로 동작하는지 확인하는 활동   연계 테스트 케이스 작성 -&gt; 연계 테스트 환경 구축 -&gt; 수행 -&gt; 검증       6. 인터페이스 구현 검증 – A   - 인터페이스 구현 검증의 개요      인터페이스가 정상적으로 문제없이 작동하는지 확인하는 것   - 인터페이스 구현 검증 도구      검증하기 위해서 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 통합 테스트 필요   테스트 자동화 도구를 이용하면 효율적으로 수행 가능   xUnit            Java, C++ 등 다양한 언어를 지원하는 단위 테스트 프레임워크           STAF            서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원           FItNesse            웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원           NTAF            협업 기능과 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크           Selenium            다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크           watir            Ruby를 사용하는 애플리케이션 테스트 프레임워크           - 인터페이스 구현 감시 도구      인터페이스 동작 상태를 APM을 사용하여 모니터링 할 수 있음   종합적인 정보를 조회하고 분석할 수 있음   Scouter, Jennifer 등   APM            리소스 방식 : Nagios, Zabbix, Cacti 등       End-to-End 방식 : VisualVM, Jennifer, Scouter 등          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp9/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-1. 논리 데이터베이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 데이터베이스 설계 – A   - 데이터베이스 설계의 개념      DB 구조에 맞게 변형한 후 DBMS로 DB를 구현하여 일반 사용자들이 사용하게 하는 것   - 데이터베이스 설계 시 고려사항      무결성 : 저장된 데이터가 정해진 제약 조건을 항상 만족   일관성 : 특정 질의에 대한 응답이 처음부터 끝까지 일정해야 함   회복 : 장애 발생 직전의 상태로 복구할 수 있어야 함   보안 : 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호   효율성 : 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화   DB 확장 : 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함   - 데이터베이스 설계 순서      요구조건 분석 -&gt; 개념적 설계 -&gt; 논리적 설계 -&gt; 물리적 설계 -&gt; 구현   - 요구 조건 분석      DB를 사용할 사람들로부터 필요한 용도를 파악하는 것   사용자에 따른 수행 업무와 필요 데이터 수집   요구 조건 명세서 작성   - 개념적 설계(정보 모델링, 개념화)      현실 세계에 대한 인식을 추상적 개념으로 표현   개념 스키마 모델링과 트랜잭션 모델링을 병행 수행   DBMS에 독립적인 E-R 다이어그램으로 작성   DBMS에 독립적인 개념 스키마 설계   - 논리적 설계(데이터 모델링)      특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정   논리적 구조의 데이터로 모델화   개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계   트랜잭션의 인터페이스를 설계   RDB라면 테이블을 설계하는 단계   - 물리적 설계(데이터 구조화)      논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환   DB 파일의 저장 구조 및 액세스 경로 결정   데이터가 컴퓨터에 저장되는 방법을 묘사   - 데이터베이스 구현      도출된 데이터베이스 스키마를 파일로 생성하는 과정   DDL을 이용하여 DB 스키마를 기술한 후 컴파일하여 빈 DB 파일 생성   빈 DB 파일에 데이터 입력   응용 프로그램을 위한 트랜잭션 작성   DB 접근을 위한 응용 프로그램 작성       2. 데이터 모델의 개념 – B   - 데이터 모델의 정의      현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형   데이터 모델 구성 요소 : 객체, 속성, 관계   데이터 모델 종류 : 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델   데이터 모델에 표시할 요소 : 구조, 연산, 제약 조건   - 데이터 모델의 구성 요소      개체(Entity) : 현실 세계의 대상체   속성(Attribute) : 데이터의 가장 작은 논리적 단위. 데이터 항목 또는 데이터 필드에 해당   관계(Relationship) : 개체 간의 관계 또는 속성 간의 논리적인 연결   - 개념적 데이터 모델      현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정   타입들 간의 관계를 이용하여 현실 세계를 표현   정보 모델이라고도 함   E-R 모델   - 논리적 데이터 모델      개념적 구조를 컴퓨터가 처리할 수 있도록 변환하는 과정   데이터 타입과 이들간의 관계를 이용하여 현실 세계를 표현   특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용   관계 모델, 계층 모델, 네트워크 모델   - 데이터 모델에 표시할 요소      구조 : 데이터 구조 및 정적 성질   연산 : 실제 데이터를 처리하는 작업에 대한 명세   제약 조건 : 실제 뎅터의 논리적인 제약 조건       3. 데이터 모델의 구성요소 - 개체(Entity) – A   - 개체의 정의 및 특징      DB에 표현하려는 것. 현실 세계의 대상체   어떤 정보를 제공하는 역할   영속적으로 존재하는 개체의 집합   독립적으로 존재하거나 그 자체로서도 구별 가능   유일한 식별자에 의해 식별 가능   업무 프로세스에 의해 이용됨   다른 개체와 하나 이상의 관계가 있음   - 개체명 지정 방법      해당 업무에서 사용하는 용어로 지정   약어 사용은 제한   단수 명사 사용   개체명은 유일해야 함   의미에 따라 이름을 부여       4. 데이터 모델의 구성요소 - 속성(Attribute) – B   - 속성의 정의 및 특징      DB를 구성하는 가장 작은 논리적 단위   데이터 항목 또는 데이터 필드에 해당   개체를 구성하는 항목   개체의 특성을 기술   속성의 추를 Degree 또는 차수라고 함   - 속성의 종류   @ 속성의 특성에 따른 분류      기본 속성            업무 분석을 통해 정의한 속성       가장 많고 일반적       업무상 코드로 정의한 속성은 기본 속성에서 제외           설계 속성            설계 과정에서 도출해내는 속성       데이터 모델링을 위해 업무를 규칙화하려고 새로 만들거나 변형하여 정의하는 속성           파생 속성            다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성       되도록 적은 수를 정의하는 것이 좋음           @ 개체 구성 방식에 따른 분류      기본키 속성 : 개체를 식별할 수 있는 속성   외래키 속성 : 다른 개체와의 관계에서 포함된 속성   일반 속성 : 개체에 포함도어 있고 기본키, 외래키에 포함되지 않은 속성   - 속성 후보 선정 원칙      속성으로 지정할 후보는 최대한 많이 선택하는 것이 좋음   원시 속성으로 판단되는 속성 후보는 버리지 않음   속성 후보군을 만들고 가장 근접한 개체에 할당   - 속성명 지정 원칙      업무에서 사용하는 용어로 지정   서술형으로 지정하지 않음   약어의 사용 제한   개체명은 속성명으로 사용할 수 없음   개체에서 유일하게 식별 가능하도록 지정       5. 데이터 모델의 구성 요소 - 관계(Relationship) – B   - 관계의 정의      개체와 개체 사이의 논리적인 연결   - 관계의 형태      1 : 1   1 : N   N : M   - 관계의 종류      종속 관계   중복 관계   재귀 관계   배타 관계       6. E-R(개체-관계) 모델 – A   - E-R 모델의 개요      개념적 데이터 모델의 대표   개체와 개체간의 관계를 기본 요소로 데이터를 개념적인 논리 데이터로 표현하기 위한 방법   대체 타입과 관계 타입을 이용해 현실 세계를 개념적으로 표현   데이터를 개체, 관계, 속성으로 묘사   특정 DBMS를 고려한 것은 아님   E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음   일반화 계층 같은 복잡한 개념들이 첨가되어 확장된 모델로 발전   - E-R 다이어그램      기호를 사용하여 시각적으로 표현한 그림   역할을 가진 모든 실체들을 표현   뷰들을 하나로 단일화   @ 피터 첸 표기법      개체 : 사각형   관계 : 마름모   속성 : 타원   다중값 속성 : 이중 타원   기본키 속성 : 밑줄 타원   복합 속성 : 복수 타원   1:1, 1:N, N:M 등 개체 간 관계에 대한 대응수를 선 위에 기술 : 관계   개체 타입과 속성을 연결 : 선, 링크   @ 정보 공학 표기법      개체 : 사각형   개체명 : 박스 바깥쪽 위   속성 : 기본키 속성과 일반 속성을 분리하여 표시   관계 : 관계 표기 기호를 사용            필수 : ㅣ       선택적 : ㅇ       다중 : &lt;           @ 바커 표기법      개체 : 모서리가 둥근 박스   개체명 : 박스 안 가장 위   속성            값이 반드시 저장되어야 하는 경우 : *       값이 저장될 수도, 안될 수도 있는 경우 : ㅇ           관계            필수 : ㅡ       선택적 : ………       다중 : &lt;               7. 관계형 데이터베이스의 구조 – A   - 관계형 데이터베이스의 개요      개체나 관계를 모두 릴레이션이라는 표로 표현   개체를 표현하는 개체 릴레이션, 관계를 나타내는 관계 릴레이션으로 구분   장점 : 간결하고 보기 편리하며, 다른 DB로 변환이 용이   단점 : 성능이 다소 떨어짐   - 관계형 데이터베이스의 Relation 구조      구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성   @ 튜플      릴레이션을 구성하는 각각의 행   속성의 모임으로 구성   파일 구조에서 레코드와 같은 의미   튜플의 수를 Cardinality 또는 기수, 대응수라고 함   @ 속성      DB를 구성하는 가장 작은 논리적 단위   파일 구조상의 데이터 항목 또는 데이터 필드에 해당   개체의 특성을 기술   속성의 수를 Degree 또는 차수라고 함   @ 도메인      하나의 Attribute가 취할 수 있는 같은 타입의 Atomic 값들의 집합   값의 합법 여부를 시스템이 검사하는데 이용   - 릴레이션의 특징      한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 튜플들은 모두 상이함   튜플 사이에는 순서가 없음   튜플의 삽입, 삭제 등의 작업으로 릴레이션은 시간에 따라 변함   릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음   속성의 명칭은 유일해야 하지만, 값은 동일한 값이 있을 수 있음   속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장   8. 관계형 데이터베이스의 제약 조건 : Key – A      제약 조건이란 키를 이용하여 입력되는 데이터에 제한을 주는 것.   개체 무결성 제약, 참조 무결성 제약 등이 해당   - Key의 개념 및 종류      키는 조건에 만족하는 튜플을 찾거나 정렬할 때 튜플을 서로 구분할 수 있는 기준이 되는 Attribute   @ 후보키(Candidate Key)      튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합. 즉 기본키로 사용할 수 있는 속성들   모든 릴레이션에는 반드시 하나 이상의 후보키 존재   유일성과 최소성을 만족시켜야 함   유일성 : 하나의 키 값으로 하나의 튜플만을 유일하게 식별   최소성 : 유일하게 식별하는 데 꼭 필요한 속성으로만 구성   @ 기본키(Primary Key)      후보키 중에서 특별히 선정된 주키로 중복된 값을 가질 수 없음   특정 튜플을 유일하게 구별할 수 있는 속성   후보키의 성질을 가짐. 유일성과 최소성을 가지며, 튜플을 식별하기 위해 반드시 필요   NULL 값을 가질 수 없음   @ 대체키(Alternate Key)      후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키. 보조키라고도 함   @ 슈퍼키(Super Key)      속성들의 집합으로 구성된 키   슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음   유일성은 만족시키지만, 최소성은 만족시키지 못함   @ 외래키(Foreign Key)      다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합   참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현   외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없음       9. 관계형 데이터베이스의 제약 조건 : 무결성 - B   - 무결성의 개념 및 종류      무결성이란 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성   부정확한 자료가 DB 내에 저장되는 것을 방지하기 위한 제약 조건   @ 개체 무결성(Entity Integrity)      기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정   @ 도메인 무결성(Domain Integrity)      주어진 속성 값이 정의된 도메인에 속한 값이어야 함   @ 참조 무결성(Referential Integrity)      외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함   릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정   외래키와 참조하려는 테이블의 기본키는 도메인과 속성 개수가 같아야 함   @ 사용자 정의 무결성      속성 값들이 사용자가 정의한 제약 조건에 만족해야 하는 규정   - 데이터 무결성 강화      데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 함   DB 구축 과정에서 정의   애플리케이션            데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 추가       복잡한 규칙 등은 애플리케이션 내에서 처리       장점 : 복잡한 무결성 조건의 구현이 가능       단점 : 분산되어 있어 관리가 힘들고, 개별 시행으로 적정성 검토가 어려움           데이터베이스 트리거            트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가       장점 : 통합 관리가 가능하고, 복잡한 요구 조건의 구현이 가능       단점 : 운영 중 변경이 어렵고, 사용상 주의가 필요           제약 조건            제약 조건을 설정하여 무결성을 유지       장점 : 통합 관리 가능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지       단점 : 복잡한 제약 조건의 구현과 예외적인 처리가 불가능           10. 관계대수 및 관계해석 – A   - 관계대수의 개요      RDB에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어   연산자와 연산규칙을 제공하는 언어로 피연산자가 릴레이션, 결과도 릴레이션   연산의 순서를 명시   순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음   - Select      선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산   행에 해당하는 튜플을 구하는 것. 수평 연산   시그마(σ) 기호를 사용   표기 형식 : σ  (R)   비교 연산이 허용되며, 논리 연산자를 사용하여 여러 조건들을 하나의 조건으로 결합 가능   σ Avg &gt; 90 (성적) :  릴레이션에서 평균 90점 이상인 튜플을 추출하시오   - Project      속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산   중복이 발생하면 제거됨   열에 해당하는 Attribute를 추출 하는 것. 수직 연산자   파이(π) 기호를 사용   표기 형식 : π  (R)   π Name, Avg (성적) :  릴레이션에서 Name과 Avg 속성을 추출하시오   - Join      공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산   차수는 합, Cartesian Product는 곱   Cartesian Product를 수행한 다음 Select를 수행한 것과 같음   ▷◁ 기호를 사용   R ▷◁ 키속성r = 키속성s S   성적 ▷◁ No = No 학적부 :  릴레이션과  릴레이션을 No 속성을 기준으로 합치시오   자연 조인            중복된 속성을 제거하여 같은 속성을 한 번만 표기하는 방법       자연 조인이 성립되려면 두 릴레이션의 속성명과 도메인이 같아야 함           - Division      X ⊃ Y인 R(X), S(Y)가 있을 때, S가 가진 속성을 제외한 속성만을 구하는 연산   ÷ 기호를 사용   표기 형식 : R [속성r ÷ 속성s] S   - 일반 집합 연산자      집합 이론에서 사용하는 연산자   UNION ∪ : 합집합   INTERSECTION ∩ : 교집합   DIFFERENCE - : 차집합   CARTESIAN PRODUCT X : 교차곱   - 관계 해석      수학의 술어 해석에 기반을 두고 RDB를 위해 제안   관계 데이터의 연산을 표현하는 방법. 계산 수식을 사용   원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성   튜플 관계해석과 도메인 관계해석이 있음   관계해석과 관계대수는 RDB를 처리하는 기능과 능력면에서 동등   관계대수로 표현한 식은 관계해석으로 표현 가능   질의어로 표현       11. 정규화(Normalization) – A   - 정규화의 개요      종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개 바람직한 스키마로 만드는 과정   분해하는 과정   차수가 높아질수록 만족시켜야 할 제약 조건이 늘어남   DB의 논리적 설계 단계에서 수행   논리적 처리 및 품질에 큰 영향을 미침   일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장   정규화 수준이 높을수록 유연한 데이터 구축이 가능. 데이터의 정확성 높아짐   물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하됨   - 정규화의 목적      데이터 구조의 안정성 및 무결성 유지   어떠한 릴레이션이라도 DB 내에서 표현 가능   효과적인 검색 알고리즘을 생성   중복을 배제하여 이상의 발생 방지 및 자료 저장 공간의 최소화 가능   데이터 삽입 시 릴레이션을 재구성할 필요성 줄임   데이터 모형의 단순화 가능   속성의 배열 상태 검증 가능   개체와 속성의 누락 여부 확인이 가능   자료 검색과 추출의 효율성 추구   - 이상의 개념 및 종류      정규화를 거치지 않으면 데이터들이 불필요하게 중복되어 릴레이션 조작시 문제 발생   삽입 이상 : 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입   삭제 이상 : 삭제할 때 의도와는 상관없는 값들도 함께 삭제   갱신 이상 : 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생김   - 정규화의 원칙      정보의 무손실 표현. 정보의 손실이 있어서는 안됨   분리의 원칙. 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현   데이터의 중복성이 감소되어야 함   - 정규화 과정      1NF : 도메인이 원자값만으로 되어 있는 정규형   2NF : 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족   3NF : 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음   BCNF : 결정자가 모두 후보키인 정규형   4NF : 다치 종속이 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족   5NF : 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형   정규화 과정 정리            도메인이 원자값       부분적 함수 종속 제거       이행적 함수 종속 제거       결정자이면서 후보키가 아닌 것 제거       다치 종속 제거       조인 종속성 이용       도부이결다조               12. 반정규화(Denormalization) – B      정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 행위   시스템의 성능이 향상, 관리 효율성 증가   데이터의 일관성 및 정합성이 저하   - 테이블 통합      조인되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행   1:1 관계 테이블 통합, 1:N 관계 테이블 통합, 슈퍼타입/서브타입 테이블 통합   고려사항            검색은 편하지만 레코드 증가로 인해 처리량 증가       통합으로 인해 입력, 수정, 삭제 규칙이 복잡해질 수 있음       Not Null, Default, Check 등의 제약조건을 설계하기 어려움           - 테이블 분할      테이블을 수직 또는 수평으로 분할하는 것   수평 분할            레코드를 기준으로 테이블을 분할       사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할           수직 분할            하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할           - 중복 테이블 추가      여러 테이블에서 데이터를 사용하거나 다른 서버 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 효율성 향상   중복 테이블을 추가하는 경우            정규화로 인해 수행 속도가 느려지는 경우       많은 범위의 데이터를 자주 처리해야 하는 경우       특정 범위의 데이터만 자주 처리해야 하는 경우       처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우           - 중복 속성 추가      조인해서 데이터를 처리할 때 데이터 조회 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가   데이터 무결성 확보가 어렵고, 디스크 공간이 추가로 필요   중복 속성을 추가하는 경우            조인이 자주 발생하는 속성인 경우       접근 경로가 복잡한 속성인 경우       액세스의 조건으로 자주 사용되는 속성인 경우       기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우           고려사항            테이블 중복과 속성의 중복을 고려       데이터 일관성 및 무결성에 유의       SQL 그룹 함수를 이용하여 처리할 수 있어야 함       저장 공간의 지나친 낭비를 고려               13. 시스템 카탈로그 – A   - 시스템 카탈로그의 의미      시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 DB   사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블   카탈로그들이 생성되면 데이터 사전에 저장   - 시스템 카탈로그 저장 정보      시스템 카탈로그에 저장된 정보를 메타 데이터라고 함   메타 데이터의 유형            DB 객체 정보 : Table, Index, View 등의 구조 및 통계 정보       사용자 정보 : 아이디, 패스워드, 접근 권한 등       테이블의 무결성 제약 조건 정보 : 기본키, 외래키, NULL 값 허용 여부 등       함수, 프로시저, 트리거 등에 대한 정보           - 카탈로그 특징      일반 이용자도 SQL을 이용하여 내용 검색할 수 있음   INSERT, DELETE, UPDATE로 카탈로그를 갱신하는 것은 허용되지 않음   DBMS에 따라 상이한 구조   DBMS가 스스로 생성하고 유지함   변화가 있으면 시스템이 자동으로 갱신함   위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 가져야 함   - 카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템      DDL Compiler : 메타 데이터를 갖는 테이블로 변환하여 데이터 사전에 저장   DML Compiler : DML문을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신   Data Directory            데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템       시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있음       데이터 디렉터리는 시스템만 접근할 수 있음           질의 최적화기 : 사용자의 요구를 효율적인 형태로 변환하고 질의를 처리하는 좋은 전략 모색   트랜잭션 처리기 : 트랜잭션 문제를 해결하여, 사용자가 DB 자원을 배타적으로 이용할 수 있도록 함  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp10/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 글꼴, 문자",
        "excerpt":"글꼴   - font-style   /* 글자의 기울기 */ font-style {   기본값: normal; 기울기 없음   font-style: italic; 이텔릭체   font-style: oblique; 기울어진 글자 }       - font-weight   /* 글자의 두께 */ font-weight {   기본값: normal or 400; 기본 두께   font-weight: bold or 700; 두껍게   font-weight: bolder; 부모 요소보다 두껍게   font-weight: lighter; 부모 요소보다 얇게   font-weight: 100 ~ 900; 100단위의 숫자 9개 }       - font-size   /* 글자의 크기 */ font-size {   기본값: 16px; 기본 크기   단위: px, em, rem;   %: 부모 요소의 폰트 크기에 대한 비율   font-size: larger; 부모 요소보다 크게   font-size: smaller; 부모 요소보다 작게   font-size: xx-small ~ xx-large; 가장 작은 크기 ~ 가장 큰 크기까지 7단계 크기 }       - line-height   /* 한 줄의 높이, 행간과 유사 */ line-height {   기본값: normal; 브라우저의 기본 정의   line-height: 숫자; 요소의 글꼴 크기의 배수로 지정   단위: px, em, rem;   %: 요소의 글꼴 크기의 비율로 지정 }       - font-family   font-family {   font-family: serif; 바탕체 계열   font-family: sans-serif; 고딕체 계열   font-family: monospace; 고정너비 글꼴 계열   font-family: cursive; 필기체 계열   font-family: fantasy; 장식 글꼴 계열 }   Hello World! Hello World! Hello World! Hello World! Hello World!  문자   - color   /* 글자의 색상 */ color {   기본값: rgb(0, 0, 0); 검정색   color: 색상; 기타 지정 가능한 색상 }       - text-align   /* 문자의 정렬 방식 */ text-align {   기본값: left; 왼쪽 정렬   text-align: right; 오른쪽 정렬   text-align: center; 가운데 정렬   text-align: justify; 양쪽 정렬 }       - text-decoration   /* 문자의 장식(선) */ text-decoration {   기본값: none; 장식 없음   text-decoration: underline; 밑줄   text-decoration: overline; 윗줄   text-decoration: line-through; 중앙 선 }   Hello World! Hello World! Hello World! Hello World!      - text-indent   /* 문자 첫 줄의 들여쓰기 */ text-indent {   기본값: 0; 들여쓰기 없음   단위: px, em, rem;   %: 요소의 가로 너비에 대한 비율   음수 사용 가능   반대는 내어쓰기 outdent }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-font/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-2. 물리 데이터베이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 사전 조사 분석 – B      논리적 구조료 표현된 논리적 DB를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환   데이터 단위는 저장 레코드   꼭 포함되어야 할 것은 저장 레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계 등   여러 가지 타입의 저장 레코드 집합이라는 면에서 단순한 파일과 다름   물리적 DB 구조는 DB 시스템 성능에 중대한 영향을 미친다   고려사항            인덱스 구조       레코드 크기       레코드 개수       트랜잭션의 갱신과 참조 성향       개념 스키마의 변경 여부 검토       트랜잭션들의 수행속도를 높이기 위한 고려       파일 크기의 변화 가능성           기존 시스템을 분석하여 파악   물리적 설계 옵션            반응시간       공간 활용도       트랜잭션 처리량           - 데이터 명명 규칙 파악      데이터 표준화 및 논리 DB 설계의 결과물 등을 통해 파악   서로 일관성 유지   동일 명칭 부여의 근거   중복 구축 등을 방지   도메인과 데이터 사전에 대한 지식 필요   도메인 : 객체에 포함된 속성들의 데이터 타입, 크기 등을 표준화 규칙에 따라 일관성 있게 정의한 것   데이터 사전            일관성 있는 데이터 이름과 인터페이스를 제공하기 위해 데이터 속성의 논리명, 물리명, 용어정의를 기술       프로젝트에서 사용하는 명칭 부여의 근거           - 시스템 자원 파악      시스템 자원은 DB 설치에 영향을 미칠 수 있는 물리적 요소. 사전에 미리 파악해야 함   하드웨어 자원, 운영체제 및 DBMS 버전, DBMS 파라미터 정보   - 데이터베이스 관리 요소 파악      DB 관리 요소는 운영과 관련된 관리 요소. 미리 파악해야 함   파악한 후 DB 시스템 조사 분석서 작성       2. 데이터베이스 저장 공간 설계 – B   - 테이블      Row와 Column으로 구성   모든 데이터는 테이블에 저장됨   논리 설계 단계의 개체에 대응하는 객체   DBMS 종류에 따라 테이블의 명칭과 기능 등은 약간씩 차이가 있음   @ 일반 테이블      대부분의 DBMS에서 표준 테이블로 사용되는 테이블   Row 위치는 속성 값에 상관없이 데이터가 저장되는 순서에 따라 결정   @ 클러스터드 인덱스 테이블      기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블   접근 경로가 단축됨   @ 파티셔닝 테이블      대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블   대용량의 데이터를 효과적으로 관리할 수 있음   파티션 키를 잘못 구성하면 성능 저하 등의 역효과 초래   범위분할 : 지정한 열의 값을 기준으로 분할   해시분할 : 해시 함수를 적용한 결과 값에 따라 분할   조합분할 : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할   @ 외부 테이블      DB에서 일반 테이블처럼 이용할 수 있는 외부 파일. 객체로 존재   데이터웨어하우스에서 ETL 등의 작업에 유용하게 사용   @ 임시 테이블      트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블   트랜잭션이 종료되면 삭제됨   임시로 사용하는 테이블   - Column      테이블의 열. 데이터 타입, 길이 등으로 정의됨   데이터 타입은 데이터의 일관성 유지를 위해 사용되는 가장 기본적인 것   도메인을 정의한 경우 도메인에 따라 데이터의 타입과 길이 정의   두 컬럼의 데이터 타입이나 길이가 다르면 DBMS 내부적으로 데이터 타입을 변환한 수 비교 연산 수행   참조 관계인 컬럼들은 데이터 타입과 길이가 일치해야 함   - 테이블스페이스      테이블이 저장되는 논리적인 영역. 하나 또는 그 이상의 테이블 저장 가능   테이블을 저장하면 논리적으로는 테이블스페이스에 저장, 물리적으로는 연관된 데이터 파일에 저장   나눠 관리하면 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장됨   고려사항            업무별로 구분하여 지정       대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장       테이블과 인덱스는 분리하여 저장       LOB 타입의 데이터는 독립적인 공간으로 지정               3. 트랜잭션 분석 / CRUD 분석 – B   - 트랜잭션 정의      DB의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 연산   병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위   시스템이 응답하기 위한 상태 변환 과정의 작업 단위   - 트랜잭션의 특성      Atomicity(원자성)            트랜잭션의 연산은 완료(Commit)되든지 전혀 반영되지 않도록 복구(Rollback)되어야 함       모든 명령은 반드시 완벽히 수행되야 하며, 오류 발생 시 트랜잭션 전부가 취소돼야 함           Consistency(일관성)            실행을 성공적으로 완료하면 언제나 일관성 있는 DB 상태로 변환       고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야 함           Isolation(독립성, 격리성, 순차성)            트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없음       완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음           Durability(영속성, 지속성)            완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영           - CRUD 분석      Create, Read, Update, Delete   CRUD 매트릭스를 작성하여 분석   트랜잭션의 주기별 발생 횟수를 파악하고, 테이블에 저장되는 데이터의 양을 유추할 수 있음   많은 트랜잭션이 몰리는 테이블을 파악할 수 있음   연결 지연이나 타임아웃 오류를 방지할 수 있음   - CRUD 매트릭스      Row에는 프로세스를, Column에는 테이블을, 행과 열이 만나는 위치에는 변화를 표시   프로세스의 트랜잭션이 테이블에 수행하는 작업을 검증   복수의 변화를 줄 때는 C &gt; D &gt; U &gt; R의 우선순위 적용   불필요하거나 누락된 테이블 또는 프로세스를 찾음   - 트랜잭션 분석      테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB 용량을 산정하고 구조를 최적화   업무 개발 담당자가 수행   디스크 입출력 분산을 통한 성능 향상을 가져올 수 있음   - 트랜잭션 분석서      단위 프로세스와 CRUD 매트릭스를 이용하여 작성       4. 인덱스 설계 – A   - 인덱스의 개념      &lt;키 값, 포인터&gt; 쌍으로 구성되는 데이터 구조   물리적 구조와 밀접한 관계   물리적 구조에 접근하는 방법 제공   파일의 레코드에 대한 액세스를 빠르게 수행   삽입, 삭제가 수시로 일어나는 경우, 인덱스의 개수를 최소로 하는 것이 효율적   인덱스가 없으면 모든 데이터 페이지를 확인하는 TABLE SCAN 발생   기본키를 위한 인덱스를 기본 인덱스, 기본 인덱스가 아닌 인덱스를 보조 인덱스라고 함   DBMS에서는 모든 기본키에 대해서 자동적으로 기본 인덱스를 생성함   레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터트 인덱스라 함            클러스터드 인덱스                    인덱스 키의 순서에 따라 데이터가 정렬되어 저장           인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있음           삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬해야 함           한 개의 릴레이션에 하나의 인덱스만 생성할 수 있음                       넌클러스터드 인덱스                    키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식           데이터 검색을 위해 인덱스를 검색하여 실제 데이터의 위치를 확인해야 하므로 검색 속도가 떨어짐           한 개의 릴레이션에 여러 개의 인덱스를 만들 수 있음                           - 트리 기반 인덱스      인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것   B 트리 인덱스            루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 검색       포인터들이 트리 노드에 오름차순으로 저장       모든 리프 노드는 같은 레벨에 있음           B+ 트리 인덱스            단말 노드가 아닌 노드로 구성된 인덱스 세트와 단말 노드로만 구성된 순차 세트로 구분       인덱스 세트에 있는 노드들은 경로로만 제공       순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킴       단말 노드만을 이용한 순차 처리 가능           - 비트맵 인덱스      인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용   목적은 Row의 주소를 제공하는 것   분포도가 좋은 컬럼에 적합하며, 성능 향상 효과를 얻을 수 있음   효율적인 논리 연산이 가능하고 저장 공간이 작음   다중 조건을 만족하는 튜플의 개수 계산에 적합   동일한 값이 반복되는 경우가 많아 압축 효율이 좋음   - 함수 기반 인덱스      컬럼의 값 대신 특정 함수나 수식을 적용하여 산출된 값을 사용   B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용   데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하 발생할 수 있음   사용자 정의 함수일 경우 시스템 함수보다 부하가 더 큼   대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용하게 사용됨   - 비트맵 조인 인덱스      다수의 조인된 객체로 구성된 인덱스   비트맵 인덱스와 물리적 구조가 동일   - 도메인 인덱스      개발자가 필요한 인덱스를 직접 만들어 사용하는 것. 확장형 인덱스   프로그램에서 제공하는 인덱스처럼 사용할 수도 있음   - 인덱스 설계      분명하게 드러난 컬럼에 대해 기본적인 인덱스를 먼저 지정   테이블, 컬럼 등 선정 -&gt; 인덱스 최적화 수행 -&gt; 인덱스 정의서 작성   - 인덱스 대상 테이블 선정 기순      MULTI BLOCK READ 수에 따라 판단   랜덤 액세스가 빈번한 테이블   특정 범위나 특정 순서로 데이터 조회가 필요한 테이블   다른 테이블과 순차적 조인이 발생되는 테이블   - 인덱스 대상 컬럼 선정 기준      컬럼의 분포도가 10~15% 이내인 컬럼   분포도가 10~15% 이상이어도 부분 처리를 목적으로 하는 컬럼   조회 및 출력 조건으로 사용되는 컬럼   기본키와 Unique키 제약 조건을 사용한 컬럼   수정이 빈번하지 않은 컬럼   ORDER BY, GROUP BY, UNION이 빈번한 컬럼   분포도가 좁은 컬럼은 단독 인덱스로 생성   인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스로 생성   - 인덱스 설계 시 고려사항      새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있음   인덱스를 지나치게 많이 만들면 오버헤드 발생   넓은 범위를 인덱스로 처리하면 많은 오버헤드 발생   인덱스를 만들면 추가적인 저장 공간이 필요   인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계       5. View 설계 – A   - View의 개요      접근이 허용된 자료만을 제한적으로 보여주기 위해 기본 테이블로부터 유도된 가상 테이블   물리적으로 존재하지 않지만, 있는 것처럼 간주   임시적인 작업을 위한 용도로 활용   조인문의 사용 최소화로 사용상의 편의성을 최대화   - View의 특징      기본 테이블과 같은 형태의 구조를 사용, 조작도 기본 테이블과 거의 같음   물리적으로 구현되어 있지 않음   데이터의 논리적 독립성을 제공   관리가 용이하고 명령문이 간단해짐   뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용   기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야 삽입, 삭제, 갱신등의 연산 가능   정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음   뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 삭제됨   - View의 장단점      장점            논리적 데이터 독립성 제공       동일 데이터에 동시에 여러 사용자의 상이한 응용이나 요구 지원       데이터 관리를 간단하게 해줌       접근 제어를 통한 자동 보안이 제공           단점            독립적인 인덱스를 가질 수 없음       뷰가 정의를 변경할 수 없음       삽입, 삭제, 갱신 연산에 제약이 따름           - View 설계 순서      대상 테이블 선정 -&gt; 대상 컬럼 선정 -&gt; 정의서 작성   - View 설계시 고려 사항      반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성   사용할 데이터를 다양한 관점에서 제시해야 함   데이터의 보안 유지를 고려하여 설계       6. 클러스터 설계 – A   - 클러스터의 개요      동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법   클러스터링키로 지정된 컬럼 값의 순서대로 저장, 여러 개의 테이블이 하나의 클러스터에 저장   - 클러스터의 특징      데이터 조회 속도는 향상. 입력, 수정, 삭제 성능은 저하   데이터의 분포도가 넓을수록 유리   저장 공간을 절약할 수 있음   저장 공간이 줄어듬   대용량 처리 트랜잭션은 클러스터링 안하는게 좋음   처리 범위가 넓은 경우는 단일 테이블 클러스터링 사용   조인이 많이 발생하는 경우는 다중 테이블 클러스터링 사용   파티셔닝된 테이블에는 클러스터링 할 수 없음   클러스터링 하면 디스크 I/O가 줄어듬   클러스터드 인덱스를 생성하면 접근 성능이 향상됨   - 클러스터 대상 테이블      분포도가 넓은 테이블   대량의 범위를 자주 조회하는 테이블   입력, 수정, 삭제가 자주 발생하지 않는 테이블   자주 조인되어 사용되는 테이블   ORDER BY, GROUP BY, UNION이 빈번한 테이블       7. 파티션 설계 – A   - 파티션의 개요      대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것   성능 저하를 방지할 뿐만 아니라 데이터 관리가 쉬워짐   파티션키 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장   데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행됨   - 파티션의 장단점      장점            데이터 접근 시 액세스 범위를 줄여 쿼리 성능 향상       디스크의 성능 향상       속도가 빠름       데이터 손상 정도를 최소화 할 수 있음       데이터 가용성이 향상       입출력을 분산시킬 수 있음           단점            세심한 관리가 요구됨       조인에 대한 비용이 증가       용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능 저하           - 파티션의 종류      범위 분할            지정한 열의 값을 기준으로 분할           해시 분할            해시 함수를 적용한 결과 값에 따라 데이터를 분할       범위 분할의 단점을 보완. 데이터를 고르게 분산할 때 유용       특정 데이터가 어디에 있는지 판단할 수 없음       데이터가 고르게 분포한 컬럼에 효과적           조합 분할            범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할       범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용           - 파티션키 선정 시 고려 사항      테이블 접근 유형에 따라 파티셔닝이 이뤄지도록 선정   이력성 데이터는 파티션 생성주기와 소멸주기를 일치시켜야 함   - 인덱스 파티션      파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것   파티션된 테이블의 종속 여부            Local Partitioned Index : 테이블 파티션과 인덱스 파티션이 1:1 대응       Global Partitioned Index : 테이블 파티션과 인덱스 파티션이 독립적으로 구성       Local Partitioned Index가 데이터 관리가 쉬움           인덱스 파티션키 컬럼의 위치            Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 같음       Non-Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다름               8. 분산 데이터베이스 설계 – A   - 분산 데이터베이스 정의      논리적으로는 하나의 시스템에 속하지만 물리적으로 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 DB   데이터의 처리나 이용이 많은 지역에 DB를 위치해 데이터 처리가 해당 지역에서 해결   - 분산 데이터베이스의 구성 요소      분산 처리기 : 자체 처리 능력. 지리적으로 분산되어 있는 컴퓨터 시스템   분산 데이터베이스 : 지리적으로 분산되어 있는 DB. 해당 지역의 특성에 맞게 DB 구성   통신 네트워크 : 분산 처리기들을 통신망으로 연결하는 통신 네트워크   - 분산 데이터베이스 설계 시 고려 사항      작업부하의 노드별 분산 정책   지역의 자치성 보장 정책   데이터의 일관성 정책   사이트나 회선의 고장으로부터의 회복 기능   통신 네트워크를 통한 원격 접근 기능   - 분산 데이터베이스의 목표      위치 투명성 : 실제 위치를 알 필요 없이 DB의 논리적인 명칭만으로 액세스 가능   중복 투명성 : 데이터가 중복되어 있더라도 사용자는 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업 수행   병행 투명성 : 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음   장애 투명성 : 장애에도 불구하고 트랜잭션을 정확하게 처리   - 분산 데이터베이스의 장단점      장점            지역 자치성이 높음       자료의 공유성 향상       분산 제어 가능       시스템 성낭 향상       중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음       효용성과 융통성이 높음       신뢰성 및 가용성 높음       점진적 시스템 용량 확장이 용이           단점            DBMS가 수행할 기능이 복잡       DB 설계가 어려움       개발 비용 증가       처리 비용 증가       잠재적 오류 증가           - 분산 데이터베이스 설계      전역 관계망을 논리적 측면에서 소규모 단위로 분할한 후, 분할된 결과를 복수의 노드에 할당하는 과정으로 진행   @ 테이블 위치 분산      테이블을 각기 다른 서버에 분산시켜 배치   테이블의 구조를 변경하지 않으며, 다른 DB의 테이블과 중복되지 않게 배치   해당 테이블들이 놓일 서버들을 미리 설정해야 함   @ 분할      테이블의 데이터를 분할하여 분산시키는 것   분할 규칙            완전성 : 전체 데이터를 대상으로 분할       재구성 : 분할된 데이터는 관계 연산을 활용하여 본래의 데이터로 재구성할 수 있어야 함       상호 중첩 배제 : 분할된 데이터는 서로 다른 분할의 항목에 속하지 않아야 함           주요 분할 방법            수평 분할 : 속성의 값을 기준으로 Row 단위로 분할       수직 분할 : 속성 단위로 분할           @ 할당      동일한 분할을 여러 개의 서버에 생성하는 분산 방법   비중복 할당 방식            분산 DB의 단일 노드에서만 분할이 존재       분할된 테이블 간의 의존성은 무시되고 비용 증가, 성능 저하 등의 문제 발생 가능           중복 할당 박식            동일한 테이블을 다른 서버에 복제하는 방식       일부만 복제하는 부분복제, 전체를 복제하는 완전 복제가 있음               9. 데이터베이스 이중화 / 서버 클러스터링 – B   - 데이터베이스 이중화      시스템 오류로 인한 DB 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 DB를 복제하여 관리   문제가 발생하면 복제된 DB를 이용하여 즉시 문제를 해결할 수 있음   사용자가 수행하는 작업이 다른 DB에도 동일하게 적용   DB 부하를 줄일 수 있음   손쉽게 백업 서버를 운영할 수 있음   - 데이터베이스 이중화의 분류      Eager 기법 : 데이터 변경이 발생하면 변경 내용이 즉시 적용   Lazy 기법 : 트랜잭션 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 DB에 전달   - 데이터베이스 이중화 구성 방법      활동-대기 방법            한 DB가 활성 상태이면 다른 DB는 대기       활성 DB에 장애가 발생하면 대기 DB가 자동으로 모든 서비스를 대신 수행       구성 방법과 관리가 쉬움           활동-활동 방법            두개의 DB가 서로 다른 서비스를 제공하다가 한쪽에 문제가 생기면 나머지 DB가 서비스 제공       처리율이 높지만 구성 방법 및 설정이 복잡           - 클러스터링      두 대 이상의 서버를 하나의 서버처럼 운영하는 기술   서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공   고가용성 클러스터링            하나의 서버에 장애가 발생하면 다른 서바가 받아 처리하여 서비스 중단을 방지           병렬 처리 클러스터링            전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리       사용자의 요청을 로드 밸런서가 여러 대의 서버로 분산               10. 데이터베이스 보안 / 암호화 – B   - 데이터베이스 보안의 개요      권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술   DB 사용자들은 일반적으로 서로 다른 객체에 대하여 다른 접근 권리 또는 권한을 가짐   - 암호화      데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 함   암호화 과정 : 평문 -&gt; 암호문   복호화 과정 : 암호문 -&gt; 평문   개인키 암호 방식(비밀키 암호 방식)            동일한 키로 데이터를 암호화하고 복호화 함       대칭 암호 방식, 단일키 암호화 기법이라고도 함       비밀키는 DB 사용 권한이 있는 사용자만 나누어 가짐           공개키 암호 방식            서로 다른 키로 데이터를 암호화하고 복호화 함       공개키는 DB 사용자에게 공개. 복호화 키는 관리자가 비밀리에 관리       비대칭 암호 방식. 대표적으로 RSA               11. 데이터베이스 보안 : 접근통제 – A   - 접근통제      데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한   자원의 불법적인 접근 및 파괴를 예방   비인가된 사용자의 접근 감시   접근 요구자의 사용자 식별   접근 요구의 정당성 확인 및 기록   접근의 승인 및 거부   임의 접근 통제            데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여       주체가 접근통제 권한을 지정하고 제어       부여된 권한을 다른 사용자에게 허가할 수 있음       GRANT, REVOKE           강제 접근 통제            주체와 객체의 등급을 비교하여 접근 권한을 부여       제3자가 접근통제 권한을 지정       객체별로 보안 등급 부여, 사용자별로 인가 등급 부여       자신보다 보안 등급이 높은 객체에 대해 읽기, 수정, 등록이 모두 불가능       자신과 보안 등급이 같은 객체에 대해 읽기, 수정, 등록 가능       자신보다 보안 등급이 낮은 객체에 대해 읽기 가능           - 접근통제 정책      신분 기반 정책            주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법       IBP : 최소 권한 정책. 단일 주체에게 하나의 객체에 대한 허가 부여       GBP : 복수 주체에 하나의 객체에 대한 허가 부여           규칙 기반 정책            주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법       MLP : 사용자 및 객체별로 지정된 기밀 분류에 따른 정책       CBP : 집단별로 지정된 기밀 허가에 따른 정책           역할 기반 정책            주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한       인사 담당자, DBA 등           - 접근통제 매커니즘      접근통제 정책을 구현하는 기술적인 방법   접근통제 목록, 능력 리스트, 보안 등급, 패스워드, 암호화   - 접근통제 보안 모델      보안 정책을 구현하기 위한 정형화된 모델   기밀성 모델            군사적인 목적으로 개발된 수학적 모델. 기밀성 보장이 최우선       군대 시스템 등 특수 환경에서 주로 사용           무결성 모델            불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델       데이터의 일관성 유지에 중점       주체 및 객체의 보안 등급을 기반으로 함           접근통제 모델            접근통제 행렬 : 행은 주체, 열은 객체           - 접근통제 조건      접근통제 매커니즘의 취약점을 보완하기 위해 접근통제 정책에 부가하여 적용할 수 있는 조건   값 종속 통제 : 객체에 저장된 값에 따라 다르게 접근 통제를 허용해야 하는 경우   다중 사용자 통제 : 다수의 사용자가 동시에 접근을 요구하는 경우   컨텍스트 기반 통제 : 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때   - 감사 추적      DB에 접근하여 수행한 모든 활동을 기록하는 기능   오류가 발생한 DB를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용       12. 스토리지 – B   - 스토리지 개요      단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술   - DAS(Direct Attached Storage)      서버와 저장장치를 전용 케이블로 직접 연결. 외장하드를 연결하는 것이 해당   서버에서 저장장치를 관리   직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬움   초기 구축 비용 및 유지보수 비용 저렴   다른 서버에서 접근할 수 없고 파일 공유 불가능   확장성 및 유연성이 상대적으로 떨어짐   저장 데이터가 적고 공유가 필요 없는 환경에 적합   - NAS(Network Attached Storage)      서버와 저장장치를 네트워크를 통해 연결   NAS Storage가 내장된 저장장치를 직접 관리   Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있음   파일 공유 가능, 장소에 구애받지 않고 저장장치에 쉽게 접근 가능   확장성 및 유연성이 우수   접속 증가 시 성능 저하   - SAN(Storage Area Network)      서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성   파이어 채널 스위치를 이용하여 네트워크 구성   광케이블로 연결하므로 처리 속도가 빠름   저장장치 및 파일 공유 가능   확장성, 유연성, 가용성이 뛰어남   높은 트랜잭션 처리에 효과적   장비의 업그레이드가 필요하고, 비용이 많이 듦       13. 논리 데이터 모델의 물리 데이터 모델 변환 – A   - 테이블      Row : 튜플, 인스턴스   Column : 속성   기본키 : 후보키 중에서 선택한 주키. 특정 튜플을 유일하게 구별할 수 있는 속성   외래키 : 다른 릴레이션의 기본키를 참조하는 속성   - Entity를 테이블로 변환      고려사항            테이블과 Entity 명칭은 동일하게 하는 것을 권고       Entity는 한글명 사용, 테이블은 영문명 사용       메타 데이터 관리 시스템에 표준화된 용어가 있을 때는 메타에 등록된 단어를 사용           - 슈퍼타입/서브타입을 테이블로 변환      물리 데이터 모델을 설계할 때는 슈퍼타입/서브타입을 테이블로 변환해야 함   슈퍼타입 기준 테이블 변환            서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것       서브타입에 속성이나 관계가 적을 경우에 적용. 서브타입의 모든 속성이 포함       장점                    데이터 액세스가 상대적으로 용이           뷰를 이용해 각각의 서브타입만을 액세스하거나 수정할 수 있음           임의 집합에 대한 처리가 용이           수행 속도가 빨라짐           SQL 문장 구성이 단순해짐                       단점                    컬럼이 증가해 디스크 저장 공간이 증가           서브타입에 대한 구분이 필요한 경우가 많이 발생           인덱스 크기의 증가로 인덱스 효율이 떨어짐                           서브타입 기준 테이블 변환            슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입을 개별적인 테이블로 만드는 것       서브타입에 속성이나 관계가 많이 포함된 경우 적용       장점                    서브타입 속성들의 선택 사양이 명확한 경우 유리           처리할 때마다 서브타입 유형을 구분할 필요가 없음           테이블당 크기가 감소하여 전체 테이블 스캔시 유리                       단점                    수행 속도 감소           복잡한 처리를 하는 SQL의 통합이 어려움           부분 범위에 대한 처리가 곤란           여러 테이블을 통합한 뷰는 조회만 가능           식별자의 유지 관리가 어려움                           개별타입 기준 테이블 변환            슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환       1:1 관계가 형성       전체 데이터에 대한 처리가 빈번한 경우       서브타입의 처리가 대부분 독립적으로 발생하는 경우       통합하는 테이블의 컬럼 수가 많은 경우       서브타입의 컬럼 수가 많은 경우       트랜잭션이 주로 슈퍼타입에서 발생하는 경우       슈퍼타입의 처리 범위가 넓고 빈번하게 발생하여 단일 테이블 클러스터링이 필요한 경우       장점                    저장 공간이 상대적으로 작음           슈퍼타입 또는 서브타입 각각의 테이블에 속한 정보만 조회하는 경우 문장 작성 용이                       단점                    슈퍼타입 또는 서브타입의 정보를 같이 처리하면 항상 조인이 발생하여 성능이 저하됨                           - 속성을 컬럼으로 변환      논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환   일반 속성 변환            표준화 된 약어를 사용하여 일치시키는 것이 좋음       SQL 예약어 사용을 피함       가능한 한 짧게 지정       복합 단어를 컬럼명으로 사용할 때는 미리 정의된 표준을 따름       샘플 데이터를 작성하여 컬럼의 정합성 검증           Primary UID를 기본키로 변환            논리 데이터 모델에서의 Primary UIU는 물리 데이터 모델의 기본키로 만듬           Primary UID(관계의 UID Bar)를 기본키로 변환            다른 Entity와의 관계로 인해 생성된 Primary UIU는 물리 데이터 모델의 기본키로 만듬           Secondary(Alternate) UID를 유니크기로 변환            논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크 키로 만듬           - 관계를 외래키로 변환      기본키와 이를 참조하는 외래키로 변환   1:1 관계            A의 기본키를 B의 외래키로 추가하거나 B의 기본키를 A의 외래키로 추가하여 표현           1:N 관계            A의 기본키를 B의 외래키로 추가하여 표현하거나 별도의 테이블로 표현           N:M 관계            A와 B의 기본키를 모두 포함한 별도의 릴레이션으로 표현           1:N 순환 관계            A에 A의 기본키를 참조하는 외래키 컬럼을 추가하여 표현       데이터의 계층 구조를 표현하기 위해 주로 사용           - 관리 목적의 테이블/컬럼 추가      논리 데이터 모델에 존재하지 않는 테이블이나 컬럼을 물리 데이터 모델에 추가하여 DB의 관리 혹은 프로그래밍의 수행 속도를 향상시킬 수 있음   - 데이터 타입 선택      DBMS의 물리적 특성과 성능을 고려하여 최적의 데이터 타입과 데이터의 최대 길이 선택   문자타입, 숫자타입, 날짜타입 등  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp11/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 배경, 배치",
        "excerpt":"배경   - background-color   /* 요소의 배경 색상 */ background-color {   기본값: transparent; 투명함   색상: 지정 가능한 색상; }       - background-image   /* 요소의 배경 이미지 삽입 */ background-image {   기본값: none; 이미지 없음   background-image: url(\"경로\"); 이미지 경로 }       - background-repeat   /* 요소의 배경 이미지 반복 */ background-repeat {   기본값: repeat; 이미지를 수직, 수평 반복   background-repeat: repeat-x; 이미지를 수평 반복   background-repeat: repeat-y; 이미지를 수직 반복   background-repeat: no-repeat; 반복 없음 }       - background-position   /* 요소의 배경 이미지 위치 */ background-position {   기본값: 0% 0%; 0% ~ 100% 사이 값   방향: top, bottom, left, right, center;   단위: px, em, rem;  }       - background-size   /* 요소의 배경 이미지 크기 */ background-size {   기본값: auto; 이미지의 실제 크기   단위: px, em, rem;   cover: 비율을 유지, 요소의 더 넓은 너비에 맞춤;   contain: 비율을 유지, 요소의 더 짧은 너비에 맞춤; }       - background-attachment   /* 요소의 배경 이미지 스크롤 특성 */ background-attachment {   기본값: scroll; 이미지가 요소를 따라서 같이 스크롤   background-attachment: fixed; 이미지가 뷰포트에 고정, 스크롤X   background-attachment: local; 요소 내 스크롤 시 이미지가 같이 스크롤 }       배치   - position   /* 요소의 위치 지정 기준 */ position {   기본값: static; 기준 없음   position: relative; 요소 자신을 기준   position: absolute; 위치 상 부모 요소를 기준, 부모 꼭 확인해야 함   position: fixed; 뷰포트를 기준   position: sticky; 스크롤 영역 기준   position과 같이 사용하는 CSS속성들은 모두 음수 사용 가능 }       - 요소 쌓임 순서      어떤 요소가 사용자와 더 가깝게 있는지 결정            요소에 position 속성의 값이 있는 경우 위에 쌓임(static제외)       1번 조건이 같은 경우, z-index 속성의 숫자 값이 높을 수록 위에 쌓임       1, 2번 조건이 같은 경우, HTML의 다음 구조일 수록 위에 쌓임           - z-index   /* 요소 쌓임 정도를 지정 */ z-index {   기본값: auto; 부모 요소와 동일한 쌓임 정도   숫자: 숫자가 높을 수록 위에 쌓임; }   - 요소의 display가 변경      position 속성의 값으로 absolute, fixed가 지정된 요소는 display 속성이 block로 변경   태그 {   display: block;   position: absolute;   top: 30px;   left: 30px;   z-index: 1; }  /* 위와 아래는 동일 */  태그 {   position: absolute;   top: 30px;   left: 30px;   z-index: 1;   }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-bgpo/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-3. SQL 응용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. SQL의 개념 – B   - SQL의 개요      국제 표준 DB 언어. 많은 회사에서 RDB를 지원하는 언어로 채택   관계대수와 관계해석을 기초로 한 혼합 데이터 언어   질의어지만 질의 기능 뿐만 아니라 데이터 구조 정의, 데이터 조작, 제어 기능을 모두 갖춤   - SQL의 분류      DDL(Data Define Language, 데이터 정의어)            SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용       논리적 데이터 구조와 물리적 데이터 구조의 사상을 정의       DB 관리자나 DB 설계자가 사용       CREATE : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의       ALTER : TABLE에 대한 정의를 변경하는 데 사용       DROP : SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제           DML(Data Manipulation Language, 데이터 조작어)            저장된 데이터를 실질적으로 처리하는 데 사용       DB 사용자와 DB 관리 시스템 간의 인터페이스 제공       SELECT : 튜플 검색       INSERT : 튜플 삽입       DELETE : 튜플 삭제       UPDATE : 튜플 내용 변경           DCL(Data Control Language, 데이터 제어어)            데이터의 보안, 무결성, 회복, 병행 수행 제어 등을 정의하는데 사용       DB 관리자가 데이터 관리를 목적으로 사용       COMMIT : 결과를 물리적 디스크로 저장. 작업이 완료되었음을 관리자에게 알려줌       ROLLBACK : 비정상적으로 종료되었을 때 원래의 상태로 복구       GRANT : 사용자에게 사용 권한을 부여       REVOKE : 사용자의 사용 권한을 취소               2. DDL – C   - DDL 개념      DB를 구축하거나 수정 할 목적으로 사용하는 언어   데이터 사전에 여러개의 테이블로서 저장됨   - CREATE SCHEMA      스키마를 정의하는 명령문   스키마 이름과 소유권자나 허가권자를 정의   CREATE SCHEMA 스키마명 AUTHORIZATION 사용자_id;  // ID가 홍길동인 스키마 대학교를 정의하는 SQL문 CREATE SCHEMA 대학교 AUTHORIZATION 홍길동;       - CREATE DOMAIN      도메인을 정의하는 명령문   SQL 에서 지원하는 전체 테이터 타입의 값이 아니고 일부분일 때, 그 값의 범위를 도메인으로 정의   일반적인 데이터 타입처럼 사용   CREATE DOMAIN 도메인명 [AS] 데이터_타입   [DEFAULT 기본값]   [CONSTRAINT 제약조건명 CHECK (범위값)];  // '성별'을 '남' 또는 '여'와 같이 정해진 1개의 문자로 표현되는 도메인 SEX를 정의하는 SQL문 CREATE DOMAIN SEX CHAR(1)   DEFAULT '남'   CONSTRAINT VALID-SEX CHECK(VALUE IN('남', '여'));       - CREATE TABLE      테이블을 정의하는 명령문   CREATE TABLE 테이블명   (속성명 데이터_타입 [DEFAULT 기본값] [NOT NULL], ...   [, PRIMARY KEY(기본키_속성명, ...)]   [, UNIQUE(대체키_속성명, ...)]   [, FOREIGN(외래키_속성명, ...)]     [REFERENCES 참조테이블(기본키_속성명, ...)]     [ON DELETE 옵션]     [ON UPDATE 옵션]   [, CONSTRAINT 제약조건명] [CHECK (조건식)]);      UNIQUE : 대체키로 사용할 속성. 중복된 값 가질 수 없음   FOREIGN KEY ~ REFERENCES ~            참조할 다른 테이블과 참조할 때 사용할 외래키 속성 지정       외래키가 지정되면 참조 무결성의 CASCADE 법칙이 적용됨       ON DELETE 옵션 : 튜플이 삭제되었을 때 옵션. NO ACTION, CASCADE, SET NULL, SET DEFAULT       ON UPDATE 옵션 : 참조 속성 값이 변경되었을 때 옵션. NO ACTION, CASCADE, SET NULL, SET DEFAULT                    NO ACTION : 기본 테이블에 아무런 조취를 취하지 않음           CASCADE : 참조 테이블의 튜플이 삭제, 수정되면 기본 테이블 튜플 삭제, 수정됨           SET NULL : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플 속성 값을 NULL로 변경           SET DEFAULT : 참조 테이블에 변화가 있으면 기본 테이블의 관련 튜플 속성 값을 기본값으로 변경                           CONSTRAINT : 제약 조건의 이름을 지정.   CHECK : 속성 값에 대한 제약 조건 정의   CREATE TABLE 학생   (이름 VARCHAR(15) NOT NULL,   학번 CHAR(8),   전공 CHAR(5),   성별 SEX,   생년월일 DATE,   PRIMARY KEY(학번),   FOREIGN KEY(전공) REFERENCES 학과(학과코드)     ON DELETE SET NULL     ON UPDATE CASCADE,   CONSTRAINT 생년월일제약     CHECK(생년월일&gt;='1980-01-01'));       - CREATE VIEW      뷰를 정의하는 명령문   CREATE VIEW 뷰명[(속성명[, 속성명, ...])] AS SELECT문;      SELECT문은 서브 쿼리로 사용하여 SELECT문의 결과로서 뷰를 생성   SELECT문에는 UNION이나 ORDER BY절을 사용할 수 없음   속성명을 기술하지 않으면 SELECT문의 속성명이 자동으로 사용됨   // &lt;고객&gt; 테이블에서 '주소'가 '안산시'인 고객들의 // '성명'과 '전화번호'를 '안산고객'이라는 뷰로 정의 CREATE VIEW 안산고객(성명, 전화번호) AS SELECT 성명, 전화번호 FROM 고객 WHERE 주소 = '안산시';       - CREATE INDEX      인데스를 정의하는 명령문   CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(속성명 [ASC | DESC] [,속성명 [ASC | DESC]]) [CLUSTER];      UNIQUE : 사용된 경우 중복값 없는 속성으로 인덱스 생성. 생략된 경우 중복 값 허용   정렬            ASC : 오름차순       DESC : 내림차순       생략시 : 오름차순           CLUSTER : 사용하면 인덱스가 클러스터드 인덱스로 설정됨   // &lt;고객&gt; 테이블에서 UNIQUE한 특성을 갖는 '고객번호' 속성에 대해 // 내림차순으로 정렬하여 '고객번호_idx'라는 이름으로 인덱스를 정의 CREATE UNIQUE INDEX 고객번호_idx ON 고객(고객번호 DESC);       - ALTER TABLE      테이블에 대한 정의를 변경하는 명령문   // ADD : 새로운 속성을 추가할 때 사용 ALTER TABLE 테이블명 ADD 속성명 데이터_타입 [DEFAULT '기본값'];  // ALTER : 특정 속성의 Default 값을 변경할 때 사용 ALTER TABLE 테이블명 ALTER 속성명 [SET DEFAULT '기본값'];  // DROP COLUMN 특정 속성을 삭제할 때 사용 ALTER TABLE 테이블명 DROP COLUMN 속성명[CASCADE];   // &lt;학생&gt; 테이블에 최대 3문자로 구성되는 '학년' 속성 추가 ALTER TABLE 학생 ADD 학년 VARCHAR(3);  // &lt;학생&gt; 테이블의 '학번' 필드의 데이터 타입과 크기를 VARCHAR(10)으로 // 하고 NULL 값이 입력되지 않도록 변경 ALTER TABLE 학생 ALTER 학번 VARCHAR(10) NOT NULL;       - DROP      스키마, 도메인, 테이블, 뷰, 인덱스, 제약 조건 등을 제거하는 명령문   DROP SCHEMA 스키마명 [CASCADE | RESTRICT]; DROP DOMAIN 도메인명 [CASCADE | RESTRICT]; DROP TABLE 테이플명 [CASCADE | RESTRICT]; DROP VIEW 뷰명 [CASCADE | RESTRICT]; DROP INDEX 인덱스명 [CASCADE | RESTRICT]; DROP CONSTRAINT 제약조건명;      CASCADE : 참조하는 다른 모든 개체를 함께 제거. 참조 무결성 제약 조건을 설정하기 위해 사용   RESTRICTED : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소       3. DCL – C   - DCL 개념      데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어   DB 관리자(DBA)가 데이터 관리를 목적으로 사용   - GRANT / REVOKE      사용자에게 권한을 부여하거나 취소하기 위한 명령어   // 사용자등급 지정 및 해제 GRANT 사용자등급 TO 사용자_ID_리스트 [IDENTIFIED BY 암호]; REVOKE 사용자등급 FROM 사용자_ID_리스트   // ID가 \"NABI\"인 사람에게 DB 및 테이블을 생성할 수 있는 권한 부여 GRANT RESOURCE TO NABI;  // ID가 \"STAR\"인 사람에게 DB 정보를 검색할 수 있는 권한을 부여 GRANT CONNECT TO STAR;   // 테이블 및 속성에 대한 권한 부여 및 취소 GRANT 권한_리스트 ON 개체 TO 사용자 [WITH GRANT OPTION]; REVOKE [GRANT OPTION FOR] 권한_리스트 ON 개체 FROM 사용자 [CASCADE];      권한 종류 : ALL, SELECT, INSERT, DELETE, UPDATE, ALTER 등   WITH GRANT OPTION : 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한을 부여   GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소   CASCADE : 권한 취소 시 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 취소   // ID가 \"NABI\"인 사람에게 &lt;고객&gt; 테이블에 대한 모든 권한과 다른 사람 // 에게 권한을 부여할 수 있는 권한까지 부여 GRANT ALL ON 고객 TO NABI WITH GRANT OPTION;  // ID가 \"STAR\"인 사람에게 부여한 &lt;고객&gt; 테이블에 대한 권한 중 UPDATE // 권한을 다른 사람에게 부여할 수 있는 권한만 취소 REVOKE GRANT OPTION FOR UPDATE ON 고객 FROM STAR;       - COMMIT      트랜잭션이 성공적으로 끝나면 DB가 새로운 일관성 상태를 가지기 위해 변경된 모든 내용을 반영   COMMIT 명령을 실행하지 않아도 DML문이 성공적으로 완료되면 자동으로 COMMIT 됨   DML이 실패하면 자동으로 ROLLBACK이 되도록 Auto Commit 기능을 설정할 수 있음   - ROLLBACK      아직 COMMIT되지 않은 변경된 모든 내용들을 취소하고 DB를 이전 상태로 되돌리는 명령어   일부분만 완료된 트랜잭션은 ROLLBACK 되어야 함   - SAVEPOINT      트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정하는 명령어   ROLLBACK 시 지정된 SAVEPOINT까지 트랜잭션 처리 내용이 취소됨       4. DML – B   - DML의 개념      DB 사용자가 응용 프로그램이나 질의어를 통해 데이터를 실질적으로 관리하는데 사용되는 언어   사용자와 DBMS 간의 인터페이스를 제공   - 삽입문(INSERT INTO ~ )      기본 테이블에 새로운 튜플을 삽입할 때 사용   INSERT INTO 테이블명([속성명1, 속성명2, ...]) VALUES (데이터1, 데이터2, ...)      대응하는 속성과 데이터는 개수와 데이터 유형이 일치해야 함   기본 테이블의 모든 속성을 사용할 때는 속성명을 생략할 수 있음   SELECT문을 사용하여 다른 테이블의 검색 결과를 삽입할 수 있음   // &lt;사원&gt; 테이블에 (이름 - 홍승현, 부서 - 인터넷)을 삽입 INSERT INTO 사원(이름, 부서) VALUES ('홍승현', '인터넷');  // &lt;사원&gt; 테이블에 (장보고, 기획, 05/03/73, 홍제동, 90)을 삽입 INSERT INTO 사원 VALUES('장보고', '기획', #05/03/73#, '홍제동', 90);  // &lt;사원&gt; 테이블에 있는 편집부의 모든 튜플을 편집부원(이름, 생일, 주소, 기본급) // 테이블에 삽입 INSERT INTO 편집부원(이름, 생일, 주소, 기본급) SELECT 이름, 생일, 주소, 기본급 FROM 사원 WHERE 부서 = '편집';       - 삭제문(DELETE FROM ~ )      기본 테이블에 있는 튜플들 중에서 특정 튜플을 삭제할 때 사용   DELETE FROM 테이블명 [WHERE 조건];      모든 레코드를 삭제할 때는 WHERE절을 생략   모든 레코드를 삭제하더라도 테이블 구조는 남아있기 때문에 DROP과는 다름   // &lt;사원&gt; 테이블에서 \"임꺽정\"에 대한 튜플을 삭제 DELETE FROM 사원 WHERE 이름 = '임꺽정';  // &lt;사원&gt; 테이블에서 \"인터넷\" 부서에 대한 모든 튜플을 삭제 DELETE FROM 사원 WHERE 부서 = '인터넷';  // &lt;사원&gt; 테이블의 모든 레코드를 삭제 DELETE FROM 사원;       - 갱신문(UPDATE ~ SET ~)      기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용   UPDATE 테이블명 SET 속성명 = 데이터[, 속성명=데이터, ...] [WHERE 조건];   // &lt;사원&gt; 테이블에서 \"홍길동\"의 '주소'를 \"수색동\"으로 수정 UPDATE 사원 SET 주소 = '수색동' WHERE 이름 = '홍길동'  // &lt;사원&gt; 테이블에서 \"황진이\"의 '부서'를 \"기획부\"로 변경하고 // '기본급'을 5만원 인상 UPDATE 사원 SET 부서 = '기획', 기본급 = 기본급 + 5 WHERE 이름 = '황진이';       - DML의 4가지 유형      SELECT~ FROM~ WHERE~   INSERT INTO~ VALUES~   DELETE~ FROM~ WHERE~   UPDATE~ SET~ WHERE~       5. DML - SELECT-1 – A   - 일반 형식   SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] FROM 테이블명[, 테이블명, ...] [WHERE 조건] [ORDER BY 속성명 [ASC | DESC]];      SELECT절            PREDICATE : 불러올 튜플 수를 제한할 명령어를 기술                    ALL : 모든 튜플을 검색할 때 지정. 주로 생략           DISTINCT : 중복된 튜플이 있으면 그 중 첫 번째 한 개만 검색           DISTINCTROW : 중복된 튜플을 제거하고 한 개만 검색. 튜플 전체를 대상으로 함                       속성명 : 검색하여 불러올 속성(열) 또는 속성을 이용한 수식을 지정                    모든 속성을 지정할 때는 ‘*‘를 기술           두 개 이상의 테이블을 대상으로 검색할 때는 ‘테이블명.속성명’으로 표현                       AS : 속성 및 연산의 이름을 다른 제목으로 표시하기 위해 사용           FROM절 : 검색될 데이터들을 포함하는 테이블명 기술   WHERE절 : 검색할 조건을 기술   ORDER BY절 : 특정 속성을 기준으로 정렬하여 검색할 때 사용            ASC : 오름차순       DESC : 내림차순       생략 : 오름차순           - 조건 연산자 / 연산자 우선순위      조건 연산자            비교 연산자 : =, &lt;&gt;, &gt;, &lt;, &gt;=, &lt;=       논리 연산자 : NOT, AND, OR       LIKE 연산자 : %(모든 문자 대표), -(문자 하나 대표), #(숫자 하나 대표)           연산자 우선순위            산술 연산자 : x, /, +, -  -&gt; 왼쪽에서 오른쪽으로 갈수록 낮아짐       관계 연산자 : =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=  -&gt; 모두 같음       논리 연산자 : NOT, AND, OR  -&gt; 왼쪽에서 오른쪽으로 갈수록 낮아짐           산술 &gt; 관계 &gt; 논리       6. DML - SELECT-2 – A   - 일반 형식   SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ...] [, 그룹함수(속성명) [AS 별칭]] [, WINDOW함수 OVER (PARTITION BY 속성명1, 속성명2, ...   ORDER BY 속성명3, 속성명4, ...) [AS 별칭]] FROM 테이블명[, 테이블명, ...] [WHERE 조건] [GROUP BY 속성명, 속성명, ...] [HAVING 조건] [ORDER BY 속성명 [ASC | DESC]];      그룹함수 : GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술   WINDOW 함수 : GROUP BY절을 이용하지 않고 속성의 값을 집계할 함수를 기술            PARTITION BY : WINDOW 함수가 적용될 범위로 사용할 속성을 지정       ORDER BY : PARTITION 안에서 정렬 기준으로 사용할 속성을 지정           GROUP BY절 : 특정 속성을 기준으로 그룹화하여 검색할 때 사용. 그룹 함수와 함께 사용   HAVING절 : GROUP BY와 함꼐 사용되며, 그룹에 대한 조건을 지정   - 집합 연산자를 이용한 통합 질의      집합 연산자를 사용하여 2개 이상의 테이블의 데이터를 하나로 통합   SELECT 속성명1, 속성명2, ... FROM 테이블명 UNION | UNION ALL | INTERSECT | EXCEPT SELECT 속성명1, 속성명2, ... FROM 테이블명 [ORDER BY 속성명 [ASC | DESC]];       7. DML - JOIN – B   - JOIN의 개념      2개의 테이블에 대해 연관된 튜플들을 결합하여 하나의 새로운 릴레이션을 반환   일반적으로 FROM절에 기술하지만, 어느 곳에서나 사용할 수 있음   - INNER JOIN      조건이 없는 INNER JOIN을 수행하면 CROSS JOIN과 동일한 결과를 얻음   EQUI JOIN            JOIN 대상 테이블에서 공통 속성을 기준으로 ‘=’ 비교에 의해 같은 값을 가지는 행을 연결       JOIN 조건이 ‘=’일 때 동일한 속성이 두 번 나타남, 중복된 속성을 제거한 것을 NATURAL JOIN       EQUI JOIN에서 연결 고리가 되는 공통 속성을 JOIN 속성이라고 함           // WHERE절을 이용한 EQUI JOIN의 표기 형식 SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2, ... WHERE 테이블명1.속성명 = 테이블명2.속성명;  // NATURAL JOIN절을 이용한 EQUI JOIN의 표기 형식 SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 NATURAL JOIN 테이블명2;  // JOIN ~ USING절을 이용한 EQUI JOIN 표기 형식 SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 JOIN 테이블명2 USING(속성명);      NON-EQUI JOIN            JOIN 조건에 ‘=’ 조건이 아닌 나머지 비교 연산자를 사용하는 JOIN 방법           SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2, ... WHERE (NON-EQUI JOIN 조건);       - OUTER JOIN      JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 방법   // LEFT OUTER JOIN SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 LEFT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명;  SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2 WHERE 테이블명1.속성명 = 테이블명2.속성명(+);   // RIGHT OUTER JOIN SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 RIGHT OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명;  SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1, 테이블명2 WHERE 테이블명1.속성명(+) = 테이블명2.속성명;   // FULL OUTER JOIN SELECT [테이블명1.]속성명, [테이블명2.]속성명, ... FROM 테이블명1 FULL OUTER JOIN 테이블명2 ON 테이블명1.속성명 = 테이블명2.속성명;       - SELF JOIN      같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN   SELECT [별칭1.]속성명, [별칭1.]속성명, ... FROM 테이블명1 [AS] 별칭1 JOIN 테이블명1 [AS] 별칭2 ON 별칭1.속성명 = 별칭2.속성명;  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp12/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-4. SQL 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 프로시저 – A   - 프로시저의 개요      절차형 SQL을 활용하여 특정 기능을 수행하는 트랜잭션 언어   미리 저장해 놓은 SQL 작업을 수행   여러 프로그램에서 호출하여 사용   스토어드 프로시저라고도 불림   시스템의 일일 마감 작업, 일괄 작업 등에 주로 사용   DECLARE (필수) BEGIN (필수)   CONTROL   SQL   EXCEPTION   TRANSACTION END (필수)      DECLARE : 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의   BEGIN / END : 프로시저의 시작과 종료   CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리   SQL : DML, DCL이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업 수행   EXCEPTION : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법을 정의   TRANSACTION : DB에 적용할지 취소할지를 결정하는 처리부   - 프로시저 생성   CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터) [지역변수 선언] BEGIN   프로시저 BODY; END;      OR REPLACE : 선택적인 예약어. 동일한 프로시저 이름이 이미 존재하는 경우, 대체 가능   프로시저명 : 생성하려는 프로시저의 이름 지정   파라미터            IN : 호출 프로그램이 프로시저에게 값을 전달할 때       OUT : 프로시저가 호출 프로그램에게 값을 반환할 때       INOUT : 전달, 반환       매개변수명 : 전달받은 값을 저장할 변수의 이름 지정       자료형 : 변수의 자료형 지정           프로시저 BODY            프로시저의 코드를 기록       BEGIN과 END 사이에는 적어도 하나의 SQL문이 있어야 함           // '사원번호'를 입력받아 해당 사원의 '지급방식'을 \"S\"로 변경하는 프로시저 생성 CREATE OR REPLACE PROCEDURE emp_change_s(i_사원번호 IN INT) IS BEGIN   UPDATE 급여 SET 지급방식 = 'S' WHERE 사원번호 = i_사원번호;   EXCEPTION     WHEN PROGRAM_ERROR THEN       ROLLBACK;   COMMIT; END;       - 프로시저 실행   EXECUTE 프로시저명; EXEC 프로시저명; CALL 프로시저명;       - 프로시저 제거   DROP PROCEDURE 프로시저명;       2. 트리거 – B   - 트리거의 개요      삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL   DB에 저장되며, 데이터 변경 및 무경성 유지, 로그 메시지 출력 등의 목적으로 사용   DCL을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 에러 발생   - 트리거의 구성   DECLARE (필수) EVENT (필수) BEGIN (필수)   CONTROL   SQL   EXCEPTION END (필수)       - 트리거의 생성   CREATE [OR REPLACE] TRIGGER 트리거명 동작시기 동작 ON 테이블명 [REFERENCING NEW | OLD AS 테이블명] [FOR EACH ROW [WHEN 조건식]] BEGIN   트리거 BODY; END;      OR REPLACE : 동일한 트리거 이름이 이미 존재하는 경우, 기존의 트리거를 대체   동작시기 : 트리거가 실행될 때를 지정            AFTER : 테이블이 변경된 후에 트리거 실행       BEFORE : 테이블이 변경되기 전에 트리거 실행           동작 : 트리거가 실행되게 할 작업의 종류를 지정            INSERT : 테이블에 새로운 튜플을 삽입할 때 트리거 실행       DELETE : 테이블의 튜플을 삭제할 때 트리거 실행       UPDATE : 테이블의 튜플을 수정할 때 트리거 실행                                           NEW           OLD : 트리거가 적용될 테이브르이 별칭을 지정                                 NEW : 추가되거나 수정에 참여할 튜플들의 집합       OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합           FOR EACH ROW : 튜플마다 트리거를 적용한다는 의미   WHEN 조건식 : 선택적인 예약어. 트리거를 적용할 튜플의 조건을 지정   트리거 BODY            트리거의 본문 코드를 입력하는 부분       BEGIN ~ END 사이에 적어도 하나 이상의 SQL문이 있어야 함           // &lt;학생&gt; 테이블에 새로운 튜플이 삽입될 때, 삽입되는 튜플에 학년 정보가 누락 // 됐으면 '학년'필드에 \"신입생\"을 치환하는 트리거를 '학년정보_tri' 이름으로 정의 CREATE TRIGGER 학년정보_tri BEFORE INSERT ON 학생 REFERENCING NEW AS new_table FOR EACH ROW WHEN (new_table.학년 IS NULL)   BEGIN     :new_table.학년 := '신입생';   END;   - 트리거의 제거   DROP TRIGGER 트리거명;       3. 사용자 정의 함수 – B   - 사용자 정의 함수의 개요      프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리   종료 시 처리 결과를 단일값으로 반환하는 절차형 SQL   DML문의 호출에 의해 실행됨   예약어 RETURN을 통해 값을 반환하기 때문에 출력 파라미터가 없음   INSERT, DELETE, UPDATE를 통한 테이블 조작은 할 수 없고 SELECT를 통한 조회만 가능   프로시저를 호출하여 사용할 수 없음   DML문에서 반환값을 활용하기 위한 용도로 사용   - 프로시저 vs 사용자 정의 함수                  구분       프로시저       사용자 정의 함수                       반환값       없거나 1개 이상 가능       1개                 파라미터       입출력 가능       입력만 가능                 사용 가능 명령문       DML, DCL       SELECT                 호출       프로시저, 사용자 정의 함수       사용자 정의 함수                 사용 방법       실행문       DML에 포함           - 사용자 정의 함수의 구성   DECLARE (필수) BEGIN (필수)   CONTROL   SQL   EXCEPTION   RETURN (필수) END (필수)      DECLARE : 선언부   BEGIN / END : 시작과 종료   CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리   SQL : SELECT문이 삽입되어 데이터 조회 작업 수행   EXCEPTION : 예외 처리   RETURN : 호출 프로그램에 반환할 값이나 변수를 정의   - 사용자 정의 함수 생성   CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터) [지역변수 선언] BEGIN   사용자 정의 함수 BODY;   RETURN 반환값; END      OR REPLACE : 동일한 사용자 정의 함수의 이름이 존재하는 경우, 기존의 함수 대체   파라미터            IN : 호출 프로그램이 사용자 정의 함수에게 값을 전달할 때 지정       매개변수명 : 전달받은 값을 저장할 변수의 이름 지정       자료형 : 변수의 자료형 지정           사용자 정의 함수 BODY            코드를 기록하는 부분       BEGIN ~ END 사이에는 적어도 하나의 SQL문이 있어야 함           RETURN 반환값 : 반환할 값이나 변수를 호출 프로그램으로 돌려줌   // 'i_성별코드'를 입력받아 1이면 \"남자\"를, 2면 \"여자\"를 반환하는 사용자 정의 // 함수를 'Get_S_성별'이라는 이름으로 정의 CREATE FUNCTION Get_S_성별(i_성별코드 IN INT) RETURN VARCHAR2 IS BEGIN   IF i_성별코드 = 1 THEN     RETURN '남자';   ELSE     RETURN '여자';   END IF END;       - 사용자 정의 함수 실행   SELECT 사용자 정의 함수명 FROM 테이블명; INSERT INTO 테이블명(속성명) VALUES (사용자 정의 함수명); DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명; UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명;       - 사용자 정의 함수 제거   DROP FUNCTION 사용자 정의 함수명;       4. DBMS 접속 기술 – B   - DBMS 접속의 개요      사용자가 데이터를 사용하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것   응용시스템은 사용자로부터 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자에게 전달하는 매개체 역할 수행   웹 응용 프로그램은 웹 응용 시스템을 통해 DBMS에 접근   웹 응용 시스템은 웹 서버와 웹 애플리케이션 서버(WAS)로 구성   규모가 작은 경우 웹 서버와 WAS를 통합하여 하나의 서버만으로 운용 가능   - 웹 응용 시스템의 구조      사용자 &lt;-&gt; 웹 서버 &lt;-&gt; WAS &lt;-&gt; DBMS   - DBMS 접속 기술      DBMS에 접근하기 위해 사용하는 API 또는 API의 사용을 편리하게 도와주는 프레임워크   JDBC(Java DataBase Connectivity)            Java 언어로 다양한 DB에 접속하고 SQL문을 수행할 때 사용되는 표준 API       Java SE에 포함. JDBC 클래스는 java.sql, javax.sql에 포함       접속하려는 DBMS에 대한 드라이버 필요           ODBC(Open DataBase Connectivity)            DB에 접근하기 위한 표준 개방형 API. 개발 언어에 관계없이 사용 가능       MS에서 출시       ODBC 문장을 사용하여 SQL을 작성하면 해당 DBMS의 인터페이스에 맞게 연결해 줌           MyBatis            JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈 소스 접속 프레임워크       간소화, 접속 기능 강화       SQL 문장을 분리하여 XML파일 만들고, Mapping을 통해 SQL 실행       SQL을 거의 그대로 사용할 수 있음           - 동적 SQL(Dynamic SQL)      개발 언어에 삽입되는 SQL코드를 문자열 변수에 넣어 처리   SQL문의 일부 또는 전부를 입력받아 실행할 수 있음   값이 입력되지 않을 경우 사용하는 NVL 함수를 사용할 필요가 없음   프리컴파일 할 때 구문 분석, 접근 권한 확인 등을 할 수 없음   정적 SQL에 비해 속도가 느리지만, 유연한 개발이 가능함   - 정적 SQL vs 동적 SQL                  구분       정적 SQL       동적 SQL                       SQL 구성       커서를 통한 정적 처리       문자열 변수에 담아 동적 처리                 개발 패턴       반복문 활용하여 SQL작성       NVL 없이 로직을 통해 SQL 작성                 실행 속도       빠름       느림                 사전 검사       가능       불가능               5. SQL 테스트 – B   - SQL 테스트의 개요      SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증   단문 SQL은 코드를 직접 실행한 후 결과를 확인   절차형 SQL은 테스트 전에 생성을 통해 Syntax Error나 참조 오류의 존재 확인   정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고, 결과를 통해 최종 확인   - 단문 SQL 테스트      직접 실행하여 결과물 확인   오류 발생 시 메시지를 참조하여 문제를 해결   DESCRIBE 명령어로 DDL로 작성된 테이블이나 뷰의 속성, 자료형, 옵션들을 확인 가능   DML로 변경한 데이터는 SELECT문으로 데이터의 정상적인 변경 여부를 확인   DCL로 설정된 사용자 권한은 해당 테이블을 SELECT로 조회하거나, SHOW 명령어로 확인            Oracle : SELECT * FROM ~~~       MySQL : SHOW GRANTS FOR ~~~           // MySQL에서 &lt;학생&gt; 테이블의 정보를 확인하는 SQL문 작성 DESC 학생;  // Oracle에서 'SINAGONG' 사용자의 시스템 권한을 확인하는 SQL문 작성 SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE = 'SINAGONG';  // MySQL에서 localhost 서버의 'SINAGONG' 사용자에 대한 권한을 확인하는 SQL문 작성 SHOW GRANTS FOR 'SINAGONG'@'localhost';       - 절차형 SQL 테스트      디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인   SHOW 명령어를 통해 오류 내용을 확인하고 문제를 수정   DB에 변화를 줄 수 있는 SQL문은 주석으로 처리하고, 출력문을 이용해 확인            Oracle 출력 형식                    DBMS_OUTPUT.ENABLE; : DBMS_OUTPUT 패키지를 불러옴           DBMS_OUTPUT.PUT_LINE(데이터); : ‘데이터’에 넣은 변수나 값을 출력                       MySQL 출력 형식                    SELECT 데이터; : ‘데이터’에 넣은 변수나 값을 출력                           디버깅이 완료되면 출력문을 삭제하고 주석을 제거   // Oracle에서 변수 RESULT를 출력하는 SQL문 작성 DBMS_OUTPUT.ENABLE; DBMS_OUTPUT.PUT_LINE(RESULT);  // MySQL에서 변수 RESULT를 출력하는 SQL문 작성 SELECT RESULT;       6. ORM(Object-Relational Mapping) – B   - ORM의 개요      객체지향 프로그래밍의 객체와 RDB의 데이터를 Mapping하는 기술   가상의 객체지향 DB를 만들어 프로그래밍 코드와 데이터를 연결   재사용 및 유지보수 용이   직관적이고 간단하게 데이터 조작 가능   - ORM 프레임워크      JAVA : JPA, Hibernate, EclipseLink, DataNucleus, Ebean 등   C++ : ODB, QxOrm 등   Python : Django, SQLAlchemy, Strom 등   iOS : DatabaseObjects, Core Data 등   .NET : NHibernate, DatabaseObjects, Dapper 등   PHP : Doctrine, Propel, RedBean 등   - ORM의 한계      의도대로 SQL이 작성되었는지 확인할 필요가 있음   프로젝트가 크고 복잡해질수록 ORM 기술을 적용하기 어려움   ORM에 적합하게 변환하려면 많은 시간과 노력 필요  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp13/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 3-5. 데이터 전환",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 데이터 전환 – B   - 데이터 전환의 정의      운영 중인 기존 정보 시스템에 축적되어 있는 데이터를 추출하여 새로 개발할 정보 시스템에서 운영 가능하도록 변환한 후, 적재하는 일련의 과정   데이터 전환을 ETL(Extraction, Transformation, Load), 추출, 변환, 적재 과정이라 함   데이터 이행 또는 데이터 이관이라고도 함   - 데이터 전환 계획서      데이터 전환 작업에 필요한 모든 계획을 기록하는 문서  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp14/",
        "teaser": null
      },{
        "title": "[CSS] CSS 속성 - 정렬, 전환, 변환",
        "excerpt":"정렬   - display   /* Flex Container의 화면 출력 특성 */ display {   display: flex; 블록 요소와 같이 Flex Container 정의   display: inline-flex; 인라인 요소와 같이 Flex Container 정의 }       - flex-direction   /* 주 축을 설정 */ flex-direction {   기본값: row; 행 축 (좌 -&gt; 우)   flex-direction: row-reverse; 행 축 (우 -&gt; 좌)   flex-direction: column; 열 축 (위 -&gt; 아래)   flex-direction: column-reverse; 열 축 (아래 -&gt; 위) }       - flex-wrap   /* Flex Items 묶음(줄 바꿈) 여부 */ flex-wrap {   기본값: nowrap; 묶음(줄 바꿈) 없음   flex-wrap: wrap; 여러 줄로 묶음   flex-wrap: wrap-reverse; wrap의 반대 방향으로 묶음 }       - justify-content   /* 주 축의 정렬 방법 */ justify-content {   기본값: flex-start; Flex Items를 시작점으로 정렬   justify-content: flex-end; Flex Items를 끝점으로 정렬   justify-content: center; Flex Items를 가운데 정렬   justify-content: space-between; 각 Flex Item 사이를 균등하게 정렬   justify-content: space-around; 각 Flex Item의 외부 여백을 균등하게 정렬 }       - align-content   /* 교차 축의 여러 줄 정렬 방법 */ align-content {   기본값: stretch; Flex Items를 시작점으로 정렬   align-content: flex-start; Flex Items를 시작점으로 정렬   align-content: flex-end; Flex Items를 끝점으로 정렬   align-content: center; Flex Items를 가운데 정렬   align-content: space-between; 각 Flex Item 사이를 균등하게 정렬   align-content: space-around; 각 Flex Item의 외부 여백을 균등하게 정렬 }       - align-items   /* 교차 축의 한 줄 정렬 방법 */ align-items {   기본값: stretch; Flex Items를 교차 축으로 늘림   align-items: flex-start; Flex Items를 각 줄의 시작점으로 정렬   align-items: flex-end; Flex Items를 각 줄의 끝점으로 정렬   align-items: center; Flex Items를 각 줄의 가운데 정렬   align-items: baseline; Flex Items를 각 줄의 문자 기준선에 정렬 }       - order   /* Flex Item의 순서 */ order {   기본값: 0; 순서 없음   숫자: 숫자가 작을 수록 먼저; }       - flex-grow   /* Flex Item의 증가 너비 비율 */ flex-grow {   기본값: 0; 증가 비율 없음   숫자: 증가 비율; }       - flex-shrink   /* Flex Item의 감소 너비 비율 */ flex-shrink {   기본값: 1; Flex Container 너비에 따라 감소 비율 적용   숫자: 감소 비율; }       - flex-basis   /* Flex Item의 공간 배분 전 기본 너비 */ flex-basis {   기본값: auto; 요소의 Content 너비   단위: px, em, rem; }       전환   - transition   /* 요소의 전환(시작과 끝) 효과를 지정하는 단축 속성 */ 태그 {   transition: 속성명 지속시간 타이밍함수 대기시간;   지속시간은 단축형으로 작성할 때, 필수 포함 속성 }       - transition-property   /* 전환 효과를 사용할 속성 이름을 지정 */ transition-property {   기본값: all; 모든 속성에 적용   속성이름: 전환 효과를 사용할 속성 이름 명시; }       - transition-duration   /* 전환 효과의 지속시간을 지정 */ transition-duration {   기본값: 0s; 전환 효과 없음   시간: 지속시간(s)을 지정; }       - transition-timing-function   /* 전환 효과의 타이밍(Easing) 함수를 지정 */ transition-timing-function {   기본값: ease; 느리게-빠르게-느리게   transition-timing-function: linear; 일정하게   transition-timing-function: ease-in; 느리게-빠르게   transition-timing-function: ease-out; 빠르게-느리게   transition-timing-function: ease-in-out; 느리게-빠르게-느리게   transition-timing-function: cubic-bezier(n, n, n, n); 자신만의 값을 정의(0~1)   transition-timing-function: step(n); n번 분할된 애니메이션 }       - transition-delay   /* 전환 효과가 몇 초 뒤에 시작할지 대기시간을 지정 */ transition-delay {   기본값: 0s; 대기시간 없음   시간: 대기시간(s)을 지정; }       변환      요소의 변환 효과   transform: 변환함수1 변환함수2 변환함수3 …   태그 {  transform: 원근법 이동 크기 회전 기울임; }   - 2D 변환 함수   태그 {   transform: translate(x, y); 이동(x축, y축)   transform: translateX(x); 이동(x축)   transform: translateY(y); 이동(y축)   transform: scale(x, y); 크기(x축, y축)   transform: scaleX(x); 크기(x축)   transform: scaleY(y); 크기(x축)   transform: rotate(degree); 회전(각도)   transform: skew(x, y); 기울임(x축, y축)   transform: skewX(x); 기울임(x축)   transform: skewY(y); 기울임(y축)   transform: matrix(n, n, n, n, n, n); 2차원 변환 효과 }       - 3D 변환 함수   태그 {   transform: translateZ(z); 이동(z축)   transform: translate3d(x, y, z); 이동(x축, y축, z축)   transform: scaleZ(z); 크기(z축)   transform: scale3d(x, y, z); 크기(x축, y축, z축)   transform: perspective(n); 원근법(거리)   transform: matrix3d(n, ..... , n); 3차원 변환 효과   transform: rotateX(x); 회전(x축)   transform: rotateY(y); 회전(y축)   transform: rotateZ(z); 회전(z축)   transform: rotate3d(x, y, z, a); 회전(x축, y축, z축, 각도) }       - perspective   /* 하위 요소를 관찰하는 원근 거리를 지정 */ perspective {   단위: px; }       - backface-visibility   /* 3D 변환으로 회전된 요소의 뒷면 숨김 여부 */ backface-visibility {   기본값: visible; 뒷면 보임   backface-visibility: hidden; 뒷면 숨김 }  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-fltrtr/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 4-1. 서버 프로그램 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 개발 환경 구축 – B   - 개발 환경 구축의 개요      개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것   응용 소프트웨어가 운영될 환경과 유사한 구조로 구축   개발 프로젝트의 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정   비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축   - 하드웨어 환경      인터페이스 역할을 하는 클라이언트, 클라이언트와 통신하여 서비스를 제공하는 서버로 구성   클라이언트에는 PC, 스마트폰 등이 있음   서버는 사용 목적에 따라 웹 서버, 웹 애플리케이션 서버, DB 서버, 파일 서버 등이 있음   웹 서버(Web Server)            클라이언트로부터 직접 요청을 받아 처리하는 서버. 정적 파일들을 제공       Apache HTTP Server, Microsoft Internet Information Service, Google Web Server 등           웹 애플리케이션 서버(WAS; Web Application Server)            동적 서비스를 제공하기 위해 웹 서버로부터 요청을 받아 데이터 가공 작업을 수행       웹 서버와 DB서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할 수행       Apache Tomcat, IBM WebSphere, Oracle WebLogic 등           DB Server            DB와 이를 관리하는 DBMS를 운영하는 서버       MySQL Server, Oracle Server, Microsoft SQL Server 등           파일 서버(File Server)            DB에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버       AWS S3 등           - Web Server의 기능      HTTP/HTTPS 지원 : 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜   통신 기록 : 처리한 요청들을 로그 파일로 기록하는 기능   정적 파일 관리 : HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능   대역폭 제한 : 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능   가상 호스팅 : 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능   인증 : 사용자가 합법적인 사용자인지를 확인하는 기능   - 소프트웨어 환경      클라이언트 + 서버 운영을 위한 시스템 S/W + 개발에 사용되는 개발 S/W   시스템 S/W : 운영체제, 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등   개발 S/W : 요구사항 관리 도구, 설계/모델링 도구, 구현 도구, 빌드 도구, 테스트 도구, 형상관리 도구            요구사항 관리 도구                    요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 S/W           JIRA, IBM DOORS, inteGREAT, Reqtify, Trello 등                       설계/모델링 도구                    UML을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 S/W           DB Designer, PlantUML, ArgoUML                       구현 도구                    개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 S/W           Eclipse, IntelliJ IDEA, Visual Studio, Netbeans, Node.js 등                       빌드 도구                    구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 S/W           Ant, Graddle, Maven, Jenkins 등                       테스트 도구                    모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 S/W           CppUnit, JUnit, HttpUnit, NUnit, SpringTest 등                       형상 관리 도구                    산출물들을 버전별로 관리하여 품질 향상을 지원하는 S/W           GIT, CVS, Subversion, Mercurial                           - 개발 언어의 선정 기준      적정성, 효율성, 이식성, 친밀성, 범용성       2. 보안 및 API – B   - 소프트웨어 개발 보안의 개요      보안 취약점을 최소화하여 보안 위협으로부터 안전한 S/W를 개발하기 위한 일련의 보안 활동   S/W 개발 보안은 데이터의 기밀성, 무결성, 가용성을 유지하는 것을 목표로 함   S/W 개발 보안 가이드를 참고하여 점검해야 할 보안 항목들을 점검   - 소프트웨어 개발 보안 점검 항목      세션 통제            세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것       보안 약점에는 불충분한 세션 관리, 잘못된 세션에 의한 정보 노출 등           입력 데이터 검증 및 표현            입력 데이터에 대한 유효검 검증체계를 갖추고, 검증 실패 시 이를 처리할 수 있도록 코딩       보안 약점에는 SQL 삽입, 경로 조작 및 자원 삽입, 크로스사이트 스크립팅(XSS) 등           보안 기능            인증, 접근제어, 기밀성, 암호화 등의 기능을 의미       보안 약점에는 적절한 인증 없는 중요기능 허용, 부적절한 인가 등           시간 및 상태            다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원활히 동작되도록 코딩       보안 약점에는 검사 시점과 사용 시점(TOCTOU) 경쟁조건, 종료되지 않는 반복문 또는 재귀함수 등           에러처리            오류들을 사전에 정의하여 에러로 인해 발생할 수 있는 문제들을 예방       오류 메시지를 통한 정보 노출, 오류 상황 대응 부재 등           코드 오류            코딩 중 실수하기 쉬운 Type 변환, 자원의 반환 등을 고려하며 코딩       보안 약점에는 널 포인터 역참조, 부적절한 자원 해제 등           캡슐화            데이터와 데이터를 처리하는 함수를 하나의 객체로 묶어 코딩하는 것       보안 약점에는 잘못된 세션에 의한 데이터 정보 노출, 제거되지 않고 남은 디버그 코드 등           API 오용            API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 고려하여 코딩       보안 약점에는 DNS lookup에 의존한 보안결정, 취약한 API 사용           - API(Application Programming Interface)      운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스   프로그래밍 언어에서 특정한 작업을 수행하기 위해 사용   운영체제의 파일 제어, 화상 처리, 문자 제어 등의 기능을 활용하기 위해 사용   개발에 필요한 여러 도구를 제공. 원하는 기능을 쉽고 효율적으로 구현 가능   공개된 API를 Open API라고 함       3. 배치 프로그램 – B   - 배치 프로그램의 개요      사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리   정기 배치 : 정해진 기간에 정기적으로 수행   이벤트성 배치 : 조건이 충족될 때만 수행   On-Demand 배치 : 사용자 요청 시 수행   필수요소 : 대용량 데이터, 자동화, 견고성, 안정성/신뢰성, 성능   - 배치 스케줄러      일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구   특정 업무를 원하는 시간에 처리할 수 있도록 지원. 잡스케줄러라고도 함   스프링 배치            스프링이 가지고 있는 다양한 기능들을 모두 사용할 수 있음       DB나 파일의 데이터를 교환하는데 필요한 컴포넌트들을 제공       로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등       구성 요소와 역할                    Job : 수행할 작업 정의           Job Launcher : 실행을 위한 인터페이스           Step : Job 처리를 위한 제어 정보           Job Repository : Step의 제어 정보를 포함하여 작업 실행을 위한 모든 정보 저장                           Quartz            응용 프로그램들의 일괄 처리를 위한 다양한 기능 제공. 오픈 소스 라이브러리       요소들을 분리하여 일괄 처리 작업에 유연성 제공       구성 요소와 역할                    Scheduler : 실행 환경 관리           Job : 수행할 작업 정의           JobDetail : Job의 상세 정보           Trigger : Job의 실행 스케줄 정의                          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp15/",
        "teaser": null
      },{
        "title": "[Javascript] 자료형",
        "excerpt":"1. String   // 따옴표 사용 let myName = \"LWW\"; let email = \"plmplmdnjsdn@naver.com\"; let hello = `Hello ${myName}!`;  console.log(myName);  // LWW console.log(email);  // plmplmdnjsdn@naver.com console.log(hello);  // Hello LWW!       - String 메서드   자세한 내용은 string mdn 검색      기호를 통해서 데이터를 손쉽게 선언하는 방식을 리터럴 방식이라고 함   리터럴 방식이 아니면 new라는 키워드를 사용해야 함   // String.prototype.indexOf() -&gt; 찾으려는 문자의 첫 번째 등장 index, 없으면 -1 const result1 = 'Hello world!!'.indexOf('world') const result2 = 'Hello world!!'.indexOf('king') console.log(result1)  // 6 console.log(result2)  // -1  const str = 'Hello world!!' console.log(str.indexOf('king') !== -1)  // false   // .length -&gt; 문자열의 길이 반환 const str = '0123' console.log(str.length)  // 4 console.log('0123'length)  // 4   // .slice(x, y) -&gt; 문자열을 인덱스 x부터 y-1까지 추출 const str = 'Hello world!' console.log(str.slice(0, 3))  // Hel console.log(str.slice(6, 11))  // world   // .replace() -&gt; 문자열 치환 const str = 'Hello world!' console.log(str.replace('world', 'LWW'))  // Hell LWW!  const str = 'Hello world!' console.log(str.replace(' world!', ''))  // Hello   // .match() -&gt; 정규표현식을 통해 특정한 문자를 match. 배열데이터로 반환 const str = 'emailaddress@gmail.com' // 정규표현식 console.log(str.match(/.+(?=@)/)[0])  // emailaddress   // .trim() -&gt; 문자데이터의 앞뒤의 모든 공백문자 제거 const str = '      Hello world     ' console.log(str.trim())  // Hello world       2. Number   // 정수 및 부동소수점 숫자를 나타냄 let number = 123; let opacity = 1.57;  console.log(number);  // 123 console.log(opacity);  // 1.57       - 숫자와 수학   자세한 내용은 math mdn 검색   const pi = 3.14159265358979 console.log(pi)  // 3.14159265358979  const str = pi.toFixed(2) console.log(str)  // 3.14 console.log(typeof str)  // string  const integer = parseInt(str) const float = parseFloat(str) console.log(integer)  // 3 console.log(float)  // 3.14 console.log(typeof integer, typeof float)  // number number       // Math.abs() -&gt; 절대값 반환 console.log('abs: ', Math.abs(-12))  // abs: 12   // Math.min() -&gt; 최소값 반환 console.log('min: ', Math.min(2, 8))  // min: 2   // Math.max() -&gt; 최대값 반환 console.log('max: ', Math.max(2, 8))  // max: 8   // Math.ceil() -&gt; 올림 console.log('ceil: ', Math.ceil(3.14))  // ceil: 4   // Math.floor() -&gt; 내림 console.log('floor: ', Math.floor(3.14))  // floor: 3   // Math.round() -&gt; 반올림 console.log('round: ', Math.round(3.5))  // round: 4   // Math.random() -&gt; 난수 console.log('random: ',Math.random())  // random: 0~1사이의 난수       3. Boolean   // true, false 두 가지 값밖에 없는 논리 데이터 let checked = true; let isShow = false;  console.log(checked);  // true console.log(isShow);  // false       4. Undefined   // 값이 할당되지 않은 상태를 나타냄 let undef; let obj = {abc: 123};  console.log(undef);  // undefined console.log(obj.abc);  // 123 console.log(obj.xyz);  // undefined       5. Null   // 어떤 값이 의도적으로 비어있음을 의미 let empty = null;  console.log(empty);  // null       6. Object   // 여러 데이터를 Key:Value 형태로 저장 { } let user = {   name: 'LWW',   age: 50,   isValid: true };  console.log(user.name);  // LWW console.log(user.age);  // 50 console.log(user.isValid);  // true       - Object 메서드   자세한 내용은 object mdn 검색   // Object.assign(x, y) -&gt; x 객체 데이터에 y 객체 데이터를 합침 // static 메서드 const userAge = {   // key: value   name: 'LWW',   age: 45 } const userEmail = {   name: 'LWW',   email: 'abcdefg@gmail.com' }  // 프로토타입으로 만들어진 메서드가 아니기 때문에 객체 데이터 자체에는 사용 불가 // ex) userAge.assign와 같은 식으로 사용불가 const target = Object.assign(userAge, userEmail) console.log(target)  // {name: \"LWW\", age: 45, email: \"abcdefg@gmail.com\"} console.log(userAge)  // {name: \"LWW\", age: 45, email: \"abcdefg@gmail.com\"} console.log(target === userAge)  // true  // 서로 다른 메모리 주소를 가리키고 있음 const a = {k: 123} const b = {k: 123} console.log(a === b)  // false  // 원본 데이터 손상 안주는 방법 const target = Object.assign({}, userAge, userEmail) console.log(target)  // {name: \"LWW\", age: 45, email: \"abcdefg@gmail.com\"} console.log(userAge)  // {name: \"LWW\", age: 45} console.log(target === userAge)  // false  // 복사본 만들기 const target = Object.assign({}, userAge) console.log(target)  // {name: \"LWW\", age: 45} console.log(userAge)  // {name: \"LWW\", age: 45} console.log(target === userAge)  // false   // Object.keys() -&gt; 객체 데이터의 key를 추출하여 새로운 배열로 만듬 const user = {   name: 'LWW',   age: 45,   email: 'abcdefg@gmail.com' }  const keys = Object.keys(user) console.log(keys)  // (3) [\"name\", \"age\", \"email\"]  console.log(user['emails'])  // abcdefg@gmail.com  const values = keys.map(key =&gt; user[key]) console.log(values)  // (3) [\"LWW\", 45, \"abcdefg@gmail.com\"]       7. Array   // 여러 데이터를 순차적으로 저장 [ ] let animals = ['Cat', 'Dog', 'Tiger'];  console.log(animals[0]);  // 'Cat' console.log(animals[1]);  // 'Dog' console.log(animals[2]);  // 'Tiger'       - Array indexing   자세한 내용은 array mdn 검색   // 각각의 요소는 element(요소), item이라고 부름 const numbers = [1, 2, 3, 4] const animals = ['Cat', 'Dog', 'Tiger']  console.log(numbers[1])  // 2 console.log(fruits[2])  // 'Tiger'       - Array 메서드   // .length -&gt; 배열의 길이 반환 const numbers = [1, 2, 3, 4] const animals = ['Cat', 'Dog', 'Tiger']  console.log(numbers.length)  // 4 console.log(animals.length)  // 3 console.log([1, 2].length)  // 2 console.log([].length)  // 0   // .concat() -&gt; 두 개의 배열 데이터를 병합해서 새로운 배열 데이터 반환 // 원본 데이터는 변하지 않음 const numbers = [1, 2, 3, 4] const animals = ['Cat', 'Dog', 'Tiger']  console.log(numbers.concat(animals))  // 0: 1                                       // 1: 2                                       // 2: 3                                       // ....                                       // 5: \"Dog\"                                       // 6: \"Tiger\" console.log(numbers)  // (4) [1, 2, 3, 4] console.log(animals)  // (3) [\"Cat\", \"Dog\", \"Tiger\"]   // .forEach() -&gt; 배열의 item 개수만큼 인수로 사용된 콜백함수가 반복적으로 실행 const numbers = [1, 2, 3, 4] const animals = ['Cat', 'Dog', 'Tiger']  animals.forEach(function (animal, i) {   console.log(animal, i)  // Cat 0 (3) [\"Cat\", \"Dog\", \"Tiger\"] })                        // Dog 1 (3) [\"Cat\", \"Dog\", \"Tiger\"]                           // Tiger 2 (3) [\"Cat\", \"Dog\", \"Tiger\"]   // .map() -&gt; 콜백에서 반환된 특정한 데이터를 기준으로 해서 새로운 배열 반환 const numbers = [1, 2, 3, 4] const animals = ['Cat', 'Dog', 'Tiger']  const a = animals.forEach(function (animal, index) {   console.log(`${animal}-${i}`) // Cat-0 })                              // Dog-1                                 // Tiger-2 console.log(a)  // Undefined, 반환값 없음  const b = animals.map(function (animal, index) {   return `${animal}-${i}` }) console.log(b) // (3) [\"Cat-0\", \"Dog-1\", \"Tiger-2\"]  const c = animals.map(function (animal, index) {   return {     id: index,     name: animal   } }) console.log(c)  // (3) [{...}, {...}, {...}]  const d = animals.map((animal, index) =&gt; ({   id: index,   name: animal })) console.log(d)  // (3) [{...}, {...}, {...}]   // .filter() -&gt; 콜백 함수에서 반환된 값이 true인 경우에만 새로운 배열로 반환 const numbers = [1, 2, 3, 4]  const a = numbers.map(number =&gt; number &lt; 3) console.log(a)  // (4) [true, true, false, false]  const b = numbers.filter(number =&gt; number &lt; 3) console.log(b)  // (2) [1, 2] console.log(numbers)  // (4) [1, 2, 3, 4]   // .find() -&gt; 내가 원하는 특정한 데이터를 찾음 // 아이템을 찾으면 반복 종료 const animals = ['Cat', 'Dog', 'Tiger']  const a = animals.find(animal =&gt; /^D/.test(animal)) const b = animals.find(animal =&gt; /^T/.test(animal)) console.log(a)  // Dog console.log(b)  // Tiger   // .findIndex() -&gt; 내가 원하는 특정한 데이터의 인덱스를 찾음 const animals = ['Cat', 'Dog', 'Tiger']  const a = animals.findIndex(animal =&gt; /^D/.test(animal)) console.log(a)  // 1   // .includes() -&gt; 배열의 인수로 사용된 특정한 데이터가 포함되어 있는지 확인 const numbers = [1, 2, 3, 4] const animals = ['Cat', 'Dog', 'Tiger']  const a = numbers.includes(3) console.log(a)  // true  const b = animals.includes('LWW') console.log(b)  // false   // .push() -&gt; 배열의 가장 뒤쪽에 새로운 데이터 삽입 // .unshift() -&gt; 배열의 가장 앞쪽에 새로운 데이터 삽입 // 원본 수정됨 주의! const numbers = [1, 2, 3, 4]  numbers.push(5) console.log(numbers)  // (5) [1, 2, 3, 4, 5] numbers.unshift(0) console.log(numbers)  // (6) [0, 1, 2, 3, 4, 5]   // .reverse() -&gt; 배열의 요소 순서를 뒤집음 // 원본 수정됨 주의! const numbers = [1, 2, 3, 4] const animals = ['Cat', 'Dog', 'Tiger']  numbers.reverse() animals.reverse()  console.log(numbers)  // (4) [4, 3, 2, 1] console.log(animals)  // (3) [\"tiger\", \"Dog\", \"Cat\"]   // .splice(x, y) -&gt; 인덱스 x에서 y개의 배열 요소를 삭제 // 원본 수정됨 주의! // 어떤 자리에 새로운 요소를 끼워 넣는 용도로도 사용 const numbers = [1, 2, 3, 4]  numbers.splice(2, 2) console.log(numbers)  // (3) [1, 2]  const numbers = [1, 2, 3, 4]  numbers.splice(2, 0, 999) console.log(numbers)  // (5) [1, 2, 999, 3, 4]  const animals = ['Cat', 'Dog', 'Tiger']  animals.splice(2, 1, 'Lion') console.log(animals)  // (3) [\"Cat\", \"Lion\", \"Tiger\"]  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-datatype/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 4-2. 프로그래밍 언어 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 데이터 타입 – B      변수에 저장될 데이터의 형식   데이터 타입의 유형            Integer : 정수       Floating Poing : 소수점 이하가 있는 실수       Character : 한 문자. ‘ ‘안에 표시       String : 문자열. “ “안에 표시       Boolean : True or False. 기본값은 False       Array : 같은 타입의 데이터 집합. { }안에 ,로 구분           - C/C++의 데이터 타입 크기 및 기억 범위                  종류       데이터 타입       크기       기억 범위                       문자       char       1Byte       -128 ~ 127                 부호없는 문자       unsigned char       1Byte       0 ~ 2^8 - 1                 정수       short       2Byte       -2^15 ~ 2^15 - 1                 ”       int       4Byte       -2^31 ~ 2^31 - 1                 ”       long       4Byte       -2^31 ~ 2^31 - 1                 ”       long long       8Byte       -2^63 ~ 2^63 - 1                 부호없는 정수       unsigned short       2Byte       0 ~ 2^16 - 1                 ”       unsigned int       4Byte       0 ~ 2^32 - 1                 ”       unsigned long       4Byte       0 ~ 2^64 - 1                 실수       float       4Byte       1.2 * 10^-38 ~ 3.4 * 10^38                 ”       double       8Byte       2.2 * 10^-308 ~ 1.8 * 10^308                 ”       long double       8Byte       2.2 * 10^-308 ~ 1.8 * 10^308           - Java의 데이터 타입 크기 및 기억 범위                  종류       데이터 타입       크기       기억 범위                       문자       char       2Byte       0 ~ 2^16 - 1                 정수       byte       1Byte       -2^7 ~ 2^7 - 1                 ”       short       2Byte       -2^15 ~ 2^15 - 1                 ”       int       4Byte       -2^31 ~ 2~31 - 1                 ”       long       8Byte       -2^63 ~ 2^63 - 1                 실수       float       4Byte       1.4 * 10^-45 ~ 3.4 * 10^38                 ”       double       8Byte       4.9 * 10^-324 ~ 1.8 * 10^308                 논리       boolean       1Byte       true or false               2. 변수 – A   - 변수명 작성 규칙      영문자, 숫자, 언더바 사용 가능   첫 글자는 숫자 올 수 없음   글자 수 제한 없음   공백이나 특수문자 사용 불가   대소문자 구분   예약어를 변수명으로 사용할 수 없음   변수 선언 시 문장 끝에 반드시 ; 붙어야 함   - 기억 클래스      기억영역을 결정하는 작업                  종류       기억영역       예약어       생존기간       사용 범위                       자동 변수       메모리(스택)       auto       일시적       지역적                 레지스터 변수       레지스터       register       ”       ”                 정적 변수(내부)       메모리(데이터)       static       영구적       ”                 정적 변수(외부)       ”       ”       ”       전역적                 외부 변수       ”       extern       ”       ”              자동 변수            함수나 코드의 범위를 한정하는 블록 내에서 선언되는 변수       함수나 블록을 벗어나면 자동으로 소멸       초기화하지 않으면 쓰레기값이 저장됨           외부 변수            선언된 변수나 함수를 참조하기 위한 변수       함수 밖에서 선언       함수가 종료된 후에도 값이 소멸되지 않음       초기화되지 않으면 자동으로 0으로 초기화       다른 파일에서 선언된 변수를 참조할 경우 초기화 할 수 없음           정적 변수            함수나 블록 내에서 선언하는 내부 정적 변수, 함수 외부에서 선언하는 외부 정적 변수       내부 정적 변수는 함수나 블록 내에서만 사용, 외부 정적 변수는 모든 함수에서 사용       함수나 블록이 종료된 뒤에도 값이 소멸되지 않음       초기화는 변수 선언 시 한 번만 가능. 초기화를 생략하면 자동으로 0으로 초기화           레지스터 변수            메모리가 아닌 CPU 내부의 레지스터에 기억영역을 할당받는 변수       자주 사용하는 변수를 레지스터에 저장하여 처리 속도를 높이기 위해 사용       함수나 블록을 벗어나면 자동으로 소멸       데이터를 저장할 레지스터가 없는 경우 자동 변수로 취급되어 메모리에 할당       변수의 주소를 구하는 주소 연산자(&amp;)를 사용할 수 없음           - 변수의 선언      자료형 변수명 = 값;       3. 연산자 – A   - 산술 연산자      산술 계산에 사용되는 연산자   +, -, *, /, %, ++, –   ++, –            전치 : 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용       후치 : 변수를 연산에 사용한 후 변수의 값을 증감           - 관계 연산자      참, 거짓을 결과로 얻는 연산자   ==, !=, &gt;, &gt;=, &lt;, &lt;=   - 비트 연산자      비트별(0, 1)로 연산하여 결과를 얻는 연산자                                   &amp;, ^,           , ~, «, »                           - 논리 연산자      참, 거짓을 결과로 얻는 연산자                                   &amp;&amp;,                       , !                           - 대입 연산자      연산식을 간략하게 입력할 수 있음   산술, 관계, 비트, 논리 연산자에 모두 적용 가능   +=, -=, *=, /=, %=, «=, »=   - 조건 연산자      조건에 따라 서로 다른 수식을 수행   조건 ? 수식1 : 수식2 : 조건의 수식이 참이면 수식1, 거짓이면 수식2 실행   - 기타 연산자      sizeof : 자료형의 크기를 표시   ,(콤마) : 한 줄에 두 개 이상의 수식을 작성하거나 변수를 정의. 순서 연산자   (자료형) : 형 변환을 위해 사용. cast 연산자   - 연산자 우선순위                  대분류       중분류       연산자       결합규칙       우선 순위                       단항 연산자       단항 연산자       ! ~ ++ – sizeof       ←       1                 이항 연산자       산술 연산자       * / %       →       2                 ”       ”       + -       ”       3                 ”       시프트 연산자       « »       ”       4                 ”       관계 연산자       &lt; &lt;= &gt;= &gt;       ”       5                 ”       ”       == !=       ”       6                 ”       비트 연산자       &amp;       ”       7                 ”       ”       ^       ”       ”                 ”       ”       비트 or       ”       ”                 ”       논리 연산자       &amp;&amp;       ”       8                 ”       ”       논리 or       ”       ”                 삼항 연산자       조건 연산자       ? :       →       9                 대입 연산자       대입 연산자       = += -= *= /= %= «= »= 등       ←       10                 순서 연산자       순서 연산자       ,       →       11               4. 제어문 – A   - 단순 if 문      조건이 한 개 일 때 사용   // 조건이 참일 때만 실행 if (조건)   실행할 문장1;   실행할 문장2;   // 조건이 참일 떄와 거짓 때 실행할 문장이 다름 if (조건)   실행할 문장1; else   실행할 문장2;       - 다중 if 문   // else if if (조건1)   실행할 문장1; else if (조건2)   실행할 문장2; else if (조건3)   실행할 문장3; else   실행할 문장4;   // 중첩 if문 if (조건1)   {     if (조건2)       실행할 문장1;     else       실행할 문장2   } else   실행할 문장3;       - switch문      조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리   switch (수식) {   case 레이블1:     실행할 문장1;     break;   case 레이블2:     실행할 문장2;     break;   default:     실행할 문장3; }       - goto문      현재 위치에서 원하는 다른 문장으로 건너뛰어 수행을 계속하기 위해 사용   많이 사용하면 프로그램의 이해와 유지 보수가 어려워져 거의 사용하지 않음   goto 레이블; 레이블:   실행할 문장       5. 반복문 – A   - for문      초기값, 최종값, 증가값을 지정하는 수식을 이용해 정해진 횟수를 반복   for(식1; 식2; 식3)   실행할 문장;       - while 문      조건이 참인 동안 실행할 문장을 반복   while(조건)   실행할 문장;       - do ~ while문      실행할 문장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여부를 결정   do   실행할 문장; while(조건);       - break, continue      break : switch문이나 반복문 안에서 break가 나오면 블록을 벗어남   continue : continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮김. 반복문에서만 사용       6. 배열과 문자열 – A   - 배열의 개념      개별적인 요소들의 위치는 첨자를 이용하여 지정   변수명 뒤에 []를 붙이고 그 안에 사용할 개수 지정   배열의 위치는 0부터 시작   행 우선으로 데이터가 기억장소에 할당   첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같음   - 1차원 배열   자료형 변수명[개수];       - 2차원 배열   자료형 변수명[행개수][열개수]       - 배열의 초기화      배열 선언 시 초기값을 지정할 수 있음   배열 선언 시 배열의 크기를 생략하는 경우, 반드시 초기값을 지정해야 함   - 배열 형태의 문자열 변수      C에서 “ “로 묶인 글자는 글자 수에 관계없이 문자열로 처리   C에는 문자열을 저장하는 자료형이 없기 때문에 배열, 포인터를 이용하여 처리   배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 널 문자(‘\\0’)가 자동으로 삽입   배열에 문자열을 저장할 때는 배열 선언 시 초기값으로 지정. 선언된 배열에는 문자열 저장 불가   널 문자를 고려하여 배열 크기를 지정해야 함   char 배열이름[크기] = \"문자열\"      Java에는 주소를 컨트롤하는 기능이 없음   하지만 Java는 문자열을 처리할 수 있도록 클래스를 제공       7. 포인터 – A   - 포인터와 포인터 변수      포인터는 변수의 주소를 말함. C에서는 주소를 제어할 수 있는 기능을 제공   변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라 함   포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 * 를 붙임(int *a;)   포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 &amp; 를 붙임(a = &amp;b;)   실행문에서 포인터에 * 를 붙이면 해당 포인터 변수가 가리키는 곳의 값임(c = *a;)   포인터 변수는 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수   포인터 변수의 용도            연결된 자료 구조를 구성하기 위해 사용       동적으로 할당된 자료 구조를 지정하기 위해 사용       배열을 인수로 전달하기 위해 사용       문자열을 표현하기 위해 사용       요소를 효율적으로 저장하기 위해 사용       메모리에 직접 접근하기 위해 사용           - 포인터와 배열      배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근 가능   첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것   배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 &amp; 연산자 사용   배열의 요소가 포인터인 포인터형 배열을 선언할 수 있음   int a[5], *b;       8. 데이터 입출력 – A   - C언어의 표준 입출력 함수의 개요      키보드로 입력받아 화면으로 출력할 때 사용하는 함수   - scanf() 함수      표준 입력함수. 키보드로 입력받아 변수에 저장   // 형식 scanf(서식 문자열, 변수의 주소)  // % : 서식 문자임을 지정 // 3 : 입력 자릿수를 3자리로 지정 // d : 10진수로 입력 // &amp;a : 입력받은 데이터를 변수 a의 주소에 저장 scanf(\"%3d\", &amp;a);      특징            입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있음       여러 개의 데이터를 입력 받을 수 있음       서식 문자열과 변수의 자료형은 일치해야 함           서식 문자열            %d : 정수형 10진수를 입출력       %u : 부호없는 정수형 10진수를 입출력       %o : 정수형 8진수를 입출력       %x : 정수형 16진수를 입출력       %c : 문자를 입출력       %s : 문자열을 입출력       %f : 소수점을 포함하는 실수를 입출력       %e : 지수형 실수를 입출력       %ld : long형 10진수를 입출력       %lo : long형 8진수를 입출력       %lx : long형 16진수를 입출력       %p : 주소를 16진수로 입출력           - Java에서의 표준 입력      Scanner 클래스를 이용해 키보드로부터 값을 입력받는 객체 변수를 생성한 후 사용   // 형식 Scanner scan = new Scanner(System.in); a = scan.nextInt();      객체 변수 생성            Scanner : 입력에 사용할 객체 변수를 생성할 때 사용       scan : 객체 변수명       new : 객체 생성 예약어       Scanner() : 클래스 이름       System.in : 표준 입력장치. 즉 키보드           객체 변수 활용            a : 입력받은 값을 저장할 변수       scan.nextInt()                    scan : 입력에 사용할 객체 변수 이름           nextInt() : 입력받은 값을 정수형으로 반환                           - printf() 함수      C언어의 표준 출력 함수. 인수로 주어진 값을 화면에 출력   // 형식 printf(서식 문자열, 변수)  // % : 서식 문자임을 지정 // - : 왼쪽부터 출력 // 8 : 출력 자리수를 8자리로 지정 // 2 : 소수점 이하를 2자리로 지정 // f : 실수로 출력 printf(\"%-8.2f\", 200.2) // 200.20VV (V는 빈칸을 의미)      주요 제어 문자            \\n : 커서를 다음 줄 앞으로 이동       \\b : 커서를 왼쪽으로 한 칸 이동       \\t : 커서를 일정 간격 띄움       \\r : 커서를 현재 줄의 처음으로 이동       \\0 : 널 문자를 출력       ' : 작은따옴표 출력       \" : 큰따옴표 출력       \\a : 스피커로 벨 소리를 출력       \\ : 역 슬래시를 출력       \\f : 한 페이지를 넘김           - Java에서의 표준 출력      Java에서 값을 화면에 출력할 때는 printf() 메소드 이용   // 형식 System.out.printf(서식 문자열, 변수)      System 클래스의 서브 클래스인 out 클래스의 메소드 printf()를 사용하여 출력   - 기타 표준 입출력 함수      입력            getchar() : 한 문자를 입력받아 변수에 저장       gets() : 문자열을 입력받아 변수로 저장. enter를 누르기 전까지를 하나의 문자열로 인식           출력            putchar() : 한 문자를 화면에 출력       puts() : 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp16/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 4-3. 응용 SW 기초 기술 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 운영체제의 개념 – A   - 운영체제(OS; Operating System)의 정의      시스템의 자원을 효율적으로 관리   컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공   사용자와 하드웨어 간의 인터페이스로서 동작하는 시스템 S/W   응용 프로그램이 유용한 작업을 할 수 있도록 환경 제공   - 운영체제의 목적      처리 능력 : 일정 시간 내에 시스템이 처리하는 일의 양   반환 시간 : 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간   사용 가능도 : 즉시 사용 가능한 정도   신뢰도 : 문제를 정확하게 해결하는 정도   - 운영체제의 기능      프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원 관리   자원의 스케줄링 기능 제공   편리한 인터페이스 제공   각종 하드웨어와 네트워크를 관리 및 제어   데이터를 관리하고 데이터 및 자원의 공유 기능 제공   시스템의 오류를 검사하고 복구   자원 보호 기능 제공   입출력에 대한 보조 기능 제공   가상 계산기 기능 제공   - 운영체제의 주요 자원 관리      프로세스 관리 : 스케줄링 및 동기화 관리, 생성과 제거, 시작과 정지, 메시지 전달   기억장치 관리 : 프로세스에게 메모리 할당 및 회수 관리   주변장치 관리 : 입출력장치 스케줄링 및 전반적인 관리   파일 관리 : 파일의 생성과 삭제, 변경, 유지 등의 관리   - 운영체제의 종류      Windows : MS사 개발. GUI   UNIX : AT&amp;T 벨 연구소, MIT, General Electric 공동 개발. CLI   LINUX : UNIX와 호환이 가능한 커널. 누구나 제한 없이 활용 및 재배포 가능. CLI   MacOS : 애플사가 UNIX를 기반으로 개발. GUI   MS-DOS : Windows 이전에 사용되던 운영체제. CLI   단일 작업 처리 시스템에는 MS-DOS   다중 작업 처리 시스템에는 Windows, UNIX, LINUX, MacOS 등   개인용 운영체제는 Windows, MacOS, MS-DOS   서버용 운영체제는 UNIX, LINUX       2. Windows – C      GUI   선점형 멀티태스킹   PnP(Plug and Play, 자동 감지 기능)   OLE   255자의 긴 파일명   Single-User 시스템       3. UNIX/LINUX/MacOS – A   - UNIX의 개요 및 특징      대화식 운영체제. 소스가 공개된 개방형 시스템   C언어로 작성되어 이식성이 높으며 장치, 프로세스 간의 호환성이 높음   크기가 작고 이해하기 쉬움   Multi-User, Multi-Tasking 지원   많은 네트워킹 기능을 제공하므로 통신망 관리용 운영체제로 적합   트리 구조의 파일 시스템   전문적인 프로그램 개발에 용이   다양한 유틸리티 프로그램 존재   - UNIX 시스템의 구성      커널            컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하며 실행       하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할       프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환           쉘            명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기       시스템과 사용자 간의 인터페이스 역할       DOS의 COMMAND.COM과 같은 기능       주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재       보조 기억장치에서 교체 처리 가능       파이프라인 기능을 지원하고 입출력 재지정을 통해 출력과 입력의 방향을 변경 가능       공용 쉘이나 사용자 자신이 만든 쉘을 사용할 수 있음           Utility Program            일반 사용자가 작성한 응용 프로그램을 처리       DOS에서의 외부 명령어에 해당       에디터, 컴파일러, 인터프리터, 디버거 등           - UNIX에서의 프로세스 간 통신      각 프로세스는 시스템 호출을 통해 커널의 기능을 사용   시그널, 파이프, 소켓 등을 사용   시그널 : 간단한 메시지를 이용하여 통신. 초기 UNIX 시스템에서 사용됨   파이프 : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식   소켓 : 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식   - LINUX의 개요 및 특징      UNIX를 기반으로 개발   프로그램 소스 코드가 무료로 공개되어 원하는 기능을 추가할 수 있음   다양한 플랫폼에 설치하여 사용 가능. 재배포 가능   UNIX와 완벽하게 호환   대부분의 특지잉 UNIX와 동일   - MacOS의 개요 및 특징      애플사가 UNIX를 기반으로 개발   애플 사에서 생산하는 제품에서만 사용 가능   드라이버 설치 및 install과 uninstall의 과정이 단순       4. 기억장치 관리의 개요 – A   - 기억장치 계층 구조의 특징      레지스터 - 캐시 기억장치 - 주기억장치 - 보조기억장치   상위의 기억장치일수록 접근 속도와 접근 시간이 빠르지만, 기억 용량이 적고 고가   주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성. 주소를 이용한 액세스 가능   레지스터, 캐시 기억장치, 주기억장치의 프로그램과 데이터는 CPU가 직접 액세스 할 수 있음   보조기억장치에 있는 프로그램이나 데이터는 CPU가 직접 액세스 할 수 없음   보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스 될 수 있음   - 기억장치 관리 전략의 개요      보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치등을 지정   한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것   @ 반입(Fetch) 전략      보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정   요구반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재   예상반입 : 참조될 프ㅗ그램이나 데이터를 미리 예상하여 적재   @ 배치(Placement) 전략      새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정   최초 적합 : 빈 영역 중에서 첫 번째 분할 영역에 배치   최적 적합 : 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치   최악 적합 : 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치   @ 교체(Replacement) 전략      모든 영역이 이미 사용중인 상태에서, 어느 영역을 교체하여 사용할 것인지를 결정   FIFO, OPT, LRU, LFU, NUR, SCR 등       5. 가상기억장치 구현 기법 / 페이지 교체 알고리즘 – A   - 가상기억장치의 개요      보조기억장치의 일부를 주기억장치처럼 사용하는 것   프로그램을 여러 개의 작은 블록 단위로 나누어서 가상 기억장치에 보관   프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리   주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용   주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있음   가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환작업이 필요   연속 할당 방식에서 발생할 수 있는 단편화를 해결   블록의 종류에 따라 페이징 기법과 세그멘테이션 기법으로 나눔   - 페이징(Paging) 기법      가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눔   나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행   프로그램을 일정한 크기로 나눈 단위를 Page라고 함   Page 크기로 일정하게 나누어진 주기억장치의 단위를 Page Frame이라고 함   외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음   주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 Page Map Table이 필요   Page Map Table 사용으로 비용이 증가되고, 처리 속도가 감소   - 세그멘테이션(Segmentation) 기법      가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적 단위로 나눈 후 주기억장치에 적재시켜 실행   프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 Segment라고 함   각 Segment는 고유한 이름과 크기를 가짐   기억장치의 사용자 관점을 보존하는 기억장치 관리 기법   기억공간을 절약하기 위함   주소 변환을 위해서 Segment가 존재하는 위치 정보를 가지고 있는 Segment Map Table 필요   Segment가 주기억장치에 적재될 때 다른 Segment에게 할당된 영역을 침범할 수 없음. 기억장치 보호키 필요   내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있음   - 페이지 교체 알고리즘      페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정   @ OPT(최적 교체)      앞으로 가장 오랫동안 사용하지 않을 페이지를 교체   페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘   @ FIFO      가장 먼저 들어와서 가장 오래 있었던 페이지를 교체   이해하기 쉽고, 프로그래밍 및 설계가 간단   @ LRU(Least Recently Used)      최근에 가장 오랫동안 사용하지 않은 페이지를 교체   각 페이지마다 계수기나 스택을 두어 현 시점에서 가장 오랫동안 사용하지 않은 페이지 교체   @ LFU(Least Frequently Used)      사용 빈도가 가장 적은 페이지를 교체   @ NUR(Not Used Recently)      최근에 사용하지 않은 페이지를 교체   LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음   각 페이지마다 참조 비트와 변형 비트를 사용   @ SCR(Second Chance Replacement, 2차 기회 교체)      가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위함   FIFO기법의 단점을 보완       6. 가상기억장치 기타 관리 사항 – A   - 페이지 크기      페이지 크기가 작을 경우            페이지 단편화가 감소, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬       효율적인 워킹 셋을 유지       기억장치 효율이 높아짐       Page Map Table의 크기가 커지고, Mapping 속도가 늦어짐       전체적인 입출력 시간은 늘어남           페이지 크기가 클 경우            페이지 단편화가 증가, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남       불필요한 내용까지도 주기억장치에 적재       Page Map Table의 크기가 작아지고, Mapping 속도가 빨라짐       전체적인 이불력의 효율성 증가           - Locality      프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질   스래싱을 방지하기 위한 워킹 셋 이론의 기반   프로세스가 집중적으로 사용하는 페이지를 알아내는 방법. 가상기억장치 관리의 이론적 근거   Denning에 의해 구역성의 개념이 증명. 캐시 메모리 시스템의 이론적 근거   시간 구역성            하나의 페이지를 일정 시간 동안 집중적으로 액세스 하는 현상       참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음       Loop, Stack, Sub Routine, Counting, Totaling에 사용되는 변수           공간 구역성            일정 위치의 페이지를 집중적으로 액세스 하는 현상       참조한 페이지 근처의 페이지를 계속 참조할 가능성이 높음       배열 순회, 순차적 코드의 실행, 관련된 변수를 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때           - 워킹 셋(Working Set)      프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합   프로그램의 Locality 특징을 이용   자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정됨   자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경됨   - 페이지 부재 빈도 방식      페이지 부재는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상   페이지 부재 빈도는 페이지 부재가 일어나는 횟수   페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식   운영체제는 임의의 페이지 프레임을 할당하고, 부재율이 상한선을 넘어가면 좀더 많은 페이지 프레임을 할당하고, 부재율이 하한선을 넘어가면 페이지 프레임을 회수   - 프리페이징(Prepaging)      처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 한번에 페이지 프레임에 적재   사용되지 않는 페이지가 많을 수도 있음   - 스래싱(Thrashing)      프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상   자주 페이지 부재가 발생함으로써 나타나는 현상. 시스템의 성능이 저하됨   다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 특정 시점까지는 높아짐   정도가 더욱 커지면 스래싱이 나타나고, CPU 이용률은 급격히 감소   스래싱 현상 방지 방법            다중 프로그래밍의 정도를 적정 수준으로 유지       페이지 부재 빈도를 조절하여 사용       워킹 셋을 유지       부족한 자원을 증설하고, 일부 프로세스를 중단시킴       CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영               7. 프로세스의 개요 – A   - 프로세스의 정의      프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 실행중인 프로그램   작업, 태스크라고도 함   PCB를 가진 프로그램   실기억장치에 저장된 프로그램   프로세서가 할당되는 실체. 디스패치가 가능한 단위   프로시저가 활동중인 것   비동기적 행위를 일으키는 주체   지정된 결과를 얻기 위한 일련의 계통적 동작   목적 또는 결과에 따라 발생되는 사건들의 과정   운영체제가 관리하는 실행 단위   - PCB(Process Control Block, 프로세스 제어 블록)      운영체제가 프로세스에 대한 정요한 정보를 저장해 놓는 곳   각 프로세스가 생성될 때마다 고유의 PCB가 생성. 프로세스가 완료되면 PCB 제거   PCB에 저장된 정보            프로세스의 현재 상태       포인터       프로세스 고유 식별자       스케줄링 및 프로세스의 우선순위       CPU 레지스터 정보       주기억장치 관리 정보       입출력 상태 정보       계정 정보           - 프로세스 상태 전이      프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것   제출(Submit)            작업을 시스템에 제출한 상태           접수(Hold)            제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태           준비(Ready)            프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태       프로세스는 준비상태 큐에서 실행을 준비       접수 상태에서 준비 상태로의 전이는 Job 스케줄러에 의해 수행           실행(Run)            준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태       할당 시간이 종료되면 프로세스는 준비 상태로 전이       입출력 처리가 필요하면 실행중인 프로세스는 대기 상태로 전이       준비 상태에서 실행 상태로의 전이는 CPU 스케줄러에 의해 수행           종료(Terminated, Exit)            프로세스의 실행으 끝나고 프로세스 할당이 해제된 상태           - 프로세스 상태 전이 관련 용어      Dispatch : 준비 상태에서 대기하고 이쓴 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이   Wake Up : 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이   Spooling : 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입출력 데이터를 직접 입출력 장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장   교통량 제어기(Traffic Controller) : 프로세스의 상태에 대한 조사와 통보 담당   - 스레드(Thread)      프로세스 내에서의 작업 단위. 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위   하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드   하나 이상의 스레드가 존재하는 경우에는 다중 스레드   프로세스의 일부 특성을 갖고 있어 경량 프로세스라고도 함   스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할 담당   동일 프로세스 환경에서 서로 독립적인 다중 수행 가능   분류            사용자 수준의 스레드                    사용자가 만든 라이브러리를 사용하여 스레드 운용           속도는 빠르지만 구현이 어려움                       커널 수준의 스레드                    운영체제의 커널에 의해 스레드를 운용           구현이 쉽지만 속도가 느림                           스레드 사용의 장점            하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진       하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상       응용 프로그램의 응답 시간을 단축       실행 환경을 공유시켜 기억장소의 낭비가 줄어듬       프로세스들 간의 통신 향상       공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신함               8. 스케줄링 – B   - 스케줄링의 개요      시스템의 여러 자원을 해당 프로세스에게 할당하는 작업   장기 스케줄링            어떤 프로세스가 시스템의 자원을 차지하게 할 것인가 결정하여 준비상태 큐로 보내는 작업       작업 스케줄링, 상위 스케줄링이라고도 함. 작업 스케줄러에 의해 수행           중기 스케줄링            어떤 프로세스들이 CPU를 할당받을 것인지를 결정하는 작업       할당받으려는 프로세스가 많으면 일시 보류시킨 후 활성화해서 일시적으로 부하 조절           단기 스케줄링            프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업       프로세서 스케줄링, 하위 스케줄링이라고도 함       프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행됨           - 스케줄링의 목적      CPU나 자원을 효율적으로 사용하기 위한 정책   공정성   처리율 증가   CPU 이용률 증가   우선순위 제도   오버헤드 최소화   응답 시간 최소화   반환 시간 최소화   대기 시간 최소화   균형 있는 자원의 사용   무한 연기 회피   - 프로세스 스케줄링의 기법      비선점(Non-Preemptive) 스케줄링            할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 기법       할당되면 해당 프로세스가 완료될 때까지 CPU 사용       모든 프로세스에 대한 요구를 공정하게 처리 가능       응답 시간의 예측이 용이. 일괄 처리 방식에 적합       중요한 작업이 중요하지 않은 작업을 기다리는 경우 발생 가능       FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘 존재           선점(Preemptive) 스케줄링            할당된 CPU를 우선순위가 높은 다른 프로세스가 강제로 빼앗아 사용할 수 있는 기법       우선순위가 높은 프로세스를 빠르게 처리 가능       빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용       많은 오버헤드를 초래       선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요       Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘 존재               9. 운영체제 기본 명령어 – B   - 운영체제 기본 명령어의 개요      CLI : 키보드로 명령어를 직접 입력하여 작업   GUI : 마우스로 아이콘이나 메뉴를 선택하여 작업   - Windows 기본 명령어      CLI 기본 명령어            DIR : 파일 목록 표시       COPY : 파일 복사       TYPE : 파일 내용 표시       REN : 파일 이름 변경       DEL : 파일 삭제       MD : 디렉터리 생성       CD : 디렉터리 위치 변경       CLS : 화면 내용 지움       ATTRIB : 파일 속성 변경       FIND : 파일 찾음       CHKDSK : 디스크 상태 점검       FORMAT : 디스크 표면을 트랙과 섹터로 나누어 초기화       MOVE : 파일 이동           GUI 기본 명령어            마우스로 작업           - UNIX/LINUX 기본 명령어      CLI 기본 명령어            cat : 파일 내용 표시       chdir : 디렉터리 위치 변경       chmod : 파일의 보호모드를 설정하여 파일의 사용 허가를 지정       chown : 소유자 변경       cp : 파일 복사       exec : 새로운 프로세스 수행       find : 파일 참음       fork : 새로운 프로세스를 생성       fsck : 파일 시스템을 검사하고 보수       getpid : 자신의 프로세스 아이디를 얻음       getppid : 부모 프로세스 아이디를 얻음       ls : 디렉터리 내의 파일 목록 확인       mount/unmount : 파일 시스템을 마운팅/마운팅 해제       rm : 파일 삭제       wait : fork후 exec에 의해 실행되는 하위 프로세스 종료 등의 event를 기다림           GUI 기본 명령어            X Window라는 별도의 프로그램을 설치하여 운영 가능               10. 인터넷 – A   - 인터넷의 개요      TCP/IP 프로토콜을 기반으로 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망   미 국방성의 ARPANET에서 시작됨   UNIX 운영체제를 기반으로 함   시간과 장소에 구애받지 않고 정보 교환 가능   모든 컴퓨터는 고유한 IP 주소를 가짐   컴퓨터 또는 네트워크를 서로 연결하기 위해 브리지, 라우더, 게이트웨이가 사용됨   중추적 역할을 하는 네트워크. 인터넷의 주가 되는 기간망을 Backbone라고 함   - IP 주소(Internet Protocol Address)      인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소   8비트씩 4부분, 총 32비트로 구성   네트워크 부분의 길이에 따라 5단계로 구성   A Class : 국가나 대형 통신망에 사용(0~127). 2^24개의 호스트 사용 가능   B Class : 중대형 통신망에 사용(128~191). 2^16개의 호스트 사용 가능   C Class : 소규모 통신망에 사용(192~223). 2^8개의 호스트 사용 가능   D Class : 멀티캐스트 용으로 사용(224~239)   E Class : 실험적 주소이며 공용되지 않음   - 서브네팅(Subnetting)      할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것   4Byte의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용   - IPv6의 개요      현재 사용하고 있는 IPv4의 주소 부족 문제를 해결하기 위해 개발   128비트의 긴 주소 사용. 자료 전송 속도가 빠름   인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결   IPv4와 호환성이 뛰어남   주소의 확장성, 융통성, 연동성이 뛰어남. 실시간 흐름 제어로 향상된 멀티미디어 기능 지원   Traffic Class, Flow Label을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장 용이   - IPv6 구성      16비트씩 8부분, 총 128비트   각 부분을 16진수로 표현하고 : 으로 구분   유니캐스트 : 1:1 통신에 사용   멀티캐스트 : 1:다 통신에 사용   애니캐스트 : 가장 가까이 있는 단일 수산자 간의 통신. 1:1 통신에 사용   - 도메인 네임      숫자로 된 IP주소를 사람이 이해하기 쉬운 문자 형태로 표현   호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관 종류, 국가명 순으로 구성   왼쪽에서 오른쪽으로 갈수록 상위 도메인 의미   문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP주소로 변환하는 시스템을 DNS라 함   이 역할을 하는 서버를 DNS 서버라고 함       11. OSI 참조 모델 – A   - OSI 참조 모델의 개요      다른 시스템 간의 원활한 통신을 위해 ISO에서 제안한 통신 규약   7단계로 표준화하여 규정   1~3 계층을 하위 계층, 4~7 계층을 상위 계층   하위 계층 : 물리 -&gt; 데이터 링크 -&gt; 네트워크   상위 게층 : 전송 -&gt; 세션 -&gt; 표현 -&gt; 응용   - OSI 참조 모델의 목적      서로 다른 시스템 간을 상호 접속하기 위한 개념을 규정   OSI 규격을 개발하기 위한 범위를 정함   관련 규정의 적합성을 조절하기 위한 공통적 기반 제공   - OSI 참조 모델에서의 데이터 단위      프로토콜 데이터 단위(PDU; Protocol Data Unit)            동일 계층 간에 교환되는 정보의 단위       물리 : 비트       데이터 링크 : 프레임       네트워크 : 패킷       전송 : 세그먼트       세션, 표현, 응용 : 메시지           서비스 데이터 단위(SDU; Service Data Unit)            서비스 접근점(SAP)을 통해 상하위 계층끼리 주고받는 정보의 단위           - 물리 계층(Physical Layer)      전송에 필요한 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙 정의   물리적 전송 매체와 전송 신호 방식을 정의   RS-232C, X.21 등의 표준   관련 장비 : 리피터, 허브   - 데이터 링크 계층(Data Link Layer)      인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 함   송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능   프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능   오류의 검출과 회복을 위한 오류 제어 기능   프레임의 순서적 전송을 위한 순서 제어 기능   HDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준   관련 장비 : 랜카드, 브리지, 스위치   - 네트워크 계층(Network Layer, 망 계층)      개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능   네트워크 연결을 설정, 유지, 해제하는 기능   경로 설정, 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송 수행   X.25, IP 등의 표준   관련 장비 : 라우터   - 전송 계층(Transport Layer)      논리적 안정과 균일한 데이터 전송 서비스 제공. 종단 시스템 간에 투명한 테이터 전송 가능   하위 3계층과 상위 3계층의 인터페이스 담당   종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능   주소 설정, 다중화, 오류 제어, 흐름 제어 수행   TCP, UDP 등의 표준   관련 장비 : 게이트웨이   - 세션 계층(Session Layer)      송수신 측 간의 관련성을 유지하고 대화 제어를 담당   대화 구성 및 동기 제어, 데이터 교환 관리 기능   전송하는 정보의 일정한 부분에 체크점을 두어 정보의 수신 상태 체크. 체크점을 동기점이라고 함   동기점은 오류가 있는 데이터의 회복을 위해 사용   - 표현 계층(Presentation Layer)      응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환   세션 계층에서 받은 데이터는 응용 계층에 맞게 변환   서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요   코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥 관리 기능   - 응용 계층(Application Layer)      사용자가 OSI 환경에 접근할 수 있도록 서비스 제공   응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스 제공       12. 네트워크 관련 장비 – B   - 네트워크 인터페이스 카드(NIC)      컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치   정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경   이더넷 카드(LAN 카드) 혹은 네트워크 어댑터라고도 함   - 허브(Hub)      한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치   각 회선을 통합적으로 관리. 신호 증폭 기능을 하는 리피터의 역할도 포함   더미 허브            네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만을 제공       LAN이 보유한 대역폭을 컴퓨터 수만큼 나누어 제공       네트워크에 연결된 각 노드를 물리적인 성형 구조로 연결           스위칭 허브            네트워크상에 흐르는 데이터의 유무 및 흐름을 제어       각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브       최근에 사용되는 허브는 대부분 스위칭 허브           - 리피터(Repeater)      전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할   OSI 참조 모델의 물리 계층에서 동작하는 장비   근접한 네트워크 사이에 신호를 전송하는 역할   전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도   - 브리지(Bridge)      LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연결하는 기능   데이터 링크 계층 중 MAC(Media Access Control) 계층에서 사용됨   트래픽 병목 현상을 줄일 수 있음   네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있음   브리지를 이용한 서브넷 구성 시 전송 가능한 회선 수는 브리지가 n개일 때 n(n-1)/2개   - 스위지(Switch)      LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치   하드웨어를 기반으로 처리하므로 전송 속도가 빠름   포트마다 각기 다른 전송 속도를 지원하도록 제어 가능. 수십에서 수백 개의 포트 제공   OSI 참조 모델의 데이터 링크 계층에서 사용   - 라우터(Router)      LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능 추가.   LAN과 WAN의 연결도 수행   OSI 참조 모델의 네트워크 계층에서 동작하는 장비   접속 가능한 경로에 대한 정보를 라우팅 제어표에 저장하여 보관   프로토콜 변환 기능 수행   - 게이트웨이(Gateway)      전 계층의 프로토콜 구조가 다른 네트워크의 연결을 수행   데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행   LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할   - 네트워크 장비 설치 시 고려 사항      네트워크에 설치된 장비를 최대한 활용   시스템 확장이나 증설 등을 고려하여 설계   최신 버전을 선정   트래픽을 분산시킬 수 있도록 설계   관리나 유지 보수가 용이하게 설계   장애 발생 시 즉시 조치할 수 있도록 여유 포트를 고려하여 설계   신기술 도입 시 연동할 수 있는 미래 지향적인 네트워크 시스템 구축       13. 프로토콜의 개념 – B   - 프로토콜의 정의      서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화한 통신 규약   하드웨어와 소프트웨어, 문서를 모두 규정   - 프로토콜의 기본 요소      구문(Syntax) : 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정   의미(Semantics) : 협조 사항과 오류 관리를 위한 제어 정보 규정   시간(Timing) : 두 기기 간의 통신 속도, 메시지의 순서 제어 등 규정   - 프로토콜의 기능      단편화와 재결합            송싱 측에서 전송할 데이터를 전송에 알맞은 크기의 작은 블록으로 자르는 작업을 단편화       수신 측에서 단편화된 블록을 원래의 데이터로 모으는 것을 재결합       단편화된 데이터 블록을 프로토콜 데이터 단위(PDU)라고 함       단편화하여 전송하면 전송 시간이 빠르고, 통신중의 오류를 효과적으로 제어 가능       너무 작게 단편화할 경우 재결합 시 처리 시간이 길어지고, 부수적인 데이터가 많아져 비효율적           캡슐화            단편화된 데이터에 송수신지 주소, 오류 검출 코드, 프로토콜 기능을 구현하기 위한 프로토콜 제어 정보 등의 정보를 부가하는 것으로 요약화라고도 함       데이터 링크 제어 프로토콜의 HDLC 프레임       정보 데이터를 오류 없이 정확하게 전송하기 위해 캡슐화 수행           흐름 제어            수신 측의 처리 능력에 따라 송신 측에서 송신하는 데이터의 전송량, 속도를 조절하는 기능       정지-대기, 슬라이딩 윈도우 방식을 이용           오류 제어            전송중에 발생하는 오류를 검출하고 정정하여 데이터나 제어 정보의 파손에 대비하는 기능           동기화            송수신 측이 같은 상태를 유지하도록 타이밍을 맞추는 기능           순서 제어            전송되는 PDU에 전송 순서를 부여하는 기능       연결 위주의 데이터 전송 방식에만 사용       데이터들이 순서적으로 전송되도록 하여 흐름 제어 및 오류 제어를 용이하게 함           주소 지정            데이터가 목적지까지 정확하게 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능           다중화            한 개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능           경로 제어            송수신 측 간의 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능           전송 서비스            우선순위 : 우선순위를 부여하여 우선순위가 높은 메시지가 먼저 도착하도록 함       서비스 등급 : 서비스 등급을 부여하여 서비스       보안성 : 액세스 제한과 같은 보안 체제를 구현               14. TCP/IP – A   - TCP/IP의 개요      인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜   ARPANET에서 사용하기 시작   UNIX의 기본 프로토콜로 사용. 현재 인터넷 범용 프로토콜로 사용   TCP 프로토콜 + IP 프로토콜   TCP            전송 계층       신뢰성 있는 연결형 서비스 제공       패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능 제공       스트림 전송 기능 제공           IP            네트워크 계층       데이터그램을 기반으로 하는 비연결형 서비스 제공       패킷의 분해/조립, 주소 지정, 경로 선택 기능 제공       헤더의 길이는 최소 20Byte에서 최대 60Byte           - TCP/IP의 구조                  OSI       TCP/IP       기능                 응용, 표현, 세션       응용       응용 프로그램 간 데이터 송수신                 전송       전송       호스트들 간의 신뢰성 있는 통신                 네트워크       인터넷       데이터 전송을 위한 주소 지정, 경로 설정                 데이터 링크, 물리       네트워크 액세스       실제 데이터(프레임)를 송수신           - 응용 계층의 주요 프로토콜      FTP            파일을 주고받을 수 있도록하는 원격 파일 전송 프로토콜           SMTP            전자 우편을 교환하는 서비스           TELNET            멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용       시스템 관리 작업을 할 수 있는 가상의 터미널 기능을 수행           SNMP            TCP/IP의 네트워크 관리 프로토콜       네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용           DNS            도메인 네임을 IP 주소로 Mapping하는 시스템           HTTP            WWW에서 HTML 문서를 송수신 하기 위한 표준 프로토콜           - 전송 계층의 주요 프로토콜      TCP            양방향 연결형 서비스 제공       가상 회선 연결 형태의 서비스 제공       스트림 위주의 전달(패킷 단위)       신뢰성 있는 경로를 확립하고 메시지 전송 감독       순서 제어, 오류 제어, 흐름 제어       패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할 때 투명성 보장하는 통신 제공           UDP            비연결형 서비스 제공       상대적으로 단순한 헤더 구조를 가져 오버헤드가 적음       빠른 속도, 동시에 여러 사용자에게 데이터 전달, 반복해서 전송할 경우 사용       실시간 전송에 유리       신뢰성보다는 속도가 중요시되는 네트워크에 사용 -RTCP       RTP 패킷의 전송 품질을 제어하기 위한 제어 프로토콜       세션에 참여한 각 참여자들에게 주기적으로 제어 정보 전송       하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화 제공       데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공       RTCP 패킷은 항상 32비트의 경계로 끝남           - 인터넷 계층의 주요 프로토콜      IP            전송할 데이터에 주소를 지정하고 경로를 설정하는 기능       비연결형인 데이터그램 방식을 사용       신뢰성이 보장되지 않음           ICMP            IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리       헤더는 8Byte           IGMP            멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용           ARP            호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC 주소)로 바꿈           RARP            ARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능           - 네트워크 액세스 계층의 주요 프로토콜      Ethernet(IEEE 802.3)            CSMA/CD 방식의 LAN           IEEE 802            LAN을 위한 표준 프로토콜           HDLC            비트 위주의 데이터 링크 제어 프로토콜           X.25            패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공           RS-232C            공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공          ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp17/",
        "teaser": null
      },{
        "title": "[Javascript] 변수, 함수",
        "excerpt":"1. 변수      데이터를 저장하고 참조하는 데이터의 이름   var, let, const   - let   // 재사용 가능 let a = 2; let b = 5;  console.log(a + b);  // 7 console.log(a - b);  // -3 console.log(a * b);  // 10 console.log(a / b);  // 0.4   // 값의 재할당 가능 let a = 12; console.log(a);  // 12  a = 999; console.log(a);  // 999       - const   // 값의 재할당 불가 const a = 12; console.log(a);  // 12  a = 999; console.log(a);  // TypeError: Assignment to constant variable       - 변수 유효범위      let, const : 블록 레벨의 유효범위   var : 함수 레벨의 유효범위   // const, let function scope() {   if (true) {     const a = 123;     console.log(a);  // 블록 내부   } } scope();  // 123;  // const, let function scope() {   if (true) {     console.log(a);  // 블록 내부     const a = 123;   } } scope();  // undefined  // const, let function scope() {   if (true) {     const a = 123;   }   console.log(a);  // 함수 내부 } scope();  // ReferenceError: a is not defined  // const, let function scope() {   console.log(a);  // 함수 내부   if (true) {     const a = 123;   } } scope();  // ReferenceError: a is not defined       // var function scope() {   if (true) {     const a = 123;     console.log(a);  // 블록 내부   } } scope();  // 123  // var function scope() {   if (true) {     console.log(a);  // 블록 내부     const a = 123;   } } scope();  // undefined  // var function scope() {   if (true) {     const a = 123;   }   console.log(a);  // 함수 내부 } scope();  // 123  // var function scope() {   console.log(a);  // 함수 내부   if (true) {     const a = 123;   } } scope();  // undefined      var은 의도하지 않은 범위에서 변수가 사용될 수 있음   그만큼 메모리를 차지하고, 결국 개발자가 확인하지 못하는 메모리 누수로 발전할 수 있음   즉 let과 const를 사용해 블록레벨의 유효범위를 만들어 주는 것이 관리하기 효과적       2. 함수      특정 동작을 수행하는 일부 코드의 집합   // 함수 선언 function helloFunc() {   // 실행 코드   console.log('Hello'); }  // 함수 호출 helloFunc();  // Hello      function returnFunc() {   ruturn 777; }  let a = returnFunc(); console.log(a);  // 777       function sum(a, b) { // a, b는 매개변수(Parameters)   return a + b; }  // 재사용 let a = sum(1, 2);  // 1, 2는 인수(Arguments) let b = sum(3, 4); let c = sum(5, 6);  console.log(a, b, c);  // 3, 7, 11       // 기명 함수 function hello() {   console.log('Hello'); }  // 익명함수 let world = function () {   console.log('World'); }  hello();  // Hello world();  // World       // 객체 데이터 const lww = {   name: 'LWW',   age: '50',   // 메소드   getName: function () {     return this.name;   } };  const hisName = lww.getName(); console.log(hisName);  // LWW // 혹은 console.log(lww.getName());  // LWW       - 화살표 함수   // () =&gt; {}  vs  function () {}  //기존 함수 const double = function (x) {   return x * 2; } console.log('double: ', double(7));  // double: 14  // 화살표 함수 const doubleArrow = x =&gt; x * 2;  // 축약 가능 console.log('doubleArrow', doubleArrow(7));  // doubleArrow 14  // 화살표 함수가 객체 데이터를 return 할 때 const doubleArrow = x =&gt; ({ name: 'LWW' }) console.log('doubleArrow', doubleArrow(7))  // {name: \"LWW\"}       - 즉시 실행 함수(IIFE)   // 한번 사용하고 쓸일이 없는 함수의 경우 이름을 지정해 줄 필요가 없음 // 함수를 만들자마자 바로 동작 실행  const a = 5; function double() {   console.log(a * 2); } double();  // 10  // IIFE (function () {   console.log(a * 2) })();  // 10  // IIFE(더 권장되는 방법) (function () {   console.log(a * 2) }());  // 10       - 호이스팅(Hoisting)   // 함수 선언부가 유효범위 최상단으로 끌어올려지는 현상  const a = 5;  double();  // TypeError: double is not a function  const double = function () {   console.log(a * 2); }       // 호이스팅 발생  const a = 5;  double();  // 10  function double() {   console.log(a * 2); }       - 타이머 함수      setTimeout(함수, 시간) : 일정 시간 후 함수 실행   setInterval(함수, 시간) : 시간 간격마다 함수 실행   clearTimeout() : 설정된 Timeout 함수를 종료   clearInterval() : 설정된 Interval 함수를 종료   // setTimeout  setTimeout(function () {   console.log('LWW!');  // 2초 뒤 LWW! }, 2000);  // 화살표 함수 setTimeout(() =&gt; {   console.log('LWW!'); // 2초 뒤 LWW! }, 2000);       // clearTimeout  // h1 태그를 클릭하면 timer함수를 종료 const h1El = document.querySelector('h1') h1El.addEventListener('click', () =&gt; {   clearTimeout(timer); });       // setInterval  const timer = setInterval(() =&gt; {   console.log('LWW!');  // 2초에 한번 LWW! }, 2000);       // clearInterval  // h1 태그를 클릭하면 interval함수를 종료 const h1El = document.querySelector('h1') h1El.addEventListener('click', () =&gt; {   clearInterval(timer); });       - 콜백(Callback)   // 콜백 : 함수의 인수로 사용되는 함수 // 특정한 실행 위치를 보장해주기 위한 방법  function timeout() {   setTimeout(() =&gt; {     console.log('LWW!'); // LWW! 2초뒤에 출력   }, 2000); } timeout(); console.log('Done!'); // Done!이 먼저 출력       function timeout(cb) {   setTimeout(() =&gt; {     console.log('LWW!');  // LWW! 먼저 출력     cb();  // 내가 실행을 보장하고 싶은 장소   }, 2000); } timeout(() =&gt; {   console.log('Done!');  // LWW!가 실행되고 Done! 출력 });       3. 예약어      특별한 의미를 가지고 있어, 변수나 함수 이름 등으로 사용할 수 없는 단어   break, case, catch, continue, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, abstract, boolean, byte, char, class, const, debugger, double, enum, export, extends, final, float, goto, implements, import, int, interface, long, native, package, private, protected, public, short, static, super, synchronized, throws, transient, volatile, as, is, namespace, use, arguments, Array, Boolean, Date, decodeURI, decodeURIComponent, encodeURI, Error, escape, eval, EvalError, Function, Infinity, isFinite, isNaN, Math, NaN, Number, Object, parseFloat, parseInt, RangeError, ReferenceError, RegExp, String, SyntaxError, TypeError, undefined, unescape, URIError …   let this = 'Hello!';  // SyntaxError let if = 123;  // SyntaxError let break = true;  // SyntaxEr  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-varifunc/",
        "teaser": null
      },{
        "title": "[Javascript] 조건문, DOM API, 메소드 체이닝",
        "excerpt":"1. 조건문      조건의 결과에 따라 다른 코드를 실행하는 구문   - if문   let isShow = true; let checked = false;  if (isShow) {   console.log('Show');  // Show }  if (checked) {   console.log('Checked'); }       - if else 문   let isShow = true;  if (isShow) {   console.log('Show');  // Show } else {   console.log('Hide'); }       - else if 문   if (a === 0) {   console.log('a is 0'); } else if (a === 2) {   console.log('a is 2'); } else {   console.log('rest . . . ') }       - switch 문   switch (a) {   case 0 :     console.log('a is 0');     break;   case 2 :     console.log('a is 2');     break;   default :     console.log('rest . . . ') }       2. DOM API   &lt;body&gt;  &lt;div class=\"box\"&gt;Box!!&lt;/div&gt; &lt;/body&gt;   // HTML 요소 1개 검색 const boxEl = document.querySelector('.box');  // HTML 요소에 적용할 수 있는 메소드 boxEl.addEventListener();  // 인수 추가 가능 boxEl.addEventListener(1, 2);  // 1 - 이벤트(Event, 상황) boxEl.addEventListener('click', 2);  // 2 - 핸들러(Handler, 실행할 함수) boxEl.addEventListener('click', function () {   console.log('Click!'); });       // HTML 요소 1개 검색 const boxEl = document.querySelector('.box');  // 요소의 클래스 정보 객체 활용 boxEl.classList.add('active'); let isContains = boxEl.classList.contains('active'); console.log(isContains);  // true  boxEl.classList.remove('active'); isContains = boxEl.classList.contains('active'); console.log(isContains);  // false       // HTML 요소 모두 검색 const boxEls = document.querySelectorAll('.box'); console.log(boxEls);  // 찾은 요소들 반복해서 함수 실행 // 익명 함수를 인수로 추가 boxEls.forEach(function () {});  // 첫 번째 매개변수 : 반복 중인 요소 // 두 번째 매개변수 : 반복 중인 번호 boxEls.forEach(function (boxEl, index) {});  // 출력 boxEls.forEach(function (boxEl, index) {   boxEl.classList.add(`order-${index + 1}`);   console.log(index, boxEl); });       const boxEl = document.querySelector('.box');  // Getter, 값을 얻는 용도 console.log(boxEl.textContent);  // BOX!!  // Setter, 값을 지정하는 용도 boxEl.textContent = 'Change!!'; console.log(boxEl.textContent);  // Change!!       3. 메소드 체이닝   const a = 'Hello!'; // split : 문자를 인수 기준으로 쪼개서 배열로 반환 // reverse : 배열 뒤집기 // join : 배열을 인수 기준으로 문자로 병합해 반환 const b = a.split('').reverse().join('');  // 메소드 체이닝  console.log(a)  // Hello! console.log(b)  // !olleH  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-ifdomchain/",
        "teaser": null
      },{
        "title": "[Git & Github] 버전 관리",
        "excerpt":"1. Git이란?      컴퓨터 파일의 변경사항을 추적   여러 사용자들 간에 해당 파일 작업을 조율   대표적인 버전 관리 시스템(VCS)       2. Git 사용 준비   # 개행 문자(Newline) 설정 # macOS, Linux $ git config --global core.autocrlf input # Windows $ git config --global core.autocrlf true  # 사용자 정보 # commit(버전 생성)을 위한 정보 등록 $ git config --global user.name 'Github 계정 이름' $ git config --global user.email 'Github 이메일'  # 구성 확인 # Q키를 눌러서 종료 $ git config --global --list       3. Git 명령어   # 현재 프로젝트에서 변경사항 추적(버전관리) 시작 $ git init  # 원격 저장소를 로컬 저장소로 복사 $ git clone 원격 저장소 url  # 변경사항을 추적할 특정 파일을 지정 $ git add 파일 이름  # 모든 파일의 변경사항을 추적하도록 지정 $ git add .  # 버전관리 상태 확인 $ git status  # 메시지(-m)와 함께 버전을 생성 $ git commit -m '메시지'  # commit list 확인 $ git log  # 한 버전 뒤로 되돌리기 $ git reset --hard HEAD~1  # N 버전 뒤로 되돌리기 $ git reset --hard HEAD~N  # 되돌린 버전 원상복귀 $ git reset --hard ORIG_HEAD  # origin이라는 별칭으로 원격 저장소를 연결 $ git remote add origin 원격 저장소 url  # origin이란 별칭의 원격 저장소로 버전 내역 전송 $ git push origin master  # 원격 저장소의 master 브랜치 내역 당겨오기 $ git pull origin master  # 병합 없이 원격 저장소의 최신 내용으로 업데이트 $ git fetch  # 파일이 삭제 됐거나 원격 서버에 반영하지 않음 $ git rm 삭제할 파일  # Stage Area에서만 제거하고 Working Directory 상태는 유지 $ git rm --cached  # 아직 add 되지 않은 Working Directory 파일을 스택에 임시 저장 $ git stash  # git stash 목록 확인 $ git stash list  # 가장 최근의 stash 적용 $ git stash apply  ","categories": ["Git"],
        "tags": ["Github","Git"],
        "url": "/git/etc-git-versionmanage/",
        "teaser": null
      },{
        "title": "[Git & Github] Branch",
        "excerpt":"1. Branch란?      독립적인 Working Directory   새로운 작업공간으로 서로 다른 작업과 테스트가 가능       2. Branch Model      master branch            프로젝트의 기본 branch       git init으로 자동 생성       배포용 branch           develop branch            메인 branch       통합 branch           feature branch            topic branch 역할       버그의 수정과 새로운 기능 개발       원격으로 관리하지 않음       개발이 완료되면, develop branch로 merge           release branch            버그 수정 작업 후 정상적으로 동작해 배포 가능하면 master branch로 merge       ‘release-‘를 branch 이름 앞에 붙임           hotfix branch            배포한 버전에 수정이 필요할 경우       ‘hotfix-‘를 branch 이름 앞에 붙임       변경 사항을 develop branch에 merge               3. 명령어   # 원하는 이름의 branch 생성 $ git branch 이름  # 로컬 저장소 branch list 확인 $ git branch  # 원격 저장소 branch list 확인 $ git branch -r  # 로컬, 원격 저장소 branch list 확인 $ git branch -a  # 생성된 branch로 이동 $ git checkout 이름  # 생성과 동시에 branch로 이동 $ git checkout -b 이름  # 원격 저장소에 있는 branch를 가져와서 해당 branch로 이동 $ git checkout -t 이름  # 로컬 저장소에서 branch 삭제 $ git branch -d 이름       4. Branch Working Flow   $ git branch login $ git checkout -b login 개발 $ git add . $ git commit -m 'Add login in new branch' $ git push origin login $ git checkout master $ git pull origin login $ git push origin master $ git branch -d login  ","categories": ["Git"],
        "tags": ["Github","Git"],
        "url": "/git/etc-git-branch/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 5-1. 소프트웨어 개발 방법론 활용",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 소프트웨어 개발 방법론 – A   - 소프트웨어 개발 방법론의 개요      S/W 개발, 유지보수 등에 필요한 일들의 수행 방법과 일들을 효율적으로 수행하기 위해 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것   목적은 S/W 생산성과 품질 향상   - 구조적 방법론      정형화된 분석 잘차에 따라 사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론   쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적   분할과 정복 원리 적용   타당성 검토 -&gt; 계획 -&gt; 요구사항 -&gt; 설계 -&gt; 구현 -&gt; 시험 -&gt; 운용/유지보수   - 정보공학 방법론      정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료 중심의 방법론   대규모 정보 시스템을 구축하는데 적합   정보 전략 계획 수립 -&gt; 업무 영역 분석 -&gt; 업무 시스템 설계 -&gt; 업무 시스템 구축   - 객체지향 방법론      개체를 하나의 객체로 만들어 부품을 조립하듯 S/W를 개발하는 방법론   구조적 기법의 문제점으로 인한 S/W 위기의 해결책   객체, 클래스, 메시지   캡슐화, 정보 은닉, 추상화, 상속성, 다형성   요구 분석 -&gt; 설계 -&gt; 구현 -&gt; 테스트 및 검증 -&gt; 인도   - 컴포넌트 기반 방법론      기존의 시스템이나 S/W를 구성하는 컴포넌트를 조립하여 하나의 새로운 앱을 만드는 방법론   컴포넌트의 재사용이 가능하여 시간과 노력을 절감   유지 보수 비용을 최소화하고 생산성 및 품질을 향상   개발 준비 -&gt; 분석 -&gt; 설계 -&gt; 구현 -&gt; 테스트 -&gt; 전개 -&gt; 인도   - 애자일 방법론      고객의 요구사항 변화에 유연하게 대응할 수 있도록 주기를 반복하며 개발하는 방법론   소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항에 적합   XP, 스크럼, 칸반, 크리스탈 등   사용자 스토리 -&gt; 계획 -&gt; 개발 -&gt; 승인   - 제품 계열 방법론      특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발   임베디드 S/W를 만드는데 적합   영역공학과 응용공학으로 구분            영역공학 : 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역       응용공학 : 제품 요구 분석, 제품 설계, 제품을 구현하는 영역           제품의 요구사항, 아키텍처, 조립 생산이 필요       2. 비용 산정 기법 – A   - 소프트웨어 비용 산정의 개요      개발에 필요한 비용을 산정하는 것   비용을 높게 산정할 경우 예산 낭비와 일의 효율성 저하를 초래   비용을 낮게 산정할 경우 개발자의 부담이 가중되고 품질문제 발생   하향식 비용 산정 기법, 상향식 비용 산정 기법   - 소프트웨어 비용 결정 요소      개발하는 S/W, S/W 개발에 투입되는 자원, S/W 생산성에 따라 결정   프로젝트 요소            제품 복잡도       시스템 크기       요구되는 신뢰도           자원 요소            인적 자원       하드웨어 자원       S/W 자원           생산성 요소            개발자 능력       개발 기간               3. 비용 산정 기법 : 하향식 – A   - 하향식 비용 산정 기법의 개요      과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적 방법   프로젝트 전체 비용을 산정한 후 각 작업별로 비용을 세분화   - 전문가 감정 기법      경험이 많은 두 명 이상의 전문가에게 비용 산정 의뢰   편리하고 신속. 의뢰자로부터 신뢰 얻을 수 있음   과거의 프로젝트와 다른 요소들이 있다는 것을 간과할 수 있음   유사한 프로젝트에 대한 경험이 없을 수 있음   개인적, 주관적   - 델파이 기법      많은 전문가의 의견을 종합하여 산정하는 기법   한 명의 조정자와 여러 전문가로 구성       4. 비용 산정 기법 : 상향식 – A      프로젝트의 세부적인 작업 단위별로 비용 산정 후 집계하여 전체 비용 산정   - LOC(원시 코드 라인 수) 기법      기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구해 비용 산정   측정이 용이하고 이해하기 쉬움   예측치를 이용하여 생산성, 노력, 개발 기간등의 비용 산정   예측치 = (낙관치 + 4 * 기대치(중간치) + 비관치) / 6   노력 = 개발 기간 * 투입 인원 = LOC / 1인당 월평균 생산 코드 라인 수   개발 비용 = 노력 * 단위 비용   개발 기간 = 노력 / 투입 인원   생산성 = LOC / 노력   - 개발 단계별 인원수 기법      각 기능을 구현하는 데 필요한 노력을 생명 주기의 각 단계별로 산정   LOC 기법보다 더 정확       5. 수학적 산정 기법 – A   - 수학적 산정 기법의 개요      상향식 비용 산정 기법   경험적 추정 모형, 실험적 추정 모형이라고도 함   개발 비용 산정의 자동화를 목표로 함   공식은 과거 유사한 프로젝트를 기반으로하여 경험적으로 유도된 것   - COCOMO 모형 개요      LOC에 의한 비용 산정 기법   규모(LOC)를 예측한 후 비용 산정 방정식에 대입하여 비용 산정   유연성이 높아 개발비 견적에 널리 통용   성격에 따라 비용이 다르게 산정   비용 산정 결과는 노력으로 나타남   - COCOMO의 소프트웨어 개발 유형   @ 조직형(Organic Mode)      5만(50KDSI) 라인 이하의 S/W 개발하는 유형   일괄 자료 처리, 과학 기술 계산용, 비즈니스 자료 처리용   사무 처리용, 업무용, 과학용 응용 S/W 개발에 적합   노력(MM) = 2.4 * KDSI^1.05   개발 기간(TDEV) = 2.5 * MM^0.38   @ 반분리형(Semi-Detached Mode)      30만(300KDSI) 라인 이하의 S/W 개발하는 유형   트랜잭션 처리 시스템, 운영체제, DBMS   컴파일러, 인터프리터와 같은 유틸리티 개발에 적합   노력(MM) = 3.0 * KDSI^1.12   개발기간(TDEV) = 2.5 * MM^0.35   @ 내장형(Embedded Mode)      30만(300KDSI) 라인 이상의 S/W 개발하는 유형   최대형 규모의 트랜잭션 처리 시스템, 운영체제   신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템   시스템 프로그램 개발에 적합   노력(MM) = 3.6 * KDSI^1.20   개발 기간(TDEV) = 2.5 * MM^0.32   - COCOMO 모형의 종류   @ 기본형 COCOMO      S/W의 크기와 개발 유형만을 이용하여 비용 산정   개발 노력(MM) = a * KDSI^b   개발 기간(TDEV) = c * MM^d   적정 투입 인원(FPS) = MM / TDEV   인적 비용(COST) = MM * 1인당 월평균 급여   @ 중간형 COCOMO      기본형 COCOMO의 공식을 토대로 사용   제품의 특성   컴퓨터의 특성   개발 요원의 특성   프로젝트 특성   개발 노력(MM) = 기본 COCOMO의 MM * 요인별 노력 승수   개발 기간(TDEV) = c * MM^d   적정 투입 인원(FPS) = MM / TDEV   인적 비용(COST) = MM * 1인당 월평균 급여   @ 발전형 COCOMO      보다 자세하고 정확하게 노력을 산출하여 비용을 산정   S/W 환경과 구성 요소가 사전에 정의되어 있어야 함   개발 과정의 후반부에 주로 적용   중간형 COCOMO 산정 공식을 그대로 사용   노력 승수 = 개발 공정별 노력 승수 * 개발 공정별 가중치   - Putnam 모형      S/W 생명 주기의 전 과정 동안에 사용될 노력의 분포를 가정해주는 모형   생명 주기 예측 모형이라고도 함   Rayleigh-Norden 곡선의 노력 분포도를 기초로 함   대형 프로젝트의 노력 분포 산정에 이용   개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소   개발 노력(MM) = 원시코드 라인수^3 / (환경상수^3 * 개발기간^4)   - 기능 점수(FP) 모형      S/W의 기능을 증대시키는 요인별로 가중치를 부여   요인별 가중치를 합산하여 총 기능 점수를 산출   총 기능 점수와 영향도를 이용하여 기능 점수를 구하고 이를 이용해서 비용 산정   기능 점수(FP) = 총 기능 점수 * (0.65 +(0.1 * 총 영향도))   유용성과 간편성으로 비용 산정 기법 가운데 최선의 평가를 받음   - 자동화 추정 도구      비용 산정의 자동화를 위해 개발된 도구   SLIM : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 함   ESTIMACS : FP 모형을 기초로 함       6. 소프트웨어 개발 표준 – B   - 소프트웨어 개발 표준의 개요      S/W 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준   - ISO/IEC 12207      S/W 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 S/W 생명 주기 표준 제공   기본 생명 주기 프로세스   지원 생명 주기 프로세스   조직 생명 주기 프로세스   - CMMI(Capability Maturity Model Integration)      S/W 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델   초기 -&gt; 관리 -&gt; 정의 -&gt; 정량적 관리 -&gt; 최적화   - SPICE(Software Process Improvement and Capability dEtermination)      정보 시스템 분야에서 S/W 품질 및 생산성 향상을 위하 S/W 프로세스를 평가 및 개선   공식 명칭은 ISO/IEC 15504   목적            프로세스 개선을 위해 개발 기관이 스스로 평가하는 것       요구조건의 만족여부를 개발 조직이 스스로 평가하는 것       계약 체결을 위해 수탁 기관의 프로세스를 평가하는 것           고객-공급자 프로세스   공학 프로세스   지원 프로세스   관리 프로세스   조직 프로세스   불완전 -&gt; 수행 -&gt; 관리 -&gt; 확립 -&gt; 예측 -&gt; 최적화       7. 소프트웨어 개발 방법론 테일러링 – B   - 소프트웨어 개발 방법론 테일러링의 개요      프로젝트 상황 및 특성에 맞도록 정의된 S/W 개발 방법론의 절차, 사용기법 등으 ㄹ수정 및 보완하는 작업   프로젝트 특징 정의 -&gt; 표준 프로세스 선정 및 검증 -&gt; 상위 수준의 커스터마이징 -&gt; 세부 커스터마이징 -&gt; 테일러링 문서화   - 소프트웨어 개발 방법론 테일러링 고려사항      내부적 요건            목표 환경       요구사항       프로젝트 규모       보유 기술           외부적 요건            법적 제약사항       표준 품질 기준           - 소프트웨어 개발 방법론 테일러링 기법      프로젝트 규모와 복잡도에 따른 테일러링 기법   프로젝트 구성원에 따른 테일러링 기법   팀내 방법론 지원에 따른 테일러링 기법   자동화에 따른 테일러링 기법       8. 소프트웨어 개발 프레임워크 – B   - 소프트웨어 개발 프레임워크의 개요      S/W 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해주는 반제품 형태의 S/W 시스템   예외 처리, 트랜잭션 처리, 메모리 공유, 데이터 소스 관리, 서비스 관리, 쿼리 서비스, 로깅 서비스, 사용자 인증 서비스 등   - 스프링 프레임워크      자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크   동적인 웹 사이트의 개발을 위해 다양한 서비스 제공   전자정부 표준 프레임워크의 기반 기술   - 전자정부 프레임워크      공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크   응용 S/W의 표준화, 품질 및 재사용성의 향상을 목적으로 함   오픈 소스 기반의 범용화와 공개된 기술을 활용하여 특정 업체의 종속성 배제   사업별 공통 컴포넌트의 중복 개발 방지   - 닷넷 프레임워크      Windows 프로그램 개발 및 실행 환경을 제공하는 프레임워크   통합 인터넷 전략을 위해 개발   코드 실행을 관리하는 CLR이라는 이름의 가상머신 상에서 작동   메모리 관리, 유형 및 메모리 안정성, 보안, 네트워크 작업 등 제공  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp18/",
        "teaser": null
      },{
        "title": "[Git & Github] Markdown",
        "excerpt":"1. 제목(Header)   #의 개수에 따라 h1 ~ h6 태그의 크기로 Header이 적용   # 제목1 ## 제목2 ### 제목3 #### 제목4 ##### 제목5 ###### 제목6   제목1(Header)  제목2  제목3  제목4  제목5  제목6       2. 문장(Paragraph)   가나다라 마바사아 자차카타 파하.   가나다라 마바사아 자차카타 파하.       3. 줄바꿈(Line Breaks)   - 띄어쓰기 2회   가나다라 마바사아   자차카타 파하   가나다라 마바사아  자차카타 파하.   - br태그   가나다라 마바사아 &lt;br&gt; 자차카타 파하.   가나다라 마바사아   자차카타 파하.       4. 강조(Emphasis)   - 두껍게   **두껍게**   두껍게   - 이텔릭(기울임)   *이텔릭* _이텔릭_   이텔릭   이텔릭   - 취소선   ~~취소선~~   취소선   - 밑줄      권장되지 않음   &lt;u&gt;밑줄&lt;/u&gt;   밑줄   - 색상   &lt;span style=\"color: red\"&gt;색상&lt;/span&gt;   색상       5. 목록(List)   - 순서가 필요한 목록   1. 순서가 필요한 목록1 2. 순서가 필요한 목록2 3. 순서가 필요한 목록3     1. 순서가 필요한 목록1         1. 순서가 필요한 목록1         2. 순서가 필요한 목록2     2. 순서가 필요한 목록2 4. 순서가 필요한 목록4      순서가 필요한 목록1   순서가 필요한 목록2   순서가 필요한 목록3            순서가 필요한 목록1                    순서가 필요한 목록1           순서가 필요한 목록2                       순서가 필요한 목록2           순서가 필요한 목록4   - 순서가 필요하지 않은 목록   - 순서가 필요하지 않은 목록 - 순서가 필요하지 않은 목록 - 순서가 필요하지 않은 목록     - 순서가 필요하지 않은 목록         - 순서가 필요하지 않은 목록         - 순서가 필요하지 않은 목록     - 순서가 필요하지 않은 목록 - 순서가 필요하지 않은 목록      순서가 필요하지 않은 목록   순서가 필요하지 않은 목록   순서가 필요하지 않은 목록            순서가 필요하지 않은 목록                    순서가 필요하지 않은 목록           순서가 필요하지 않은 목록                       순서가 필요하지 않은 목록           순서가 필요하지 않은 목록   - 체크 리스트   - [X] 체크 - [ ] 체크X      체크   체크X       6. 링크(Links)   &lt;a href=\"https://google.com\"&gt;GOOGLE&lt;/a&gt; &lt;br&gt; [GOOGLE](https://google.com)   GOOGLE   GOOGLE       title : 링크에 마우스를 올렸을 때 나타나는 메시지   &lt;a href=\"https://naver.com\" title=\"NAVER로 이동!\"&gt;NAVER&lt;/a&gt; &lt;br&gt; [NAVER](https://naver.com \"NAVER로 이동!\")   NAVER   NAVER       target=”_blank” : 링크를 클릭했을 때 창이 새 탭에 열림   &lt;a href=\"https://naver.com\" title=\"NAVER로 이동!\" target=\"_blank\"&gt;NAVER&lt;/a&gt;   NAVER       7. 이미지(Image)   - 일반   ![이미지](경로)          - 이미지에 링크 걸기   [![이미지](경로)](링크 url)      사진 클릭하면 구글로 이동          8. 인용문   &gt; 남의 말이나 글에서 직접 또는 간접으로 따온 문장.   &gt; (네이버 국어 사전)  &gt; 인용문을 작성하세요! &gt;&gt; 중첩된 인용문 &gt;&gt;&gt; 중중첩된 인용문 1 &gt;&gt;&gt; 중중첩된 인용문 2 &gt;&gt;&gt; 중중첩된 인용문 3      남의 말이나 글에서 직접 또는 간접으로 따온 문장.  (네이버 국어 사전)       인용문을 작성하세요!         중첩된 인용문             중중첩된 인용문 1 중중첩된 인용문 2 중중첩된 인용문 3                9. 인라인(inline) 코드 강조   백틱기호 ` `를 사용해 강조  CSS에서 `background` 혹은 `background-image` 속성으로 요소에 배경 이미지를 삽입할 수 있습니다.   CSS에서 background 혹은 background-image 속성으로 요소에 배경 이미지를 삽입할 수 있습니다.       10. 블록(block) 코드 강조   백틱기호 3개(‘’’) 언어 이름(html, css, javascript, java, c, bash, python…) 코드 백틱기호 3개(‘’’)   '''html \\&lt;a href=\"https://www.google.co.kr/\" target=\"_blank\"&gt;GOOGLE&lt;/a&gt; '''   &lt;a href=\"https://www.google.co.kr/\" target=\"_blank\"&gt;GOOGLE&lt;/a&gt;       '''css .list &gt; li {   position: absolute;   top: 40px; } '''   .list &gt; li {   position: absolute;   top: 40px; }       '''javascript function func() {   var a = 'AAA'   return a; } '''   function func() {   var a = 'AAA'   return a; }       '''bash $ git commit -m 'Study Markdown' '''   $ git commit -m 'Study Markdown'       '''plaintext 가나다라 마바사아   자차카타 파하 '''   가나다라 마바사아   자차카타 파하       11. 표(Table)   |:--| : 왼쪽 정렬 |--:| : 오른쪽 정렬 |:--:| : 가운데 정렬   position 속성  값 | 의미 | 기본값 --|:--:|--: static | 기준 없음 | O relative | 요소 자신 | X absolute | 위치 상 부모 요소 | X fixed | 뷰포트 | X   position 속성                  값       의미       기본값                       static       기준 없음       O                 relative       요소 자신       X                 absolute       위치 상 부모 요소       X                 fixed       뷰포트       X               12. 원시 HTML(Raw HTML)   동해물과 &lt;u&gt;백두산&lt;/u&gt;이 마르고 닳도록&lt;br/&gt; &lt;span style=\"text-decoration: underline;\"&gt;하느님&lt;/span&gt;이 보우하사 우리나라 만세  &lt;a href=\"https://naver.com\" title=\"NAVER로 이동!\" target=\"_blank\"&gt;NAVER&lt;/a&gt;  &lt;img width=\"500\" src=\"https://user-images.githubusercontent.com/62803763/127985736-2879d5fd-621b-4872-8b9b-0b0ce9141c7a.jpg\" alt=\"ggam4\" /&gt;    동해물과 백두산이 마르고 닳도록  하느님이 보우하사 우리나라 만세   NAVER          13. 수평선(Horizontal Rule)   ---  &lt;br&gt;  ***           ","categories": ["Git"],
        "tags": ["Github","Git","Markdown"],
        "url": "/git/etc-git-markdown/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 5-2. IT프로젝트 정보시스템 구축 관리",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 네트워크 관련 신기술 – A   - IoT(Internet of Things, 사물 인터넷)      다양한 사물들을 인터넷으로 서로 연결   환경이나 사물 그 자체가 지능화   사람과 사물, 사물과 사물 간에 지능 통신하는 M2M의 개념을 인터넷으로 확장   개방형 아키텍처를 필요로 함   정보 보안 기술의 적용이 중요   - M2M(Machine to Machine, 사물 통신)      무선 통신을 이용한 기계와 기계 사이의 통신   무선으로 통합하여 상호 작용하는 통신   부호 분할 다중 접속, GSM, 무선 데이터 통신 등 다양한 무선 통신망 사용   - 모바일 컴퓨팅(Mobile Computing)      휴대형 기기로 이동하면서 자유롭게 네트워크에 접속하여 업무 처리   휴대기기는 소형 대용량화와 저전력화 진행중   네트워크 기술은 무선으로 고속/대용량의 정보를 처리할 수 있는 기술 상용화   휴대 기기와 네트워크 기술의 진화로도 가능   비즈니스 효율을 극대화하여 경쟁력을 확보   - 클라우드 컴퓨팅(Cloud Computing)      컴퓨팅 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행할 수 있는 환경   중앙 컴퓨터는 가상화 기술로 통합한 대형 데이터 센터로 각종 S/W, 데이터, 보안 솔루션 기능 등 컴퓨팅 자원을 보유   사용자는 통신 포트만 연결하면 업무 수행 가능   그리드 컴퓨팅과 다른점은 그리드 컴퓨팅이 수많은 컴퓨터를 하나의 컴퓨터처럼 묶어 분산 처리하는 방식으로 기상 예측이나 우주 문제 등 대규모 연산에 사용된다면, 클라우드 컴퓨팅은 중앙의 대형 데이터 센터의 컴퓨팅 자원을 필요한 이들에게 필요한 순간에 빌려주는 방식   - 모바일 클라우드 컴퓨팅(MCC; Mobild Cloud Computing)      클라우드 서비스를 이용하여 소비자와 소비자의 파트너가 모바일 기기로 클라우드 컴퓨팅 인프라를 구성하여 여러 가지 정보와 자원을 공유하는 ICT 기술   모바일 기기의 기종이나 OS 등과 같은 환경에 구애받지 않고 클라우드의 ICT 자원들을 제약 없이 이용하는 것이 가능   모바일의 이동성과 클라우드 컴퓨팅의 경제성 결합   - 인터클라우드 컴퓨팅(Inter-Cloud Computing)      각기 다른 클라우드 서비스를 연동하거나 컴퓨팅 자원의 동적 할당이 가능하도록 여러 클라우드 서비스 제공자들이 제공하는 클라우드 서비스나 자원을 연결하는 기술   대등 접속   연합   중개   - 메시 네트워크(Mesh Network)      대규모 디바이스의 네트워크 생성에 최적화   무선 랜의 한계를 극복하기 위해 라우터들을 기지국으로 활용   모든 구간을 동일한 무선망처럼 구성   사용자는 와이파이에 접속하는 것처럼 안정적인 네트워크를 사용할 수 있음   디바이스가 유기적으로 연결되어 있어야 하는 건물 자동화, 센서 네트워크 등에 적합   - 와이선(Wi-SUN)      장거리 무선 통신을 필요로 하는 사물 인터넷 서비스를 위한 저전력 장거리 통신기술   짧은 시간 동안 데이터 전송이 빈번한 검침 분야에 유용   낮은 지연 속도, 메시 네트워크 기반 확장성, 펌웨어 업그레이드 용이성   - NDN(Named Data Networking)      콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 수행하는 기술   콘텐츠 중심 네트워킹과 같은 개념   콘텐츠에 담겨 있는 정보와 라우터 기능만으로 목적지를 확정   - NGN(Next Generation Network, 차세대 통신망)      유선망 기반의 차세대 통신망   이동 사용자를 목표로 함   이동통신에서 제공하는 완전한 이동성 제공을 목표로 개발   인터넷 프로토콜을 기반으로 구축   - SDN(Software Defined Networking)      네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 S/W로 네트워킹을 가상화하여 제어하고 관리하는 네트워크   네트워크 비용 및 복잡성을 해결할 수 있는 기술   - NFC(Near Field Communication, 근거리 무선 통신)      고주파를 이용한 근거리 무선 통신 기술   RFID 기술의 일종   - UWB(Ultra WideBand, 초광대역)      짧은 거리에서 많은 양의 디지털 데이터를 낮은 전력으로 전송하기 위한 무선 기술   블루투스와 비교되는 기술   땅 속이나 벽면 뒤로도 전송 가능   전파 탐지기 기능으로 인명 구조를 할 수 있는 등 응용 범위 넓음   - 피코넷(PICONET)      여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술   - WBAN(Wireless Body Area Network)      웨어러블 또는 몸에 심는 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술   - GIS(Geographic Information System, 지리 정보 시스템)      위성을 이용해 모든 사물의 위치 정보를 제공해 주는 것   공간 의사 결정에 도움   - USN(Ubiquitous Sensor Network)      센서로 수집한 정보를 무선으로 수집할 수 있도록 구성한 네트워크   모든 것에 RFID 태그를 부착   사물의 인식 정보는 물론 주변의 환경정보까지 탐지   - SON(Self Organizing Network)      주변 상황에 맞추어 스스로 망을 구성하는 네트워크   - 애드 혹 네트워크(Ad-hoc Network)      별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용해 구성한 네트워크   망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합   빠른 망 구성과 저렴한 비용이 장점   - 네트워크 슬라이승(Network Slicing)      물리적인 코어 네트워크 인프라를 독립된 다수의 가상 네트워크로 분리하여 각각의 네트워크를 통해 다양한 고객 맞춤형 서비스를 제공하는 것을 목적으로 하는 네트워크   - 저전력 블루투스 기술(BLE; Bluetooth Low Energy)      연결되지 않은 대기 상태에서는 절전 모드를 유지하는 기술   - 지능형 초연결망      스마트 시티 등 급격하게 증가하는 데이터 트래픽을 효과적으로 수용하기 위해 시행되는 정부 주관 사업       2. 네트워크 구축 – A   - 네트워크 설치 구조      정보를 전달하기 위해서 통신 규약에 의해 연결한 통신 설비의 집합   - 성형(Star, 중앙 집중형)      중앙 컴퓨터가 있고, 이를 중심으로 단말장치들이 연결되는 중앙 집중식 네트워크   포인트 투 포인트 방식   각 단말장치들은 중앙 컴퓨터를 통해 데이터를 교환   단말장치의 추가/제거가 쉬움   중앙 컴퓨터가 고장나면 전체 통신망의 기능이 정지   교환 노드의 수가 가장 적음   - 링형(Ring, 루프형)      컴퓨터와 단말장치들을 서로 이웃하는 것끼리 포인트 투 포인트 방식으로 연결   분산 및 집중 제어 모두 가능   단말장치의 추가/제거 및 기밀 보호가 어려움   전송 지연 발생 가능   중계기의 수가 많아짐   데이터는 단방향 혹은 양방향으로 전송 가능   단방향의 경우 고장나면 전체 통신망에 영향   - 버스형(Bus)      한 개의 통신 회선에 여러 대의 단말장치가 연결   물리적 구조가 간단, 단말장치의 추가/제거 용이   고장나더라도 통신망 전체에 영향을 주지 않아 신뢰성을 높일 수 있음   기밀 보장이 어렵고, 통신 회선 길이에 제한   - 계층형(Tree, 분산형)      중앙 컴퓨터와 일정 지역의 단말장치까지는 하나의 통신 회선으로 연결   이웃하는 단말장치는 일정 지역 내에 설치된 중간 단말장치로부터 다시 연결   분산 처리 시스템을 구성하는 방식   - 망형(Mesh)      모든 지점의 컴퓨터와 단말장치를 서로 연결한 형태. 노드의 연결성 높음   많은 단말장치로부터 많은 양의 통신을 필요로 하는 경우에 유리   공중 데이터 통신망에서 사용. 통신 회선의 총 경로가 가장 김   통신 회선 장애 시 다른 경로를 통하여 데이터 전송 가능   n(n-1)/2, n-1   - 네트워크 분류      근거리 통신망(LAN)            가까운 거리       자원 공유를 목적으로 사용       데이터 전송 속도가 빠르고, 에러 발생률 낮음       버스형, 링형 구조 사용           광대역 통신망(WAN)            멀리 떨어진 사이트들을 연결하여 구성       통신 속도가 느리고, 에러 발생률 높음               3. 스위치 – B   - 스위치 분류      브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치   L2 스위치            OSI 2계층에 속하는 장비       MAC 주소를 기반으로 프레임 전송       동일 네트워크 간의 연결만 가능           L3 스위치            OSI 3계층에 속하는 장비       L2 + 라우터 기능. IP 주소를 기반으로 패킷 전송       서로 다른 네트워크 간의 연결 가능           L4 스위치            OSI 4계층에 속하는 장비       L3 + 로드밸런서       IP주소 및 TCP/UDP를 기반으로 사용자들의 요구를 서버의 부하가 적은 곳에 배분           L7 스위치            OSI 7계층에 속하는 장비       IP주소, TCP/UDP 포트 정보에 패킷 내용까지 참조하여 세밀하게 로드밸런싱           - 스위칭 방식      Store and Forwarding : 데이터를 모두 받은 후 스위칭   Cut-through : 데이터의 목적지 주소만을 확인한 후 바로 스위칭   Fragment Free : 위 두개 장점 결합   - 백본 스위치      네트워크들을 연결할 때 중추적 역할을 하는 네트워크를 백본이라고 함   백본에서 스위칭 역할을 하는 장비를 백본 스위치라고 함   모든 패킷이 지나가는 네트워크의 중심에 배치   대규모 트래픽을 처리하려면 고성능의 백본 스위치를 사용해야 함   L3 스위치가 백본 스위치의 역할을 함   - Hierarchical 3 Layer 모델      액세스 계층            네트워크에 접속할 때 최초로 연결되는 지점       통신을 집약해서 디스트리뷰션 계층으로 전송       장비 성능은 낮아도 되지만 포트수는 사용자수 만큼 있어야 함       L2 스위치 사용           디스트리뷰션 계층            액세스 계층의 장치들이 연결되는 지점       오는 통신을 집약해서 코어 계층으로 전송       LAN 간에 라우팅 기능 수행       라우터, L3 스위치 사용           코어 계층            디스트리뷰션 계층에서 오는 통신을 집약해 인터넷에 연결       백본 계층이라고도 함       전자우편, 인터넷 접속, 화상 회의 등의 기능 수행       백본 스위치 사용               4. 경로 제어 / 트래픽 제어 – B   - 경로 제어의 개요      최적 패킷 교환 경로를 결정하는 기능   한 경로에 데이터의 양이 집중하는 것을 피하면서, 최저의 비용으로 최단 시간에 송신   경로 제어표를 참조. 라우터에 의해 수행   - 경로 제어 프로토콜      효율적인 경로 제어를 위해 네트워크 정보를 생성, 교환, 제어   IGP            하나의 자율 시스템 내의 라우팅에 사용       RIP                    가장 널리 사용됨           소규모 동종의 네트워크 내에서 효율적           대규모 네트워크에서는 사용할 수 없음                       OSPF                    대규모 네트워크에서 많이 사용           라우팅 정보에 변화가 생길 경우, 변화된 정보만 네트워크 모든 라우터에 알림                           EGP            자율 시스템 간의 라우팅, 즉 게이트웨이 간의 라우팅에 사용           BGP            자율 시스템 간의 라우팅 프로토콜       EGP의 단점 보완       초기에는 전체 경로 제어표 교환, 이후에는 변화된 정보만 교환           - 트래픽 제어의 개요      전송되는 패킷의 흐름 또는 그 양을 조절하는 기능   @ 흐름 제어      송수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능   수신 측 버퍼의 오버플로를 방지하기 위한 기능   정지-대기            수신 측의 확인 신호(ACK)를 받은 후에 다음 패킷 전송       한 번에 하나의 패킷만을 전송           슬라이딩 윈도우            수신 통지를 이용하여 송신 데이터의 양을 조절       미리 정해진 패킷의 수만큼 연속적으로 전송       여러 개의 패킷을 전송할 수 있어 전송 효율이 좋음       긍정 ACK이 전달된 경우 윈도우 크기 증가       부정 ACK이 전달된 경우 윈도우 크기 감소           @ 폭주(혼잡) 제어      네트워크 내의 패킷 수를 조절하여 네트워크 오버플로 방지   느린 시작            윈도우의 크기를 2배씩 증가시켜 초기에는 느리지만 갈수록 빨라짐       전송 데이터의 크기가 임계 값에 도덜하면 혼잡 회피 단계로 넘어감           혼잡 회피            노린 시작의 지수적 증가가 임계값에 도달되면 혼잡으로 간주       회피를 위해 윈도우의 크기를 1씩 증가시켜 혼잡을 예방           @ 교착상태 방지      교환기 내에 패킷들을 축적하는 기억 공간이 꽉 차 있을 때 다음 패킷들이 기억 공간에 들어가기 위해 무한정 기다리는 현상   패킷이 같은 목적지를 갖지 않도록 할당   교착상태 발생 시에는 교착상태에 있는 한 단말장치를 선택하여 패킷 버퍼 폐기       5. SW 관련 신기술 – A   - 인공 지능(AI)      컴퓨터 스스로 인간지능적인 작업을 수행하는 시스템   유연한 문제 해결을 지원   개발 언어로 리스프, 프롤로그 등   - 뉴럴링크(Neuralink)      사람의 뇌와 컴퓨터를 결합하는 기술   - 딥 러닝      인간의 두뇌를 모델로 만들어진 인공 신경망   기계 학습 기술   스스로 필요한 데이터를 수집, 분석하여 고속으로 처리   - 전문가 시스템(Expert System)      특정 분야의 전문가가 수행하는 고도의 업무를 지원하기 위한 응용 프로그램   지식 베이스   - 증강현실(AR)      실제 촬영한 화면에 가상의 정보를 부가하여 보여주는 기술   - 블록체인      P2P 네트워크를 이용하여 금융 거래 정보를 참여자의 디지털 장비에 분산 저장   보안 및 거래 안정성 향상   - 분산 원장 기술(DLT; Distributed Ledger Technology)      중앙 데이터 저장소가 존재하지 않고 P2P 망내의 참여자들에게 모든 거래 목록이 분산 저장되어 거래가 발생할 때마다 지속적으로 갱신   - 해시(Hash)      임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환   데이터 무결성 검증 방법   - 양자 암호키 분배(QKD; Quantum Key Distribution)      양자 통신을 위해 비밀키를 분배하여 관리하는 기술   - 프라이버시 강화 기술(PET)      개인정보 위험 관리 기술   다양한 사용자 프라이버시 보호 기술을 통칭   - 디지털 저작권 관리(DRM)      데이터의 저작권 보호를 위해 데이터의 안전한 배포를 활성화하거나 불법 배포 방지   디지털 워터마크 사용 등   - 공통 평가 기준(CC; Common Criteria)      정보 보호 제품 평가 기준   정보화 제품의 정보보호 기능과 이에 대한 사용 환경 등급을 정한 기준   - 개인정보 영향평가 제도(PIA; Privacy Impact Assessment)      개인정보를 활용하는 새로운 정보시스템의 도입   기존 정보시스템의 중요한 변경 시 시스템의 구축, 운영이 기업의 고객은 물론 국민의 사생활에 미칠 영향에 대해 미리 조사, 분석, 평가하는 제도   - 그레이웨어(Grayware)      사용자 입장에서는 유용할 수도 있고 악의적일 수도 있는 S/W   애드웨어, 트랙웨어, 기타 악성 코드나 악성 공유웨어   - 매시업(Meshup)      웹에서 제공하는 정보 및 서비스를 이용하여 새로운 S/W나 서비스, DB 만드는 기술   다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공   - 리치 인터넷 애플리케이션(RIA)      기존 HTML 보다 역동적인 웹페이지를 제공하는 플래시 웹페이지 제작 기술   - 시맨틱 웹(Semantic Web)      컴퓨터가 사람을 대신하여 정보를 읽고 이해하고 가공하여 새로운 정보를 만들어 낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹   - 증발품(Vaporware)      판매 계획 또는 배포 계획은 발표되었으나 실제로 판매, 배포되지 않는 S/W   - 오픈 그리드 서비스 아키텍처(OGSA)      애플리케이션 공유를 위한 웹 서비스를 그리드 상에서 제공   - 서비스 지향 아키텍처(SOA)      정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처   - 서비스형 소프트웨어(SaaS)      사용자가 필요로 하는 서비스만 이용할 수 있도록 한 S/W   S/W 유통 방식의 근본적인 변화를 설명하는 개념   하나의 플랫폼을 이용해 다수의 고객에게 S/W 서비스를 제공   이용한 만큼 돈을 지급   - 소프트웨어 에스크로(Escrow)      S/W를 안정적으로 사용 및 유지보수 받을 수 있도록 소스 프로그램과 기술 정보 등을 제 3의 기관에 보관하는 것   - 복잡 이벤트 처리(CEP; Complex Event Processing)      실시간으로 발생하는 의미 있는 사건만을 추출할 수 있도록 사건 발생 조건을 정의하는 데이터 처리 방법   - 디지털 트윈      현실속의 사물을 S/W로 가상화한 모델       6. 소프트웨어 개발 직무별 보안 활동 – B   - 프로젝트 관리자      보안 전략을 조직 구성원들에게 전달   응용 프로그램 보안 영향을 이해시킴   조직의 상태 모니터링   - 요구사항 분석가      보안 관련 비즈니스 요구사항 설명   구조 정의, 자원에 대한 보안 요구사항 정의   - 아키텍트      보안 기술 문제를 충분히 이해   사용되는 모든 리소스 정의, 각 리소스별로 적절한 보안 요구사항 적용   - 설계자      보안 요구사항의 만족성 여부 확인   최선의 문제 해결 방법 결정   보안 수준에 대한 품질 측정 지원   수정 요구사항을 최소화하기 위한 방법 제공   발생할 수 있는 보안 위험에 대해 이해   발견된 보안 위협에 대해 적절히 대응   - 구현 개발자      시큐어 코딩 표준을 준수하여 개발   S/W 안전 여부를 쉽게 확인할 수 있도록 문서화   - 테스트 분석가      요구사항과 구현 결과를 반복적으로 확인   보안 위험에 대한 학습이나 툴 사용법 정도는 숙지   - 보안 감사자      현재 상태의 보안을 보장   요구사항의 적합성과 완전성을 확인   프로젝트의 전체 단계에서 활동   설계 단계에서는 보안 문제로 이어질 수 있는 사항이 있는지 확인   구현 단계에서는 보안 문제가 있는지 확인       7. HW 관련 신기술 – A   - 고가용성(HA; High Availability)      장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘   클러스터, 이중화 등   - 3D Printing      손으로 만질 수 있는 실제 물체로 만들어내는 것   - 4D Printing      특정 시간이나 조건이 갖추어지면 스스로 형태를 변화시키거나 제조되는 자가 조립 기술이 적용된 제품을 3D Printing하는 기술   - RAID      여러 개의 하드디스크로 디스크 배열을 구성   - 4K 해상도      차세대 고화질 모니터의 해상도를 지칭   - 앤 스크린      N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용하는 서비스   - 컴패니언 스크린      앤 스크린의 한 종류   - 신 클라이언트 PC      하드디스크나 주변장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터   서버 기반 컴퓨팅   - 패블릿      폰 + 태블릿   태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰   - C형 USB      크기가 작고, 어느 방향으로든 연결 가능   - 멤스(MEMS; Micro-Electro Mechanical Systems)      기계 구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치   - 트러스트존 기술      하나의 프로세서 내에 일반 애플리케이션을 처리하는 일반 구역과 보안이 필요한 애플리케이션을 처리하는 보안구역으로 분할하여 관리하는 하드웨어 기반의 보안 기술   - 엠디스크      한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장 장치   - 멤리스터(Memristor)      메모리 + 레지스터   전류의 방향과 양등 기존의 경험을 모두 기억하는 특별한 소자       8. Secure OS – B   - Secure OS의 개요      보안 기능을 갖춘 커널을 이식하여 시스템 자원을 보호하는 운영체제   보안 커널은 TCB를 기반으로 참조 모니터의 개념을 구현하고 집행   메모리, 보조기억장치, 데이터, 하드웨어, 자료 구조, 명령어 등 보호   구현하기 복잡한 것            암호적 분리 : 내부 정보 암호화       논리적 분리 : 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한       시간적 분리 : 동시 실행으로 발생하는 보안 취약점 제거       물리적 분리 : 사용자별로 특정 장비만 사용하도록 제한           참조 모니터            보호대상의 객체에 대한 접근통제를 수행하는 추상머신       이것을 실제로 구현한 것이 보안 커널           참조 모니터와 보안 커널의 특징            격리성 : 부정 조작 불가능       검증가능성 : 적절히 구현되었다는 것을 확인할 수 있어야 함       완전성 : 우회가 불가능           - Secure OS의 보안 기능      식별 및 인증   임의적 접근 통제   강제적 접근 통제   객체 재사용 보호   완전한 조정   신뢰 경로   감사 및 감사기록 축소       9. DB 관련 신기술 – A   - 빅데이터      막대한 양의 정형 또는 비정형 데이터 집합   미래를 예측해 최적의 대응 방안을 찾고, 수익으로 연결하여 새로운 가치 창출   - 브로드 데이터      소비자와 상호 작용을 통해 생성된 기업 마케팅에 효율적인 데이터   소비자의 SNS 활동이나 위치 정보 등   - 메타 데이터      일련의 데이터를 정의하고 설명해 주는 데이터   빠르게 검색하거나 내용을 간략하고 체계적으로 하기 위해 사용   - 디지털 아카이빙      디지털 정보 자원을 장기적으로 보존하기 위한 작업   아날로그 콘텐츠를 디지털로 변환 후 압축해서 저장   디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화   - 하둡(Hadoop)      오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼   가상화된 대형 스토리지를 형성   거대 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 S/W 프레임워크   - 타조(Tajo)      아파치 하둡 기반의 분산 데이터 웨어하우스 프로젝트   빅데이터를 분석할 때 맵리듀스를 사용하지 않고 SQL 사용   대규모 데이터 처리와 실시간 상호 분석에 모두 사용 가능   - 데이터 다이어트      데이터를 삭제하는 것이 아니라 압축   중복 배제하고 새로운 기준에 따라 나누어 저장   방대한 정보를 효율적으로 관리하기 위해 대두된 방안       10. 회복 / 병행제어 – B   - 회복      장애로 DB가 손상됐을 때, 손상되기 이전의 정상 상태로 복구하는 작업   장애의 유형            트랜잭션 장애       시스템 장애       미디어 장애           회복 관리기            DBMS의 구성 요소       트랜잭션 실행이 완료되지 못하면 모든 변화를 취소하고 원래 상태로 복구       메모리 덤프, 로그를 이용해 수행           - 병행제어      다수의 트랜잭션을 병행수행할 때, 트랜잭션 간의 상호 작용을 제어   병행제어의 목적            DB 공유 최대화       시스템 활용도 최대화       DB 일관성 유지       응답 시간 최소화           - 병행수행의 문제점      갱신 분실(Lost Update)   비완료 의존성(Uncommitted Dependency)   모순성(Inconsistency)   연쇄 복귀(Cascading Rollback)       11. 데이터 표준화 – A   - 데이터 표준화의 정의      시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙 수립, 적용   데이터 이름이 중복되지 않고 공통된 의미로 전달되도록 표준 항목명 부여   데이터 요소에서 사용되는 단어에 대해 일정한 규칙이 적용되도록 해야 함   - 데이터 표준      데이터 모델이나 DB에서 정의할 수 있는 모든 오브젝트를 대상으로 표준화 수행   데이터 표준의 종류            표준 단어       표준 도메인       표준 코드       표준 용어           - 데이터 관리 조직      데이터 표준 원칙이나 데이터 표준의 준수 여부 등을 관리하는 사람들                  구분       데이터 관리자(DA)       DB 관리자(DBA)                       관리 대상       데이터 모델, 각종 표준       DB                 주요 업무       요구사항 반영, 메터 데이터 정의       DB 관리                 품질 관리       데이터 표준 관리 및 적용       데이터 정합성 관리           - 데이터 표준화 전략      표준화 요구사항 수집 -&gt; 표준 정의 -&gt; 표준 확정 -&gt; 표준 관리   - 데이터 표준화의 대상      데이터 명칭   데이터 정의   데이터 형식   데이터 규칙   - 데이터 표준화의 기대 효과      명확한 의사소통 가능   데이터의 의미나 위치 등을 쉽게 파악   입력 오류를 방지하고 의사 결정의 오류를 줄여 데이터 품질 향상   시스템 간 데이터 공유 시 데이터 변환이나 정제 작업을 수행하지 않아도 됨   데이터 유지보수 및 운영의 효율성, 관리 비용 절감  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp19/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 5-3. 소프트웨어 개발 보안 구축",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. Secure SDLC – A      SDLC에 보안 강화를 위한 프로세스를 포함   유지 보수 단계에서 보안 이슈를 해결하기 위해 소모되는 많은 비용 최소화   CLASP, SDL 등   SDLC 전체 단계에 걸쳐 수행되어야 할 보안 활동 제시   - 요구사항 분석 단계에서의 보안 활동      요구사항을 식별하는 작업 수행   보안 수준을 보안 요소별로 등급을 구분   보안 정책 항목들의 출처, 요구 수준, 세부 내용 등을 문서화   - 보안 요소      기밀성 : 인가된 사용자에게만 접근 허용. 노출되더라도 읽을 수 없음   무결성 : 인가된 사용자만 수정 가능   가용성 : 인가된 사용자는 언제라도 사용 가능   인증 : 사용자가 합법적인 사용자인지를 확인하는 모든 행위   부인 방지 : 송수신 사실을 부인할 수 없도록 송수신 증거 제공   - 설계 단계에서의 보안 활동      보안 요구사항들을 S/W 설계서에 반영하고, 보안 설계서 작성   위협 식별   보안통제 기준 수립하여 설계에 반영   네트워크 : 네트워크를 분리하거나 방화벽 설치   서버 : 보안이 뛰어난 운영체제 사용, 접근통제 등 실시   물리적 보안 : 출입통제, 개발 공간 제한, 폐쇄회로 등의 감시설비 설치   개발 프로그램 : 허가되지 않은 프로그램 통제. 지속적인 데이터 무결성 검사 실시   - 구현 단계에서의 보안 활동      표준 코딩 정의서 및 S/W 개발 보안 가이드 준수   설계서에 따라 보안 요구사항 구현   지속적인 단위 테스트를 통해 보안 취약점 최소화   코드 점검, 소스 코드 진단 작업   시큐어 코딩   - 테스트 단계에서의 보안 활동      보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작되는지 점검   동적 분석 도구 또는 모의 침투테스트를 통해 위협의 해결여부 검증   위협과 취약점들을 점검할 수 있도록 테스트 계획을 수립하고 시행   모든 결과는 문서화. 개발자에게 피드백   - 유지보수 단계에서의 보안 활동      이전 과정을 모두 수행하였음에도 발생할 수 있는 보안사고들 식별   사고 발생 시 이를 해결하고 보안 패치 실시       2. 세션 통제 – B   - 세션 통제의 개요      세션은 서버와 클라이언트의 연결   세션 통제는 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것   요구사항 분석 및 설계 단계에서 진단   불충분한 세션 관리, 잘못된 세션에 의한 정보 노출   - 불충분한 세션 관리      규칙이 존재하는 세션 ID가 발급되거나 타임아웃이 너무 긴 경우 발생   세션 하이재킹 같은 공격을 통해 중요한 정보에 접근할 수 있음   - 잘못된 세션에 의한 정보 노출      다중 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점   싱글톤 패턴에서 발생하는 레이스컨디션으로 동기화 오류가 발생. 멤버 변수 정보 노출   멤버 변수보다 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지   - 세션 설계시 고려 사항      모든 페이지에서 로그아웃이 가능하도록 UI 구성   로그아웃 요청 시 할당된 세션이 완전히 제거되도록 함   세션 타임아웃은 중요도가 높으면 2~5분, 낮으면 15~30분으로 설정   이전 세션이 종료되지 않으면 새 세션이 생성되지 못하도록 설계   중복 로그인을 허용하지 않은 경우 클라이언트의 중복 접근에 대한 세션 관리 정책 수립   패스워드 변경 시 활성화된 세션을 삭제하고 재할당   - 세션ID의 관리 방법      안전한 서버에서 최소 128비트의 길이로 생성   예측이 불가능하도록 안전한 난수 알고리즘 적용   세션 ID가 노출되지 않도록 URL Rewrite 기능을 사용하지 않는 방향으로 설계   로그인 시 로그인 전의 세션ID를 삭제하고 재할당   장기간 접속하고 있는 세션ID는 주기적으로 재할당       3. 입력 데이터 검증 및 표현 – B   - 입력 데이터 검증 및 표현의 개요      입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목   개발의 구현 단계에서 유효성 검증 체계를 갖춤   검증되지 않은 데이터가 입력되는 경우 이를 처리할 수 있도록 구현   자료형 올바른지 확인, 일관된 언어셋 사용하도록 코딩   - 입력 데이터 검증 및 표현의 보안 약점      SQL 삽입            입력란에 SQL을 삽입하여 무단으로 DB를 조회하거나 조작       동적 쿼리에 사용되는 입력 데이터에 예약어 및 특수문자가 입력되지 않게 필터링           경로 조작 및 자원 삽입            데이터 입출력 경로를 조작하여 서버 자원을 수정, 삭제할 수 있는 보안 약점       경로 순회 공격을 막는 필터를 사용하여 방지           크로스사이트 스크립팅(XSS)            악의적인 스크립트를 삽입하여 방문자들의 정보 탈취, 비정상적 기능 수행 유발       HTML 태그 사용 제한하거나 삽입되지 않도록 &lt;, &gt;, &amp;등의 문자를 다른문자로 치환           운영체제 명령어 삽입            외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취, 장애 유발       웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 함       외부 입력값을 검증 없이 내부 명령어로 사용하지 않음           위험한 형식 파일 업로드            악의적인 명령어가 포함된 스크립트 파일을 업로드하여 시스템에 손상, 제어       파일의 확장자 제한, 파일명 암호화, 웹사이트와 파일 서버 경로 분리, 실행 속성 제거           신뢰되지 않는 URL 주소로 연결            방문자를 피싱 사이트로 유도하는 보안 약점       외부사이트의 주소를 화이트 리스트로 관리하여 방지               4. 보안 기능 – B   - 보안 기능의 개요      S/W 개발의 구현 단계에서 코딩하는 기능인 인증, 접근제어, 기밀성, 암호화 등을 올바르게 구현하기 위한 보안 점검 항목   서비스 환경이나 취급 데이터 맞게 처리될 수 있도록 구현   데이터에 접근하려는 사용자별로 중요도를 구분. 차별화된 인증 방안을 적용   개별적으로 접근 권한을 부여하여 인가되지 않은 기능과 데이터로의 접근 차단   안전한 암호화 기술을 적용   - 보안 기능의 보안 약점      적절한 인증 없이 중요기능 허용            보안검사를 우회하여 인증과정 없이 중요한 정보 또는 기능에 접근 및 변경이 가능       중요 기능을 수행하는 페이지에는 재인증 기능을 수행하도록 하여 방지           부적절한 인가            접근제어 기능이 없는 실행경로를 통해 정보 또는 권한을 탈취할 수 있음       모든 실행경로에 대해 접근제어 검사를 수행. 반드시 필요한 접근 권한만을 부여           중요한 자원에 대한 잘못된 권한 설정            권한 설정이 잘못된 자원에 접근하여 해당 자원을 임의로 사용할 수 있음       S/W 관리자만 자원을 읽고 쓸 수 있도록 설정       인가되지 않은 사용자의 중요 자원에 대한 접근 여부를 검사           취약한 암호화 알고리즘 사용            암호화된 환경설정 파일을 해독하여 비밀번호 등의 중요정보 탈취       안전한 암호화 알고리즘 이용       IT 보안인증사무국이 안정성을 확인한 암호모듈을 이용           중요정보 평문 저장 및 전송            암호화되지 않은 평문 데이터를 탈취하여 중요 정보 획득       반드시 암호화 과정을 거치도록 하고 HTTPS, SSL 같은 보안 채널 이용           하드코드 된 비밀번호            소스코드 유출 시 내부에 하드코드된 패스워드를 이용하여 관리자 권한 탈취       패스워드는 암호화하여 별도의 파일에 저장       디폴트 패스워드나 디폴트 키의 사용을 피함               5. 에러 처리 – B   - 에러처리의 개요      오류들을 사전에 정의하여 오류로 인해 발생할 수 있는 문제들을 예방   프로그래밍 언어의 예외처리 구문을 통해 오류에 대한 사항 정의   예외처리 구문으로 처리하지 못한 오류들은 문제 발생시킬 수 있음   오류 메시지를 통한 정보 노출, 오류 상황 대응 부재, 부적절한 예외처리   - 오류 메시지를 통한 정보 노출      오류 발생으로 중요 정보를 S/W가 메시지로 외부에 노출하는 보안 약점   예외처리 구문에 예외의 이름이나 스택 트레이스를 출력하도록 코딩한 경우 해커는 소프트웨어의 내부구조를 쉽게 파악할 수 있음   오류를 내부에서 처리되도록 하거나 메시지를 출력할 경우 최소한의 정보 또는 사전에 준비된 메시지만 출력되도록 함으로써 방지   - 오류 상황 대응 부재      S/W 개발 중 예외처리를 하지 않았거나 미비로 인해 발생하는 보안 약점   실행이 중단되거나 의도를 벗어난 동작이 유도될 수 있음   예외처리 구문을 작성하고, 제어문을 활용하여 오류가 악용되지 않도록 코딩하여 방지   - 부적절한 예외처리      오류를 세분화하지 않고 한번에 처리하거나, 누락된 예외가 존재할 때 발생하는 보안 약점   모든 오류들을 광범위한 예외처리 구문으로 정의하면 예기치 않은 문제 발생   예상했던 결과와 다른 값 반환, 예외로 처리되지 않은 경우 잘못된 값으로 문제 발생   모든 함수의 반환값이 의도대로 출력되는지 확인하고, 세분화된 예외처리를 수행하여 방지       6. 코드 오류 – B   - 코드 오류의 개요      개발자들이 코딩 중 실수하기 쉬운 형변환, 자원 반환 등의 오류를 예방   - 널 포인터 역참조      널 포인터가 가리키는 메모리에 어떠한 값을 저장할 때 발생하는 보안 약점   함수들이 오류 발생 시 널 값을 반환하는데, 이 반환값을 포인터로 참조하는 경우 발생   널 포인터는 메모리의 첫 주소를 가리키며, 이를 참조할 경우 비정상적으로 종료될 수 있음   공격자가 널 포인터 역참조로 발생하는 예외 상황을 악용할 수 있음   널이 될 수 있는 포인터를 이용하기 전에 널 값을 갖고 있는지 검사하여 방지   - 부적절한 자원 해제      자원을 반환하는 코드를 누락하거나 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점   힙 메모리, 소켓 등의 유한한 시스템 자원이 계속 점유하고 있으면 자원 부족으로 인해 새로운 입력을 처리하지 못 할 수 있음   자원 반환 코드가 누락되었는지 확인   오류로 인해 함수가 중간에 종료되었을 때 예외처리에 관계없이 자원이 반환되도록 코딩   - 해제된 자원 사용      이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생   반환된 메모리를 참조하는 경우 예상하지 못한 값 또는 코드를 수행하게 되어 의도하지 않은 결과가 발생할 수 있음   반환된 메모리에 접근할 수 없도록 주소를 저장하고 있는 포인터를 초기화함으로써 방지   - 초기화되지 않은 변수 사용      변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점   변수가 선언되어 메모리가 할당되면 해당 메모리에 이전에 사용하던 내용이 계속 남아있어 변수가 외부에 노출되는 경우 중요정보가 악용될 수 있음   변수 선언 시 할당된 메모리를 초기화함으로써 방지       7. 암호 알고리즘 – A   - 암호 알고리즘의 개요      중요정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법   해시를 사용하는 단방향 암호화 방식, 개인키 및 공개키로 분류되는 양방향 암호화 방식        암호화 방식         양방향              개인키                  Stream 방식 : LFSR, RC4  Block 방식 : DES, SEED, AES, ARIA                           암호화 방식         양방향              공개키                    암호화 방식         단방향              HASH            - 개인키 암호화 기법      동일한 키로 데이터를 암호화하고 복호화   대칭 암호 기법, 단일키 암호화 기법   한 번에 하나의 데이터 블록을 암호화. 블록 암호화 방식   평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화. 스트림 암호화 방식   장점 : 암호화/복호화 속도 빠름. 알고리즘 단순. 파일 크기가 작음   단점 : 사용자의 증가에 따라 관리해야 할 키의 수가 상대적으로 많아짐   - 공개키 암호화 기법      암호화할 때 공개키는 DB 사용자에게 공개   복호화할 때 비밀키는 관리자가 비밀리에 관리   비대칭 암호 기법. 대표적으로 RSA   장점 : 키의 분배가 용이, 관리해야 할 키의 개수가 적음   단점 : 암호화/복호화 속도 느림. 알고리즘 복잡. 파일의 크기가 큼   X.509 방식, 비X.509 방식   - 양방향 알고리즘 종류      SEED : 블록 크기 128비트, 키 길이에 따라 128, 256   ARIA : 블록 크기 128비트, 키 길이에 따라 128, 192, 256   DES : 블록 크기 64비트, 키 길이는 56비트   AES : 블록 크기는 128비트, 키 길에 따라 128, 192, 256   RSA : 공개키 암호화 알고리. 큰 숫자를 소인수분해 하기 어렵다는 것에 기반   - 해시      임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것   데이터의 암호화, 무결성 검증. 정보보호의 다양한 분야에서 활용   SHA 시리즈, MD5, N-NASH, SNEFRU 등  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp20/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 5-4. 시스템 보안 구축",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 일부 제외   1. 서비스 공격 유형 – A   - 서비스 거부(DoS) 공격의 개념      서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송하여, 표적이 되는 서버의 정상적인 기능을 방해   - Ping of Death      Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 고역 대상의 네트워크를 마비시킴   분할되어 전송된 패킷을 재조립해야 하는 부담과 분할되어 전송된 각각의 패킷들의 CIMP Ping 메시지에 대한 응답을 처리하느라 시스템이 다운되게 됨   jolt, sPING, ICMP bug, IceNewk 등의 변종 공격에 대비하여 ICMP Ping 메시지가 전송되지 못하도록 방화벽에서 차단하는 기술 개발   - SMURFING(스머핑)      대량의 데이터를 한 사이트에 집중적으로 보내 네트워크를 불능 상태로 만드는 공격   송신 주소를 공격 대상지의 IP 주소로 위장하고 해당 네트워크 라우터의 브로드캐스트 주소를 수신지로 하여 패킷을 전송하면, 라우터의 브로드캐스트 주소로 수신된 패킷은 해당 네트워크 내의 모든 컴퓨터로 전송   각 네트워크 라우터에서 브로드캐스트 주소를 사용할 수 없게 미리 설정   - SYN Flooding      가상의 클라이언트로 위장하여 3-way-handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법   SYN 수신 대기 시간을 줄이거나 침입 차단 시스템을 활용   - TearDrop      패킷의 크기가 커 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데, 이 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부하를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법   Fragment Offset이 잘못된 경우 해당 패킷을 폐기하도록 설정   - Land      패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상에게 전송하는 것으로, 패킷을 받은 공격 대상은 송신 IP 주소가 자신이므로 자신에게 응답을 수행하는데, 이러한 패킷이 계속해서 전송될 경우 자신에 대해 무한히 응답   송신 IP 주소와 수신 IP 주소의 적절성을 검사   - DDoS(분산 서비스 거부) 공격      분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행   분산 서비스 공격용 툴을 설치하여 에이전트로 만든 후 공격에 이용   다수의 에이전트를 관리할 수 있는 핸들러 프로그램을 설치하여 마스터로 지정   분산 서비스 공격용 툴            Trin00 : 초기형태, UDP Flooding       TFN : UDP Flooding, TCP SYN Flood 공격, ICMP 응답 요청, 스머핑       TFN2K : TFN의 확장판       Stacheldraht : 공격자가 노출되지 않도록 암호화된 통신 수행, 툴 자동 업데이트           - 네트워크 침해 공격 관련 용어      스미싱(Smishing)            문자 메시지를 이용해 사용자의 개인 신용 정보를 빼내는 수법       개인 비밀정보나 소액 결제를 유도하는 형태       행사, 경품 등의 문자 메시지에 링크를 걸어 apk 파일을 설치하도록 유도           스피어 피싱(Spear Phishing)            특정 대상을 선정한 후 일반적인 이메일을 가장하여 메일 지속적으로 발송       발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도해 개인정보 탈취           APT(지능형 지속 위협)            조직적으로 침투해 거점을 마련하고 보안을 무력화시키고 정보를 수집해 외부로 빼돌림       악성코드가 포함된 이메일을 꾸준히 발송해 한번이라도 클릭되길 기다림       악성코드가 담긴 이동식 디스크 등으로 전파       악성코드에 감염된 P2P 사이트에 접속하면 악성코드에 감염되는 형태           무작위 대입 공격            암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격           큐싱(Qshing)            QR코드를 통해 악성 앱의 다운로드를 유도하는 금융사기 기법의 하나           SQL 삽입            DB 등의 데이터를 조작하는 공격방식           크로스 사이트 스크립팅(XSS)            스크립트 취약점을 악용한 해킹 기법           - 정보 보안 침해 공격 관련 용어      좀비PC            악성코드에 감염된 컴퓨터       C&amp;C 서버의 제어를 받아 주로 DDoS 공격 등에 이용           C&amp;C 서버            감염된 좀비 PC에 명령을 내리고 악성코드를 제어하기 위한 용도로 사용되는 서버           봇넷            악성 프로그램에 감염된 컴퓨터들이 네트워크로 연결된 형태           웜            네트워크를 통해 자신을 복제하여 시스템의 부하를 높임       버퍼 오버플로 공격, 슬래퍼 등           제로 데이 공격            공격의 신속성           키로거 공격            키보드 움직임을 탐지해 중요한 정보를 몰래 빼가는 해킹 공격           랜섬웨어            내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램. 금전 요구           백도어            시스템 보안을 제거하여 만들어놓은 비밀 통로. 범죄에 악용           트로이 목마            정상적인 기능을 하는 프로그램으로 위장하여 프로그램이 동작할 때 부작용 발생       자기복제 능력은 없음               2. 서버 인증 – B   - 보안 서버의 개념      인터넷을 통해 개인정보를 암호화하여 송수신할 수 있는 기능을 갖춘 서버   서버에 SSL 인증서를 설치하여 전송 정보를 암호화하여 송수신하는 기능   암호화 응용 프로그램을 설치하고 전송 정보를 암호화하여 송수시하는 기능   스니핑 이용한 정보 유출, 피싱을 이용한 위조 사이트에 대비 위해 보안 서버 구축 필요   - 인증의 개념      로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차   인증의 주요 유형            지식 기반 인증       소유 기반 인증       생체 기반 인증       위치 기반 인증           - 지식 기반 인증      사용자가 기억하고 있는 정보를 기반으로 인증을 수행   사용자의 기억을 기반으로 하므로 관리 비용이 저렴   사용자가 인증 저오를 기억하지 못하면 본인이라도 인증 받지 못함   고정된 패스워드, 패스 프레이즈, 아이핀   - 소유 기반 인증      사용자가 소유하고 있는 것을 기반으로 인증을 수행   소유물이 쉽게 도용될 수 있어 지식 기반 인증이나 생체 기반 인증과 함께 사용됨   신분증, 메모리 카드, 스마트 카드, OTP   - 생체 기반 인증      사용자의 고유한 생체 정보를 기반으로 인증   사용이 쉽고 도난의 위험도 적으며 위조가 어려움   지문, 홍채/망막, 얼굴, 음성, 정맥 등   - 기타 인증 기법      행위 기반 인증            사용자의 행동 정보를 이용해 인증 수행       서명, 동작           위치 기반 인증            인증을 시도하는 위치의 적절성 확인       콜백, GPS, IP주소               3. 보안 솔루션 – A   - 보안 솔루션의 개념      접근 통제, 침입 차단 등을 수행하여 불법적인 침입을 막는 기술 및 시스템   - 방화벽(Firewall)      네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용, 거부, 수정하는 기능을 가진 침입 차단 시스템   내부에서 외부 네트워크로 나가는 패킷은 그대로 통과   외부에서 내부 네트워크로 들어오는 패킷은 엄밀히 체크하여 인증된 패킷만 통과   외부로의 정보 유출을 막기 위해 사용   - 침입 탐지 시스템(IDS; Intrusion Detection System)      컴퓨터 시스템의 비정상적인 사용 등을 실시간으로 탐지   내부 사용자의 불법적인 행동과 외부 해킹에 완벽하게 대처할 수 없음   해커 침입 패턴에 대한 추적과 유해 정보 감시 필요   오용 탐지            미리 입력해 둔 공격 패턴이 감지되면 이를 알려줌           이상 탐지            평소를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 알려줌           침입 탐지 시스템의 위치            패킷이 라우터로 들어오기 전 : 네트워크에 시도되는 모든 공격 탐지       라우터 뒤 : 라우터에 의해 패킷 필터링을 통과한 공격을 탐지       방화벽 뒤 : 내부에서 외부로 향하는 공격을 탐지할 수 있음           내부 네트워크            내부에서 내부 네트워크의 해킹 공격을 탐지할 수 있음           DMZ            외부 공격이나 내부 공격으로부터 중요 데이터를 보호하거나 서버의 서비스르 중단을 방지 할 수 있음           - 침입 방지 시스템(IPS; Intrusion Prevention System)      방화벽 + IDS   비정상적인 트래픽을 능동적으로 차단하고 격리   비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단   - 데이터 유출 방지(DLP; Data Leakage/Loss Prevention)      내부 정보의 외부 유출을 방지하는 보안 솔루션   사용자 행위를 탐지, 통제해 외부로의 유출을 사전에 막음   - 웹 방화벽(Web Firewall)      일반 방화벽이 탐지하지 못하는 SQL 삽입 공격, XSS 등의 웹 기반 공격을 방어   - VPN(가상 사설 통신망)      사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션   비용 부담을 줄일 뿐만 아니라 지역적인 제한 없이 업무 수행 가능   - NAC(Network Access Control)      네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일괄된 보안 관리 기능을 제공하는 보안 솔루션   내부 PC의 S/W 사용 현황을 관리하여 불법적인 S/W 설치 방지   일괄적인 배포 관리 기능을 이용해 백신이나 보안 패치 등의 설치 및 업그레이드 수행   비인가된 시스템을 자동으로 검출하여 자산을 관리   - ESM(Enterprise Security Management)      다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 보안 솔루션   비용 및 자원 절약   종합적인 보안 관리 체계 수립  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp21/",
        "teaser": null
      },{
        "title": "[Git & Github] Merge & Conflict",
        "excerpt":"1. Merge &amp; Conflict      2개의 branch를 통합하는 것   현재의 branch와 merge하고자 하는 branch에서 같은 위치의 코드를 수정했을 경우 conflict 발생   conflict가 발생했을 경우 상의하여 코드 수정       2. 명령어   # 현재 branch에서 merge $ git merge 이름  # merge할 때, commit 이력을 제거하고 수정된 내용만 merge $ git merge --squash 이름  # fast-forward 방식으로 merge할 때, commit message 생성 $ git merge --no-ff 이름       3. Fast-Forward merge   - master branch에서 작업   &lt;!-- master branch --&gt; &lt;body&gt;   &lt;h1&gt;abc&lt;/h1&gt; &lt;/body&gt;   $ git add . $ git commit -m \"commit message abc\"       - 새로운 branch에서 작업   &lt;!-- xyz branch --&gt; &lt;body&gt;   &lt;h1&gt;abc&lt;/h1&gt;   &lt;h2&gt;xyz&lt;/h2&gt; &lt;/body&gt;   $ git checkout -b xyz $ git add . $ git commit -m \"commit message xyz\"       - master branch에서 xyz branch merge 수행   $ git checkout master $ git merge xyz      master branch의 HEAD가 xyz branch의 HEAD로 이동함   master branch의 commit message와 파일 내용이 xyz에서 작성한 내용을 포함       4. Conflict가 발생하는 merge   - master branch에서 작업   &lt;!-- master branch --&gt; &lt;body&gt;   &lt;h1&gt;abcd&lt;/h1&gt;   &lt;h2&gt;xyz&lt;/h2&gt; &lt;/body&gt;   $ git add . $ git commit -m \"commit message abcd\"       - 새로운 branch에서 작업   &lt;!-- xyz branch --&gt; &lt;body&gt;   &lt;h1&gt;abcdefg&lt;/h1&gt;   &lt;h2&gt;xyz&lt;/h2&gt; &lt;/body&gt;   $ git checkout xyz $ git add . $ git commit -m \"commit message abcdefg\"       - master branch에서 xyz branch merge 수행   $ git checkout master $ git merge xyz   &lt;&lt;&lt;&lt;&lt;&lt; HEAD   &lt;h1&gt;abcd&lt;/h1&gt; =======   &lt;h1&gt;abcdefg&lt;/h1&gt; &gt;&gt;&gt;&gt;&gt;&gt; xyz      master branch와 xyz branch의 commit 수가 같아 fast-forward 방식으로 merge 안됨   h1 태그의 내용을 동시에 각각 다른 값으로 수정함   conflict가 발생한 부분을 상호 협의를 거쳐 비교한 후 수정해야 함  ","categories": ["Git"],
        "tags": ["Github","Git"],
        "url": "/git/etc-git-mergeconflict/",
        "teaser": null
      },{
        "title": "[Node.js] NVM, Node.js, NPM",
        "excerpt":"1. Node.js      Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임   JavaScript가 동작할 수 있는 컴퓨터 환경   - Node.js 사용 이유      웹 페이지에서는 html, css, js만 동작   순수하게 html, css, js만 가지고 개발하면 그 과정이 비효율적   따라서 개발을 도와주는 모듈의 도움을 받아야 함   모듈들은 브라우저에서 직접적으로 동작할 수 없음   따라서 모듈의 도움을 받은 내용들을 html, css, js로 변환해야 함   변환을 위해 컴퓨터에게 변환작업에 대한 명령을 내려주어야 함   Node.js가 명령이 돌아가는 환경을 제공   Node.js 환경에서 js 프로그래밍 언어로 변환을 만들어 줄 수 있음   변환된 결과는 html, cs, js로 결과를 만들어 브라우저로 동작시킴       2. 단일 버전의 Node.js 설치 방법   아래의 링크를 통해 설치할 수 있음   https://nodejs.org/ko/      LTS(짝수 Version)            장기적으로 안정되고 신뢰도가 높은 지원이 보장       유지/보수와 보안(서버 운영 등)에 초점을 맞춤       대부분의 사용자에게 추천되는 버전           현재 버전(홀수 Version)            가장 최신의 버전           다른 Node.js 버전에서도 개발을 진행해야 할 수 있음   단일 버전의 Node.js 설치보다 NVM 우선 설치 권장!       3. NVM 설치   구글에 nvm-window를 검색하고 해당 Github 페이지에 접속한 뒤 nvm-setup.zip 파일을 설치       혹은 아래의 링크를 통해 설치   https://github.com/coreybutler/nvm-windows       4. 원하는 버전의 Node.js 설치   VS Code 환경   # nvm을 통해 설치되어 있는 node.js 버전 리스트 $ nvm ls  # 설치하고자 하는 node.js 버전 $ nvm install 14.17.3 $ nvm install 12.22.3  # 사용하고자 하는 node.js 버전 $ nvm use 14.17.3  # 현재 사용되고 있는 node.js 버전 $ node --version  # 삭제하고자 하는 node.js 버전 $ nvm uninstall 12.22.3  # nvm 명령어 모음, 설명 $ nvm --help       5. NPM 설치      NPM은 전 세계의 개발자들이 만든 다양한 패키지와 모듈들을 관리   최신의 웹 프론트앤드 개발에서는 기능들을 프로젝트에 직접적으로 설치해서 별도의 가공처리를 거치고, 가공된 결과물을 웹 사이트로 동작시킴   Node.js를 설치하면 NPM이 자동으로 설치됨   $ npm --version       6. NPM을 통한 Package 설치   # package.json 파일 생성 $ npm init -y  # parcel-bundler 패키지 설치(-D : 개발 의존성 패키지 설치) $ npm install -D parcel-bundler # or $ npm install parcel-bundler -D  # lodash 패키지 설치(일반 의존성 설치) $ npm install lodash  # lodash 패키지 정보 확인 $ npm info lodash  # lodash 원하는 버전으로 설치 $ npm install lodash@4.17.20  # lodash 패키지 업데이트 $ npm update lodash  # 패키지를 삭제하더라도 내역에 있는 패키지 설치 가능 $ npm install # or $ npm i       - package.json      name : 프로젝트 이름   version : 프로젝트 버전   description : 프로젝트 설명   main : npm 생태계에 업로드 할 때 필요한 옵션   scripts : 프로젝트 내부에서 사용할 수 있는 script 명령들을 명시   keywords : 프로젝트와 관련된 키워드   author : 프로젝트 소유주   license : 프로젝트 라이선스   ","categories": ["Javascript"],
        "tags": ["Javascript","Node.js","NVM","NPM","Web"],
        "url": "/javascript/frontend-javascript-nvmnpm/",
        "teaser": null
      },{
        "title": "[Node.js] Parcel-Bundler, lodash",
        "excerpt":"1. Parcel-Bundler      open with live server는 원시적인 방법으로 동작   최신의 웹 frontend 개발에서는 잘 쓰이지 않음   dependencies : 사용하는 여러가지 패키지들이 명시   devDependencies : 우리가 설치한 패키지들이 명시   개발, 관리, 제품화 목적   - parcel 명령어 등록      터미널에서 parcel 명령어가 동작하지 않음   package.json 파일의 scripts 부분에서 “dev”: “parcel index.html” 작성   터미널에서 parcel이라는 명령어가 현재 프로젝트에서만 동작할 수 있음   로컬 환경에서 개발용으로 서버를 열기 위함   $ parcel index.html       - 개발서버 열기   $ npm run dev      npm 명령어를 통해 scripts 부분을 실행   dev는 development의 약어로, 로컬 환경에서 개발서버를 열겠다는 뜻   - build 명령어 등록      package.json 파일의 scripts 부분에서 “build”: “parcel build index.html” 작성   실제로 사용자들이 보는 용도의 결과물이 출력   - 빌드서버 열기   $ npm run build      프로젝트 구조에서 dist 폴더 생성   들여쓰기 같은 띄어쓰기도 다 용량이기 때문에, 전부 제거해서 압축된 형식으로 만들어 줌   코드 난독화            작성된 코드를 읽기 어렵게 만드는 작업       빌드된 결과(제품)는 브라우저에서 해석되는 용도로, 용량을 축소하기 읽기 어렵게 만드는 등의 최적화를 거치는 것이 좋음           Bundle : 프로젝트 개발에 사용한 여러 모듈(패키지)을 하나로 묶어내는 작업       2. lodash   - lodash 패키기 가져오기   import _ from 'lodash'      lodash를 node_modules 디렉토리에서 import   즉 lodash라는 패키지의 package.json 파일에 main 옵션에 명시되어있는 lodash.js 파일을 실제로 가져와서 프로젝트의 js 파일에서 활용됨   “_” 라는 변수에 할당해서 사용   - lodash 메서드   import _ from 'lodash'  // _.camelCase() -&gt; 문자열을 CamelCase 방식으로 출력 console.log(_.camelCase('hello world'));  // helloWorld   // _.uniqBy(배열, 속성) -&gt; 합쳐진 배열의 중복값을 제거한 배열 반환 const usersA = {   { userId: '1', name: 'LWW' },   { userId: '2', name: 'Kim' } }  const userB = {   { userId: '1', name: 'LWW'},   { userId: '3', name: 'Park'}, }  // .concat()은 중복 발생! const usersC = usersA.concat(usersB) console.log('concat', usersC) // concat                               // 0: {userId: \"1\", name: \"LWW\"}                               // 1: {userId: \"2\", name: \"Kim\"}                               // 2: {userId: \"1\", name: \"LWW\"}                               // 3: {userId: \"3\", name: \"Park\"} console.log('uniqBy', _.uniqBy(usersC, 'userId')) // uniqBy                                                   // 0: {userId: \"1\", name: \"LWW\"}                                                   // 1: {userId: \"2\", name: \"Kim\"}                                                   // 2: {userId: \"3\", name: \"Park\"}   // _.unionBy(배열1, 배열2, 속성) -&gt; 합치기 전 배열을 합쳐 중복값을 제거한 배열 반환 const usersD = _.unionBy(usersA, usersB, 'userId') console.log('unionBy', usersD)  // unionBy                                 // 0: {userId: \"1\", name: \"LWW\"}                                 // 1: {userId: \"2\", name: \"Kim\"}                                 // 2: {userId: \"3\", name: \"Park\"}   // _.find() -&gt; 해당 객체를 찾음 const users = {   { userId: '1', name: 'LWW' },   { userId: '2', name: 'Kim' },   { userId: '3', name: 'Park' },   { userId: '4', name: 'Choi' },   { userId: '5', name: 'Jang' } }  const foundUser = _.find(users, { name: 'Park' }) console.log(foundUser)  // {userId: \"3\", name: \"Park\"}   // _.findIndex() -&gt; 해당 객체의 index 번호 반환 const foundUserIndex = _.findIndex(users, { name: 'Park' }) console.log(foundUserIndex)  // 2   // _.remove() -&gt; 해당 객체를 삭제 _.remove(users, { name: 'LWW' }) console.log(users)  // 0: { userId: \"2\", name: \"Kim\" }                     // 1: { userId: \"3\", name: \"Park\" }                     // 2: { userId: \"4\", name: \"Choi\" }                     // 3: { userId: \"5\", name: \"Jang\" }  ","categories": ["Javascript"],
        "tags": ["Javascript","Node.js","NPM","Parcel","Lodash","Web"],
        "url": "/javascript/frontend-javascript-parcelodash/",
        "teaser": null
      },{
        "title": "[Javascript] ECMA, Data type 확인",
        "excerpt":"1. ECMA      Javascript를 표준화 해주는 국제 표준화 기구   ES2015(ES6) 때 Javascript의 전성기가 시작됨   Internet explorer 같은 구버전의 브라우저는 ES5버전 이하만 지원   바벨같은 플러그인의 도움을 받으면 ES6버전 이후의 최신 버전 기술들을 구형 브라우저에서도 동작할 수 있는 ES5버전대의 Javascript 문법으로 변환시켜 줄 수 있음       2. 연습용 프로젝트 초기화   npm init -y npm i parcel-bundler -D # scripts에 \"dev\": \"parcel index.html\" # scripts에 \"build\": \"parcel build index.html\" npm run dev       3. Data Type 확인   typeof : 특정한 데이터의 타입을 알아낼 수 있음   console.log(typeof 'Hello World!');  // string console.log(typeof 123);  // number console.log(typeof true);  // boolean console.log(typeof undefined);  // undefined console.log(typeof null);  // object console.log(typeof {});  // object console.log(typeof []);  // object   데이터 타입을 확인할 때 typeof 키워드로는 객체데이터, 배열데이터를 확인할 수 없음   function getType(data) {   return Object.prototype.toString.call(data) }  console.log(getType(123));  // [object Number] console.log(getType(false));  // [object Boolean]       function getType2(data) {   return Object.prototype.toString.call(data).slice(8, -1); }  console.log(getType(123));  // Number console.log(getType(false));  // Boolean console.log(typeof null);  // Null console.log(typeof {});  // Object console.log(typeof []);  // Array       사용한 함수를 다른 Javascript 파일에서도 사용하기 위해 함수를 사용할 파일에서 import   // 내보내기 할 함수 export default function getType2(data) {   return Object.prototype.toString.call(data).slice(8, -1); }  // 함수를 사용할 파일 import getType2 from './getType'  ","categories": ["Javascript"],
        "tags": ["Javascript","Node.js","NPM","Parcel","Web"],
        "url": "/javascript/frontend-javascript-ecma/",
        "teaser": null
      },{
        "title": "[Javascript] 연산자",
        "excerpt":"1. 산술 연산자   console.log(1 + 2);  // 3 console.log(5 - 7);  // -2 console.log(3 * 4);  // 12 console.log(10 / 2);  // 5 console.log(7 % 5);  // 2       2. 할당 연산자   let a = 2; a += 1;  // a = a + 1 console.log(a);  // 3       3. 비교 연산자   a === b  // 서로 같음 a !== b // 서로 다름 a &lt; b  // a &lt; b a &lt;= b  // a &lt;= b a &gt; b  // a &gt; b a &gt;= b  // a &gt;= b       4. 논리 연산자   a &amp;&amp; b  // a and b a || b  // a or b !a  // not a       5. 삼항 연산자   console.log(a ? '참' : '거짓');  // true면 앞, false면 뒤       6. 동등 연산자      대부분의 경우 비교 연산자 ‘===’ 을 사용   서로 다른 값이 의도하지 않게 ‘같다’라고 출력되는 것을 방지   const a = 1; const b = '1';  console.log(a === b);  // false console.log(a == b);  // true       7. 전개 연산자   // Spread. 쉼표로 구분된 각각의 아이템으로 배열 데이터가 전개되어 만들어짐  const animals = ['Cat', 'Dog', 'Tiger'] console.log(animals)  // (3) ['Cat', 'Dog', 'Tiger'] console.log(...animals)  // Cat Dog Tiger // console.log('Cat', 'Dog', 'Tiger')  function toObject(a, b, c) {   return {     a: a,     b: b,     c: c   } } console.log(toObject(...animals))  // {a: \"Cat\", b: \"Dog\", c: \"Tiger\"} // console.log(toObject(animals[0], animals[1], animals[2]))       // 매개변수에서도 전개 연산자를 사용할 수 있음  const animals = ['Cat', 'Dog', 'Tiger', 'Lion']  // rest parameter ...c가 나머지의 모든 인수들을 다 받아냄 function toObject(a, b, ...c) {   return {     // 속성의 이름과 변수의 이름이 같으면 하나만 남겨둘 수 있음     a,  // a: a,     b,  // b: b,     c   // c: c   } } console.log(toObject(...animals))  // {a: \"Cat\", b: \"Dog\", c: Array(2)}   // function toObject 축약형 const animals = ['Cat', 'Dog', 'Tiger', 'Lion'] const toObject = (a, b, ...c) =&gt; ({a, b, c}) console.log(toObject(...animals))  // {a: \"Cat\", b: \"Dog\", c: Array(2)}  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-operator/",
        "teaser": null
      },{
        "title": "[Javascript] 반복문",
        "excerpt":"반복문 for   // for (시작조건; 종료조건; 변화조건) {}  // ul태그 내부에 li태그 10개 생성하는 예제 const ulEl = document.querySelector('ul');  for (let i = 0; i &lt; 10; i += 1) {   const li = document.createElement('li');      li.textContent = `list-${i + 1}`      // 짝수 번호의 li태그를 클릭하면 문자 출력하는 부분   if ((i+1) % 2 === 0) {         li.addEventListener('click', function () {         console.log(li.textContent);       });   }   ulEl.appendChild(li); }  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-for/",
        "teaser": null
      },{
        "title": "[Javascript] 형 변환",
        "excerpt":"형 변환   - Truthy   // Truthy(참 같은 값) // true, 1, 2, {}, [], 'false', -17 '4.14' ...  if (true) {   console.log(123);  // 123 }  if ('false') {   console.log(123);  // 123 }       - Falsy   // Falsy(거짓 같은 값) // false, null, undefined, 0, '', -0, NaN  if (false) {   console.log(123);  // 출력되지 않음 }  if (undefined) {   console.log(123);  // 출력되지 않음 }  if (0) {   console.log(123);  // 출력되지 않음 }  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-typeconversion/",
        "teaser": null
      },{
        "title": "[Javascript] Prototype",
        "excerpt":"Prototype      객체가 만들어지기 위해 그 객체의 모태가 되는 것   // 생성자로 new라는 키워드와 같이 사용되는 함수를 Parcal case로 작성 function User(first, last) {   this.firstName = first   this.lastName = last }  // 객체가 여러개 생기더라도 getFullName 함수는 메모리에 1번만 만들어짐 // constructor와 __proto__ 속성을 가짐 User.prototype.getFullName = function () {   return `${this.firstName} ${this.lastName}` }  // user : 생성자 함수 // ww, kim, park : 인스턴스 const ww = new User('WW', 'L') const kim = new User('ChulSoo', 'Kim') const park = new User('Younghee', 'Park')  console.log(ww.getFullName())  // WW L console.log(kim.getFullName())  // ChulSoo Kim console.log(park.getFullName())  // Younghee Park  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-prototype/",
        "teaser": null
      },{
        "title": "[Javascript] this",
        "excerpt":"this      일반 함수는 호출 위치에 따라 this 정의   화살표 함수는 자신이 선언된 함수 범위에서 this 정의   const ww = {   name: 'WW',   // 일반 함수   normal: function () {     console.log(this.name)   },   // 화살표 함수   arrow: () =&gt; {     console.log(this.name)   } }  ww.normal()  // WW ww.arrow()  // Undefined       const kim = {   name: 'Kim',   normal: ww.normal,   arrow: ww.arrow }  kim.normal()  // Kim kim.arrow()  // Undefined       function User(name) {   this.name = name } User.prototype.normal = function () {   console.log(this.name) } User.prototype.arrow = () =&gt; {   console.log(this.name) }  const ww = new User('WW')  ww.normal()  // WW ww.arrow()  // undefined          setTimeout나 setInterval 함수를 사용할 때는 콜백으로 일반함수보다 화살표 함수를 쓰는 것이 활용도가 높음   const timer = {   name: 'LWW!!',   timeout: function () {      setTimeout(function () {        console.log(this.name)      }, 2000)   } } timer.timeout()  // 2초 뒤 undefined       const timer = {   name: 'LWW!!',   timeout: function () {      setTimeout(() =&gt; {        console.log(this.name)      }, 2000)   } } timer.timeout()  // 2초 뒤 LWW!!  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-this/",
        "teaser": null
      },{
        "title": "[Javascript] ES6 Classes",
        "excerpt":"1. function 축약      객체 데이터 내부에서 일반함수를 사용할 때 function 축약 가능   const ww = {   name: 'WW',   normal: function () {     console.log(this.name)   } }  // 축약형 const ww = {   name: 'WW',   normal() {     console.log(this.name)   } }       2. ES6 Classes      클래스 만들기 편리함   function User(first, last) {   this.firstName = first   this.lastName = last } User.prototype.getFullName = function () {   return `${this.firstName} ${this.lastName}` }  const ww = new User('WW', 'Lee') const kim = new User('Chulsoo', 'Kim') const park = new User('Younghee', 'Park')  console.log(ww) console.log(kim.getFullName()) console.log(park.getFullName())       class User {   constructor(first, last) {     this.firstName = first     this.lastName = last   }   getFullName() {     return `${this.firstName} ${this.lastName}`   } }       3. 상속(확장)   class Vehicle {   constructor(name, wheel) {     this.name = name     this.wheel = wheel   } }  const myVehicle = new Vehicle('운송수단', 2) console.log(myVehicle)  // 상속(확장) class Bicycle extends Vehicle {   constructor(name, wheel) {     // super : 부모 클래스의 인스턴스를 참조     super(name, wheel)   } }  const myBicycle = new Bicycle('삼천리', 2) const sonsBicycle = new Bicycle('세발', 3) console.log(myBicycle) console.log(sonsBicycle)  class Car extends Vehicle {   constructor(name, wheel, license) {     super(name, wheel)     this.license = license   } }  const myCar = new Car('벤츠', 4, true) console.log(myCar)  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-classes/",
        "teaser": null
      },{
        "title": "[Javascript] 구조 분해 할당",
        "excerpt":"구조 분해 할당      객체 데이터에서 내용을 구조 분해 해서 원하는 속성들만 꺼내서 사용   // 객체 데이터 const user = {   name: 'LWW',   age: 45,   email: 'abcdefg@gmail.com' } const { name = 'abc', age, address = 'Korea' } = user  console.log(`사용자의 이름은 ${name}입니다.`)  // 사용자의 이름은 LWW입니다. console.log(`${name}의 나이는 ${age}세 입니다.`)  // LWW의 나이는 45세 입니다. // LWW의 이메일 주소는 abcdefg@gmail.com입니다. console.log(`${name}의 이메일 주소는 ${user.email}입니다.`)   console.log(address)  // Korea       // 배열 데이터 const animals = ['Cat', 'Dog', 'Tiger'] const [a, b, c, d] = animals console.log(a, b, c, d)  // Cat Dog Tiger undefined  const[, b] = animals console.log(b)  // Dog  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-desass/",
        "teaser": null
      },{
        "title": "[Javascript] 데이터 불변성",
        "excerpt":"데이터 불변성(Immutability)   - 원시 데이터      원시 데이터 : String, Number, Boolean, undefined, null   새로운 원시 데이터를 사용했을 때, 그 데이터가 기존의 메모리 주소에 들어있다면 새로운 메모리에 만드는 것이 아니라 기존에 존재하는 메모리 주소를 바라보도록 만들어 줌   즉 원시 데이터는 새롭게 만들어지지 않고 불변함   let a = 1 let b = 4  // ---------------------------------- // |1: 1     |2: 4    |3: 7    |4:  // ----------------------------------  console.log(a, b, a === b)  // 1 4 false  // 1번 메모리의 주소를 b에게 할당 b = a console.log(a, b, a === b)  // 1 1 true  // a가 3번 메모리 주소를 가리킴 a = 7 console.log(a, b, a === b)  // 7 1 false  // c가 4번 메모리 주소에 들어가지 않고, 1번 메모리 주소 가리킴 let c = 1 console.log(b, c, b === c)  // 1 1 true       - 참조형 데이터      참조형 데이터 : Object, Array, Function   참조형 데이터는 모양이 같아도 같은 데이터가 아닐수도 있음   참조형 데이터는 새로운 값을 만들 때마다 새로운 메모리 주소에 할당   즉 참조형 데이터는 불변하는 개념이 아님(가변)   a라는 변수와 b라는 변수를 구분해서 사용하고 싶다면 복사를 사용   let a = { k: 1 } let b = { k: 1 }  // --------------------------- // |1: {K: 1}     |2: {k: 1}   // ---------------------------  console.log(a, b, a === b)  // {k: 1} {k: 1} false  // --------------------------- // |1: {K: 7}     |2: {k: 1}    // ---------------------------  a.k = 7 b = a console.log(a, b, a === b)  // {K: 7} {k: 7} true  // --------------------------- // |1: {K: 2}     |2: {k: 1}    // ---------------------------  // a와 b가 같은 메모리를 바라보고 있기 때문에 a의 값만 수정해도 // b의 값까지 같이 수정됨 (주의!) a.k = 2 console.log(a, b, a === b)  // {k: 2} {k: 2} true  // --------------------------- // |1: {K: 2}     |2: {k: 1}    // ---------------------------  // b가 가리키는 1번 메모리 주소를 c에 할당 let c = b console.log(a, b, c, a === c)  // {k: 2} {k: 2} {k: 2} true  // --------------------------- // |1: {K: 9}     |2: {k: 1}    // ---------------------------  a.k = 9 console.log(a, b, c, a === c)  // {k: 9} {k: 9} {k: 9} true   결론!  참조형 데이터를 관리할 때, 할당 연산자를 사용하면 의도치 않은 문제를 발생시킬 수 있기 때문에, 의도한 것이 아니라면 복사라는 개념을 통해서 두 변수를 실제 메모리 상에서 분리해 주어야 함  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-immutability/",
        "teaser": null
      },{
        "title": "[Javascript] 얕은 복사, 깊은 복사",
        "excerpt":"1. 얕은 복사(Shallow copy)   const user = {   name: 'LWW',   age: 45,   emails: ['abcdefg@gmail.com'] } const copyUser = user console.log(copyUser === user)  // true  // user 데이터를 수정했는데, copyUser 데이터도 같이 변경됨 user.age = 29 console.log('user', user)  // user {name: \"LWW\", age: 29, emails: Array(1)} console.log('copyUser', copyUser)  // copyUser {name: \"LWW\", age: 29, emails: Array(1)}  user.emails.push('opqrstu@naver.com') console.log(user.emails === copyUser.emails)  // true       const user = {   name: 'LWW',   age: 45,   emails: ['abcdefg@gmail.com'] }  // Object.assign(대상객체, 출처객체) 활용 const copyUser = Object.assign({}, user) console.log(copyUser === user)  // false  user.age = 29 console.log('user', user)  // user {name: \"LWW\", age: 29, emails: Array(1)} console.log('copyUser', copyUser)  // copyUser {name: \"LWW\", age: 45, emails: Array(1)}  user.emails.push('opqrstu@naver.com') console.log(user.emails === copyUser.emails)  // true       const user = {   name: 'LWW',   age: 45,   emails: ['abcdefg@gmail.com'] }  // 전개 연산자 활용 const copyUser = {...user} console.log(copyUser === user)  // false  user.age = 29 console.log('user', user)  // user {name: \"LWW\", age: 29, emails: Array(1)} console.log('copyUser', copyUser)  // copyUser {name: \"LWW\", age: 45, emails: Array(1)}  user.emails.push('opqrstu@naver.com') console.log(user.emails === copyUser.emails)  // true       2. 깊은 복사(Deep copy)      참조 데이터 내부에 또 다른 참조 데이터가 있는 경우 깊은 복사 고려   const user = {   name: 'LWW',   age: 45,   emails: ['abcdefg@gmail.com'] } const copyUser = {...user} console.log(copyUser === user)  // false  user.age = 29 console.log('user', user)  // user {name: \"LWW\", age: 29, emails: Array(1)} console.log('copyUser', copyUser)  // copyUser {name: \"LWW\", age: 45, emails: Array(1)}  // 얕은 복사로는 속의 내용까지 복사되지 않음 user.emails.push('opqrstu@naver.com') console.log(user.emails === copyUser.emails)  // true console.log('user', user)  // user {name: \"LWW\", age: 29, emails: Array(2)} console.log('copyUser', copyUser)  // copyUser {name: \"LWW\", age: 45, emails: Array(2)}          깊은 복사는 javascript로 직접 구현하기 복잡하기 때문에 lodash 패키지 활용   $ npm i lodash $ npm run dev       // lodash 패키지 import import _ from 'lodash'  const user = {   name: 'LWW',   age: 45,   emails: ['abcdefg@gmail.com'] }  // lodash 패키지의 깊은 복사 cloneDeep 메서드 사용 const copyUser = _.cloneDeep(user) console.log(copyUser === user)  // false  user.age = 29 console.log('user', user)  // user {name: \"LWW\", age: 29, emails: Array(1)} console.log('copyUser', copyUser)  // copyUser {name: \"LWW\", age: 45, emails: Array(1)}  user.emails.push('opqrstu@naver.com') console.log(user.emails === copyUser.emails)  // false console.log('user', user)  // user {name: \"LWW\", age: 29, emails: Array(2)} console.log('copyUser', copyUser)  // copyUser {name: \"LWW\", age: 45, emails: Array(1)}          참고   lodash 검색   documentation 버튼 누름   clone 검색       결론!  얕은복사 : Object.assign, 전개 연산자 사용 // 깊은복사 : lodash 패키지 사용  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-copy/",
        "teaser": null
      },{
        "title": "[Javascript] 가져오기, 내보내기",
        "excerpt":"import, export      외부에 있는 다른 javascript 파일을 가지고 올 수 있는 하나의 통로를 가짐   특정 내용을 밖으로 내보낼 수 있는 2가지 통로를 가짐(Default export, Named export)   // getType.js  (default) export default function (data) {  // default는 함수의 이름을 지정하지 않아도 됨   return Object.prototype.toString.call(data).slice(8, 11) }  // default는 하나의 파일에서 하나의 데이터만 내보낼 수 있음 export default 123  // Only one default export allowed per module.       // getRandom.js  (이름 지정) export function random() {   return Math.floor(Math.random() * 10) }  // 이름만 지정되어 있으면 여러개의 데이터를 내보낼 수 있음 export const user = {   name: 'LWW',   age: 45 }  // Named export와 Default export 같이 사용 가능 export default 123         // main.js import _ from 'lodash'  // From `node_modules` import checkType from './getType'  // getType.js // 이름이 지정된 통로로 나오는 데이터는 데이터를 {}로 묶어서 사용! import { random, user as lww} from './getRandom'  // getRandom.js  console.log(_.camelCase('the hello world'))  // theHelloWorld console.log(checkType([1, 2, 3]))  // Array console.log(random(), random())  // 0~9 랜덤값 0~9 랜덤값 console.log(lww)  // {name: \"LWW\", age: 45}   // 한번에 가져오기 (와일드카드 * 사용) import * as R from './getRandom'  console.log(R)  // {user: {...}, default: 123, __esModule: true, random: f}  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web"],
        "url": "/javascript/frontend-javascript-importexport/",
        "teaser": null
      },{
        "title": "[Javascript] Json",
        "excerpt":"Json      Javascript의 데이터를 표현하는 하나의 포맷   속성-값 쌍   AJAX 통신을 위해, XML을 대체하는 주요 데이터 포맷   - 자료형      Number   String(큰따옴표만 허용)   Boolean   Array   Object   null   - 문법   //myData.json  {   \"string\": \"LWW\",   \"number\": 123,   \"boolean\": true,   \"null\": null,   \"object\": {},   \"array\": []   // \"undefined\": undefined -&gt; 에러 }       // main.js  import myData from './myData.json'  console.log(myData)  // {string: \"LWW\", number: 123, boolean: true, ...}  const user = {   name: 'LWW',   age: 45,   emails: [     'abcdefg@gmail.com',     'opqrstu@naver.com'   ],   // javascript에서 속성 이름을 따옴표로 묶어줄 수 있음   // javascript에서 속성 이름에 특수기호가 들어가는 경우 따옴표로 묶어줌   // 'companyName@#^@#*$': {}   // json 문법은 속성을 큰따옴표로 묶어주어야 함 }  console.log('user', user)  // user {name: \"LWW\", age: 45, emails: Array(2)}  // json 파일은 하나의 문자 데이터 // stringify -&gt; 데이터를 문자 데이터화 시킴 const str = JSON.stringify(user) console.log('str', str)  // str {\"name\":\"LWW\",\"age\":45,\"emails\":[abcdefg@...]} console.log(typeof str)  // string  // 실제 javascript 데이터처럼 출력 // parse -&gt; 문자 데이터를 javascript 데이터처럼 변경 const obj = JSON.parse(str) console.log('obj', obj)  // obj {string: \"LWW\", number: 123, boolean: true, ...}  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web","Json"],
        "url": "/javascript/frontend-javascript-json/",
        "teaser": null
      },{
        "title": "[Javascript] Storage",
        "excerpt":"Local Storage   자세한 내용은 local storage mdn 검색      개발자 도구 Application 탭을 통해 확인   데이터가 만료되지 않음 (반영구적)   데이터를 문자 데이터로 저장하는 것을 권고   const user = {   name: 'LWW',   age: 45,   emails: [     'abcdefg@gmail.com',     'opqrstu@naver.com'   ] }  // 문자 데이터로 변환해서 저장해야 함 localStorage.setItem('user', user)  // Key: user, Value: [object Object]  // 문자 데이터로 변환 JSON.stringify('user', JSON.stringify(user))  // Key: user, Value: {\"name\":\"LWW\",\"age\":...} console.log(localStorage.getItem('user'))  // {\"name\":\"LWW\",\"age\":45,\"emails\":[\"abc...]}  // 객체 데이터로 변환 console.log(JSON.parse(localStorage.getItem('user')))  // {name: \"LWW\", age: 45, emails: Array(2)}  // 데이터 삭제 localStorage.removeItem('user')   // 데이터 가져옴 const str = localStorage.getItem('user') const obj = JSON.parse(str)  // 데이터 수정 obj.age = 29 console.log(obj)  // {name: \"LWW\", age: 29, emails: Array(2)}  // 데이터 저장 localStorage.setItem('user', JSON.stringify(obj))  // Key: user, Value: {\"name\":\"LWW\",\"age\":29,...}      위의 방법은 매우 원시적   따라서 Lowdb 사용   lodash 패키지의 기능을 사용해서 Local Storage를 하나의 DB처럼 쉽게 관리해 줄 수 있음  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web","Json","Storage"],
        "url": "/javascript/frontend-javascript-storage/",
        "teaser": null
      },{
        "title": "[Javascript] OMDb API",
        "excerpt":"OMDb API   자세한 내용은 omdb api 검색      Usage 부분의 주소를 복사해 검색창에 붙여넣기   api key를 입력   https://www.omdbapi.com/?apikey=5f6c9466&amp;s=frozen   JSON 포맷의 정보가 출력됨   axios 패키지 설치   $ npm i axios $ npm run dev       // main.js  import axios from 'axios'  function fetchMovies() {   // 해당하는 정보를 가져옴   // http's'로 요청   axios     .get('https://www.omdbapi.com/?apikey=5f6c9466&amp;s=frozen')     .then(res =&gt; {       console.log(res)       const h1El = document.querySelector('h1')       const imgEl = document.querySelector('img')       h1El.textContent = res.data.Search[0].Title  // 제목 출력       imgEl.src = res.data.Search[0].Poster  // 포스터 출력     }) } fetchMovies()  // {data: {...}, status: 200, statusText: \"\", headers: {..} ..}       &lt;!-- 영화 제목과 포스터 사진 출력 --&gt; &lt;body&gt;   &lt;h1&gt;Hello world!&lt;/h1&gt;   &lt;img src=\"\" alt=\"\" width=\"200\" /&gt; &lt;/body&gt;       - Query String      문자를 사용해 어떤 내용을 검색   주소?속성=값&amp;속성=값&amp;속성=값  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web","Json","OMDb"],
        "url": "/javascript/frontend-javascript-omdbapi/",
        "teaser": null
      },{
        "title": "[Javascript] 정규표현식 생성",
        "excerpt":"1. 프로젝트 시작   # terminal  $ npm init -y $ npm i parcel-bundler -D      index.html 파일 생성   main.js 파일 생성   README.md 파일 생성   // package.json  \"scripts\": {   \"dev\": \"parcel index.html\",   \"build\": \"parcel build index.html\" },       # 개발서버 열기  $ npm run dev  # 개발서버가 버전문제로 실행되지 않는다면 다른버전 설치 $ npm i parcel-bundler@버전 -D       &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;meta charset=\"UTF-8\"&gt;   &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;   &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;   &lt;title&gt;Document&lt;/title&gt;   &lt;script src=\"./main.js\"&gt;&lt;/script&gt; &lt;/head&gt;  &lt;body&gt;   &lt;h1&gt;Hello RegExp&lt;/h1&gt; &lt;/body&gt;       // main.js  console.log(123)       2. 정규표현식      문자열을 검색하고 대체하는 데 사용 가능한 형식 언어(패턴)   간단한 문자 검색부터 이메일, 패스워드 검사 등의 문자 일치 기능등을 수행   정규표현식 역할            문자 검색(Search)       문자 대체(replace)       문자 추출(extract)           정규표현식 테스트 사이트            https://regex101.com/       https://regexr.com/       https://regexper.com/           - Javascript 정규식 생성   @ 생성자 함수 방식      RegExp 생성자 함수를 호출하여 사용할 수 있음   // new RegExg(표현식) const regexp1 = new RegExp(\"^abc\");  // new RegExg(표현식, 플래그) const regexp2 = new RegExp(\"^abc\", \"gi\");  new RegExp('표현', '옵션') new RegExp('[a-z]', 'gi')       // main.js  const str = ` 010-1234-5678 theabc@gmail.com https://www.omdbapi.com/?apikey=5f6c9466&amp;s=frozen The quick brown fox jumps over the lazy dog. abbcccdddd `  const regexp = new RegExp('the', '') console.log(str.match(regexp))  // [\"the\", index: 15, input: \"\\n010-1234-5678\\ntheabc@...\"]  // 대소문자 구분 -&gt; g 옵션 const regexp = new RegExp('the', 'g') console.log(str.match(regexp)  // (2) [\"the\", \"the\"]  // 대소문자 구분X -&gt; gi 옵션 const regexp = new RegExp('the', 'gi') console.log(str.match(regexp)  // (3) [\"the\", \"The\", \"the\"]       @ Literal 방식   // /표현식/ const regexp1 = /^abc/;  // /표현식/플래그 const regexp2 = /^abc/gi;  /표현/옵션 /[a-z]/gi       const regexp = /the/gi console.log(str.match(regexp)  // (3) [\"the\", \"The\", \"the\"]  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web","Reg"],
        "url": "/javascript/frontend-javascript-regexp/",
        "teaser": null
      },{
        "title": "[Javascript] 정규표현식 메서드, 플래그",
        "excerpt":"1. 정규표현식 메서드                  메서드       문법       설명                       exec       정규식.exec(문자열)       일치하는 하나의 정보(Array) 반환                 test       정규식.test(문자열)       일치 여부(Boolean) 반환                 match       문자열.match(정규식)       일치하는 문자열의 배열(Array) 반환                 search       문자열.search(정규식)       일치하는 문자열의 인덱스(Number) 반환                 replace       문자열.replace(정규식, 대체문자)       일치하는 문자열을 대체하고 문자열(String) 반환                 split       문자열.split(정규식)       일치하는 문자열을 분할하여 배열(Array)로 반환                 toString       생성자_정규식.toString()       생성자 함수 방식의 정규식을 리터럴 방식의 문자열(String)로 반환               const str = ` 010-1234-5678 theabc@gmail.com https://www.omdbapi.com/?apikey=5f6c9466&amp;s=frozen The quick brown fox jumps over the lazy dog. abbcccdddd `  // test const regexp = /fox/gi console.log(regexp.test(str))  // true  const regexp = /LWW/gi console.log(regexp.test(str))  // false  // replace const regexp = /fox/gi console.log(str.replace(regexp, 'AAA'))  // The quick bronw AAA ... console.log(str)  // The quick brown fox ...  let str = ` The quick brown fox jumps over the lazy dog. ` const regexp = /fox/gi str = str.replace(regexp, 'AAA') console.log(str)  // The quick brown AAA ...       2. 정규표현식 플래그(옵션)                  플래그       설명                       g       모든 문자 일치(global)                 i       영어 대소문자를 구분 않고 일치(ignore case)                 m       여러 줄 일치(multi line)           const str = ` 010-1234-5678 theabc@gmail.com https://www.omdbapi.com/?apikey=5f6c9466&amp;s=frozen The quick brown fox jumps over the lazy dog. abbcccdddd ` // 플래그 없음 const regexp = /the/ console.log(str.match(regexp))  // [\"the\", index: 15, input: \"\\n010-1234-5678\\ntheabc@...]  // g const regexp = /the/g console.log(str.match(regexp))  // (2) [\"the\", \"the\"]  // gi const regexp = /the/gi console.log(str.match(regexp))  // (3) [\"the\", \"The\", \"the\"]  console.log(str.match(/the/gi))  // (3) [\"the\", \"The\", \"the\"]  // Escape Character console.log(str.match(/\\./gi))  // (4) [\".\", \".\", \".\", \".\"]  // 끝나는 부분 찾아서 일치시킴 console.log(str.match(/\\.$/gi))  // null  // m console.log(str.match(/\\.$/gim))  // [\".\"]  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web","Reg"],
        "url": "/javascript/frontend-javascript-regmethod/",
        "teaser": null
      },{
        "title": "[Javascript] 정규표현식 패턴",
        "excerpt":"정규표현식 패턴(표현)                  패턴       설명                       ^ab       줄(Line) 시작에 있는 ab와 일치                 ab$       줄(Line) 끝에 있는 ab와 일치                 .       임의의 한 문자와 일치                 a&amp;verbar;b       a 또는 b와 일치                 ab?       b가 없거나 b와 일치                 {n}       n개 연속 일치                 {n,}       n개 이상 연속 일치                 {n,m}       n개 이상 m개 이하 연속 일치                 [abc]       a 또는 b 또는 c                 [a-z]       a부터 z 사이의 문자 구간에 일치(소문자)                 [A-Z]       A부터 Z 사이의 문자 구간에 일치(대문자)                 [0-9]       0부터 9 사이의 문자 구간에 일치(숫자)                 [가-힣]       가부터 힣 사이의 문자 구간에 일치(한글)                 \\w       63개 문자(Word, 대소영문52개 + 숫자10개 + _)에 일치                 \\b       63개 문자에 일치하지 않는 문자 경계(Boundary)                 \\d       숫자(Digit)에 일치                 \\s       공백(Space, Tab 등)에 일치                 (?=)       앞쪽 일치(Lookahead)                 (?&lt;=)       뒤쪽 일치(Lookbehind)           const str = ` 010-1234-5678 theabc@gmail.com https://www.omdbapi.com/?apikey=5f6c9466&amp;s=frozen The quick brown fox jumps over the lazy dog. abbcccdddd http://localhost:1234 동해물과 백두산이 마르고 닳도록 `  // $ -&gt; 줄(Line) 끝에 있는 ab와 일치 console.log(str.match(/d$/g))  // null console.log(str.match(/d$/gm))  // [\"d\"]   // ^ -&gt; 줄(Line) 시작에 있는 ab와 일치 console.log(str.match(/^t/gm))  // [\"t\"] console.log(str.match(/^t/gim))  // [\"t\", \"T\"] console.log(str.match(/^T/gm))  // [\"T\"]   // . -&gt; 임의의 한 문자와 일치 console.log(str.match(/./g))  // (152) [\"0\", \"1\", \"0\", \"-\", \"1\", \"2\", \"3\", \"4\", ...] console.log(str.match(/h..p/g))  // [\"http\", \"http\"]   // | -&gt; a 또는 b와 일치 console.log(str.match(/fox|dog/g))  // [\"fox\", \"dog\"]   // ? -&gt; b가 없거나 b와 일치 console.log(str.match(/https?/g))  // [\"https\", \"http\"]   // {n} -&gt; n개 연속 일치 console.log(str.match(/d{2}/))  // [\"dd\", index: ...] console.log(str.match(/d{2}/g))  // [\"dd\", \"dd\"]   // {n,} -&gt; n개 이상 연속 일치 console.log(str.match(/d{2,}/g))  // [\"dddd\"]   // {n,m} -&gt; n개 이상 m개 이하 연속 일치 console.log(str.match(/\\w{2,3}/g))  // (36) [\"010\", \"123\", \"567\", \"the\", \"abc\", ...] console.log(str.match(/\\b\\w{2,3}\\b/g))  // (8) [\"010\", \"com\", \"www\", \"com\", \"The\", ...]   // [abc] -&gt; a 또는 b 또는 c console.log(str.match(/[fox]/g))  // (12) [\"o\", \"o\", \"o\", \"f\", \"f\", \"o\", \"o\", ..]   // [0-9] -&gt; 0부터 9 사이의 문자 구간에 일치(숫자) console.log(str.match(/[0-9]/g))  // (21) [\"0\", \"1\", \"0\", \"1\", \"2\", \"3\", \"4\", ...] console.log(str.match(/[0-9]{1,}/g))  // (6) [\"010\", \"1234\", \"5678\", ...]   // [가-힣] -&gt; 가부터 힣 사이의 문자 구간에 일치(한글) console.log(str.match(/[가-힣]{1,}/g))  // (4) [\"동해물과\", \"백두산이\", \"마르고\", \"닳도록\"]   // \\w -&gt; 63개 문자(Word, 대소영문52개 + 숫자10개 + _)에 일치 console.log(str.match(/\\w/g))  // [\"0\", \"1\", \"0\", \"1\", \"2\", ...]   // \\b -&gt; 63개 문자에 일치하지 않는 문자 경계(Boundary) console.log(str.match(/\\bf\\w{1,}\\b/g))  // [\"frozen\", \"fox\"]   // \\d -&gt; 숫자(Digit)에 일치 console.log(str.match(/\\d/g))  // [\"0\", \"1\", \"0\", \"1\", \"2\", ...] console.log(str.match(/\\d{1,}/g))  // [\"010\", \"1234\", \"5678\", ...]   // \\s -&gt; 공백(Space, Tab 등)에 일치 console.log(str.match(/\\s/g))  // [\"\\n\", \"\\n\", \"\\n\", \"\\n\", \" \", \" \", ...]  const h = `  the hello  world   !  ` console.log(h.replace(/\\s/g, ''))  // thehelloworld!   // (?=) -&gt; 앞쪽 일치(Lookahead) console.log(h.match(/.{1,}(?=@)/g))  // [\"theabc\"]   // (?&lt;=) -&gt; 뒤쪽 일치(Lookbehind) console.log(h.match(/(?&lt;=@).{1,}/g))  // [\"gmail.com\"]  ","categories": ["Javascript"],
        "tags": ["Javascript","Programming","Web","Reg"],
        "url": "/javascript/frontend-javascript-regpattern/",
        "teaser": null
      },{
        "title": "[정보처리기사 실기] 1. 요구사항 확인",
        "excerpt":"2021 시나공 정보처리기사 실기책 참고   주의! 중요도가 낮은 항목(C, D)은 일부 제외   1. 소프트웨어 생명 주기 – A   - Software Life Cycle      S/W를 개발하기 위한 과정을 각 단계별로 나눈 것   폭포수, 프로토타입, 나선형, 애자일   - 폭포수 모형(Waterfall Model)      각 단계를 확실히 매듭짓고 결과를 검토하여 승인 과정을 거친 후 다음 단계 진행   가장 오래되고 가장 폭넓게 사용된 전통적인 S/W 생명 주기 모형   고전적 생명 주기 모형   모형을 적용한 경험과 성공 사례 많음   다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 함   - 프로토타입 모형(Prototype Model)      실제 개발될 S/W에 대한 견본품을 만들어 최종 결과물을 예측   사용자와 시스템 사이의 인터페이스에 중점   - 나선형 모형(Spiral Model)      여러 번의 S/W 개발 과정을 거쳐 점진적으로 개발   보헴이 제안   폭포수, 프로토타입 + 위험 분석 기능   누락되거나 추가된 요구사항 첨가 가능   유지보수 과정 필요 없음   계획 수립 -&gt; 위험 분석 -&gt; 개발 및 검증 -&gt; 고객 평가   - 애자일 모형(Agile Model)      요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하며 개발   고객과의 소통에 초점   기업 활동 전반에 걸쳐 사용됨   Scrum, XP, Kanban, Lean, FDD   개인과 상호작용에 더 가치를 둠   실행되는 S/W에 더 가치를 둠   고객과 협업에 더 가치를 둠   변화에 반응하는 것에 더 가치를 둠   - 소프트웨어 공학(Software Engineering)      S/W의 위기를 극복하기 위한 방안으로 연구된 학문   S/W의 품질과 생산성 향상이 목적   현대적인 프로그래밍 기술을 계속적으로 적용   품질이 유지되도록 지속적으로 검증   명확한 기록 유지       2. 스크럼(Scrum) 기법 – B      팀이 중심이 되어 개발의 효율성을 높이는 기법   팀원 스스로가 팀을 구성, 개발에 대한 모든 것 스스로 해결   제품 책임자(PO; Product Owner)            요구사항이 담긴 백로그 작성       개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사를 결정할 사람           스크럼 마스터(SM; Scrum Master)            스크럼을 잘 수행할 수 있도록 가이드 역할           개발팀(DT; Development Team)            PO, SM을 제외한 모든 팀원       개발 수행           스프린트 계획 회의 -&gt; 스프린트 -&gt; 일일 스크럼 회의 -&gt; 스프린트 검토 회의 -&gt; 스프린트 회고       3. XP(eXtreme Programming) 기법 – A      요구사항에 유연하게 대응하기 위함   고객의 참여와 개발 과정의 반복을 극대화해 생산성 향상   S/W를 빠르게 개발하는 것이 목적   릴리즈 기간을 짧게 반복하면서 요구사항 반영에 대한 가시성을 높임   의사소통, 단순성, 용기, 존중, 피드백   릴리즈 계획 수립 -&gt; 이터레이션 -&gt; 승인검사 -&gt; 소규모 릴리즈   Pair Programming            다른 사람과 함께 프로그래밍을 수행하여 책임을 공동으로 나눠 갖음           Collective Ownership            코드에 대한 권한과 책임을 공동으로 소요           Test-Driven Development            코드를 작성하기 전에 테스트 케이스를 먼저 작성       자동화된 테스팅 도구 사용           Whole Team            모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가짐           Continuous Integration            모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적 통합           Refactoring            프로그램 기능의 변경 없이 시스템 재구성       프로그램을 쉽게 이해하고 수정하여 빠르게 개발하기 위함           Small Releases            릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응               4. 개발 기술 환경 파악 – B      운영체제(OS; Operating System)            컴퓨터 시스템의 자원을 효율적으로 관리       컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공       사용자와 하드웨어 간의 인터페이스       프로그램이 유용한 작업을 할 수 있도록 환경 제공       가용성, 성능, 기술지원, 주변 기기, 구축 비용           데이터베이스 관리 시스템(DBMS; DataBase Management System)            사용자와 DB 사이에서 정보를 생성, DB 관리       데이터의 종속성과 중복성의 문제를 해결       DB를 공용할 수 있도록 관리       가용성, 성능, 기술 지원, 상호 호환성, 구축 비용           웹 애플리케이션 서버(WAS; Web Application Server)            동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어       데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공       DB 서버와 연동해서 사용       가용성, 성능, 기술 지원, 구축 비용           오픈 소스(Open Source)            제한 없이 사용할 수 있도록 소스 코드를 공개한 S/W       라이선스의 종류, 사용자 수, 기술의 지속 가능성               5. 요구사항 정의 – B      S/W가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명   정상적으로 운영되는데 필요한 제약 조건   기능 요구사항            기능이나 수행과 관련된 요구사항       입력이나 출력으로 무엇이 포함되어야 하는지       어떤 데이터를 저장하거나 연산을 수행해야 하는지       시스템이 반드시 수행해야 하는 기능       사용자가 시스템을 통해 제공받기를 원하는 기능           비기능 요구사항            품질이나 제약사항과 관련된 요구사항       시스템 장비, 성능, 인터페이스, 테스트, 보안, 품질, 제약사항           사용자 요구사항            사용자 관점에서 본 시스템이 제공해야 할 요구사항       친숙한 표현으로 이해하기 쉽게 작성           시스템 요구사항            개발자 관점에서 본 시스템 전체가 제공해야 할 요구사항       전문적이고 기술적인 용어로 표현       소프트웨어 요구사항               6.  ","categories": ["JCKS"],
        "tags": ["JCKS"],
        "url": "/jcks/etc-jcks1/",
        "teaser": null
      },{
        "title": "[Typescript] Typescript란?",
        "excerpt":"1. Typescript란?      Programming Language   Compiled Language            전통적인 Compiled Language와는 다른 점이 많음       Transpile       Javascript는 Interpreted Language           Typescript -&gt; (Typescript Compiler) -&gt; Javascript   타입을 명시적으로 지정할 수 있음   타입을 지정하지 않으면, Typescript 컴파일러가 자동으로 타입을 추론                  Compiled       Interpreted                       컴파일 필요       컴파일 필요 X                 컴파일러 필요       컴파일러 필요 X                 컴파일하는 시점 O       컴파일하는 시점 X                 컴파일된 결과물을 실행       코드를 실행하는 시점 O = 런타임                 컴파일된 결과물을 실행하는 시점       -               2. Typescript 설치   - 글로벌 설치   # 글로벌 설치 $ npm i typescript -g   # 프로젝트 폴더 생성 $ mkdir ts-test   # 프로젝트 폴더로 이동 $ cd ts-test   # 테스트 파일 생성 $ nano test.ts  # console.log('hello')   # 컴파일(test.js 파일 생성) $ tsc test.ts   # 파일 확인 $ cat test.js $ cat test.ts   # 설정파일 디폴트 생성 $ tsc --init   # 파일 수정 시 새로 컴파일  $ tsc -w   # 파일 내용 변경 $ nano test.ts  # console.log('hello typescript')   # 파일 내용 확인 $ cat test.js   # 글로벌 설치 삭제 $ npm uninstall typescript -g   # 프로젝트 폴더 삭제 $ rm -rf ts-test       - 프로젝트에 설치   # 프로젝트 폴더 생성 $ mkdir ts-test   # 프로젝트 폴더로 이동 $ cd ts-test   # npm 프로젝트 시작 $ npm init -y   # typescript 설치 $ npm i typescript -D   # typescript 설치 확인 $ cat package.json  # dependencies 항목에서 typescript 설치 확인   # typescript 컴파일러 설치 확인 $ ls node_modules  # typescript   # tsc 실행 방법1 $ node_modules/.bin/tsc   # tsc 실행 방법2 $ node_modules/typescript/bin/tsc   # tsc 실행 방법3 $ npx tsc   # 설정파일 디폴트 생성 $ npx tsc --init   # 테스트 파일 생성 $ nano test.ts   # 컴파일(test.js 파일 생성) $ npx tsc   # watch 모드 실행 $ npx tsc -w   # script 명시 $ nano package.json  # scripts: {\"build\": \"tsc\", \"build:watch\": \"tsc -w\"}   # tsc 실행 $ npm run build $ npm run build:watch       - VS Code에서 설치   $ npm init -y $ npm i typescript -D  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-typestart/",
        "teaser": null
      },{
        "title": "[Typescript] Typescript Types",
        "excerpt":"1. Type Annotation   // 타입 에러 let a = \"Amy\"; a = 39;  // Error  // a의 타입을 string로 지정 let a: string;  a = \"Amy\"; a = 39;  // Error  // a의 타입을 number로 지정 let a: number;  a = \"Amy\";  // Error a = 39;  // 함수 내의 type annotation function hello(b: number) {    } hello(39); hello('Amy');  // Error       2. Typescript Types vs Javascript Types      Typescript : Static Types(개발 중간에 타입 체크)   Javascript : Dynamic Types(runtime에 들어가야 체크)   // Javascript  function add(n1, n2) {   // runtime에서 에러 체크   if (typeof n1 !== 'number' || typeof n2 !== 'number') {     throw new Error('Incorrect input!');   }   return n1 + n2; }  const result = add(10, 20);       // Typescript  // 개발중에 체크 function add(n1: number, n2: number) {   return n1 + n2; }  const result = add(10, 20);          Typescript에서 제공하는 데이터 타입   Javascript 기본 자료형 포함(superset)            ECMAScript 표준에 따른 기본 자료형(6가지)       Boolean       Number       String       Null       Undefined       Symbol(ECMAScript 6에 추가)       Array: object형           프로그래밍을 도울 몇가지 타입 추가 제공            Any, Void, Never, Unknown       Enum       Tuple: object형               3. Primitive Types      오브젝트와 레퍼런스 형태가 아닌 실제 값을 저장하는 자료형   Primitive 형의 내장 함수를 사용 가능한 것은 Javascript 처리 방식 덕분   Primitive types은 모두 소문자   ES2015 기준 6가지            boolean       number       string       symbol       null       undefined           literal 값으로 Primitive 타입의 서브 타입을 나타낼 수 있음   wrapper 객체로 만들 수 있음   // 내장함수 사용 가능 let name = 'Amy'; name.toString();  // literal 값으로 Primitive 타입의 서브 타입 표시 true; 'hello'; 3.14; null; undefined;  // wrapper 객체(Typescript에서는 권장하지 않음) new Boolean(false);  // typeof new Boolean(false) : 'object' new String('world');  // typeof new String('world') : 'object' new Number(29);  // typeof new Number(29) : 'object'       4. boolean   // boolean.ts  let isDone: boolean = false; isDone = true; console.log(typeof isDone)  // boolean console.log(isDone);  // true  let isOk: Boolean = true; isOk = false; console.log(typeof isOk);  // boolean console.log(isOk);  // false  let isNotOk: boolean = new Boolean(true);  // Error       $ nxp tsc $ node boolean.js  # boolean       5. number      Javascript와 같이 Typescript의 모든 숫자는 부동 소수점 값   10진수 및 16진수 외에도, ECMAScript 2015에 도입된 2진수 및 8진수 지원   NaN   1_000_000과 같은 표기 가능   // number.ts  // 10진수 리터럴 let decimal: number = 7;  // 16진수 리터럴 let hex: number = 0xf00e;  // 2진수 리터럴 let binary: number = 0b1100;  // 8진수 리터럴 let octal: number = 0o732;  // NaN let notANumber: number = NaN;  // 밑줄 표기 let underscoreNum: number = 1_000_000;       6. string      텍스트 형식을 참조하기 위해 string 형식을 사용   문자열 데이터를 둘러싸기 위해 큰 따옴표나 작은 따옴표를 사용   // string.ts  let myName: string = 'Lee'; myName = \"LWW\";       - Template String      행에 걸쳐 있거나, 표현식을 넣을 수 있는 문자열   이 문자열은 backtick 기호에 둘러쌓여 있음   포함된 표현식은 `${expr}` 와 같은 형태로 사용   // template string 사용 let fullName: string = 'WW Lee'; let age: number = 29; let sentence: string = `Hello, My name is ${fullName}.  I'll be ${age + 1} years old next month.`;  console.log(sentence);  // Hello, My name is WW Lee.                          // I'll be 30 years old next month.  // template string을 사용하지 않을 경우 let sentence: string = \"Hello, My name is \" + fullName + \".\\n\\n\" +   \"I'll be \" + (age + 1) + \" years old next month.\";       $ nxp tsc $ node string.js       7. Symbol      ECMAScript 2015에 추가   new Symbol로 사용할 수 없음   Symbol을 함수로 사용해서 symbol 타입을 만들 수 있음   Primitive type의 값을 담아서 사용   고유하고 수정 불가능한 값으로 만들어 줌   주로 접근을 제어하는데 쓰는 경우가 많음   // tsconfig.json  \"lib\": [   \"ES2015\",   \"DOM\" ]       // symbol.ts  console.log(Symbol('foo') === Symbol('foo'))  // false  const sym = Symbol(); const obj = {   [sym]: \"value\", };  obj[\"sym\"];  // 접근 불가 obj[sym];       $ nxp tsc $ node symbol.js       8. null &amp; undefined      Typescript에서 null과 undefined는 실제로 각각 null과 undefined 타입을 가짐   void와 마찬가지로, 그 자체로는 그다지 유용하지 않음   둘 다 소문자만 존재   다른 모든 타입의 서브타입으로 존재   컴파일 옵션에서 `–strictNullChecks` 사용하면, void나 자기 자신에만 할당 가능            이 경우, null과 undefined를 할당할 수 있게 하려면, union type을 이용해야 함           // null.ts  let MyName: string = null;  // Error let u: undefined = null;  // Error  let v: void = undefined; let union: string | null = null; union = \"LWW\";       - null in Javascript      null이라는 값으로 할당된 것   무언가 있는데, 사용할 준비가 덜 된 상태   null 타입은 null 값만 가질 수 있음   런타임에서 typeof 연산자를 이용해 알아내면, object   - undefined in Javascript      값을 할당하지 않은 변수는 undefined 값을 가짐   무언가가 아예 준비가 안된 상태   object의 property가 없을 때도 undefined   런타임에서 typeof 연산자를 이용해 알아내면, undefined       9. object      Primitive type이 아닌 것을 나타내고 싶을 때 사용하는 타입   Primitive type이 아닌것            number, string, boolean, bigint, symbol, null, undefined가 아닌 것           // object.ts  // person1은 object 타입이 아님 // person1은 {name: string, age: number} 타입 const person1 = {   name: 'LWW',   age: 29 };  // object 타입 const person2 = Object.create({   name: 'LWW',   age: 29 });  let obj: object = {}; obj = {name: 'LWW'}; obj = [{name: 'LWW'}]; obj = 29;  // Error obj = 'LWW';  // Error obj = true;  // Error obj = 100n;  // Error obj = Symbol();  // Error obj = null;  // Error obj = undefined  // Error  declare function create(o: object | null): void; create({prop: 0}); create(null); create(42);  // Error create(\"string\");  // Error create(false);  // Error create(undefined);  // Error  Object.create(0);  // Error       10. Array      원래 Javascript에서 array는 객체   사용방법            Array       타입[]           // array.ts  // 방법 1(선호) let list1: number[] = [1, 2, 3];  // 방법 2 let list2: Array&lt;number&gt; = [4, 5, 6];  // 여러 타입 let list3: (number | string)[] = [7, 8, 9, \"0\"];       11. Tuple   // tuple.ts  let x: [string, number];  x = ['hello', 29]; x = [10, 'world']  // Error x[3] = 'item';  // Error  const person: [string, number] = [\"LWW\", 29];  // const first: string, const second: number const [first, second] = person;       12. any      어떤 타입이어도 상관없는 타입   any를 써야하는데 쓰지 않으면 오류를 뱉는 컴파일 옵션 nolmplicitAny가 있음   any는 계속해서 개체를 통해 전파됨   모든 편의는 타입 안전성을 잃는 대가로 오는 것   타입 안전성은 Typescript를 사용하는 주요 동기   최대한 쓰지 않는 것을 권장   컴파일 타임에 타입 체크가 정상적으로 이루어지지 않을 수 있음   // any.ts  function returnAny(message: any): any {   console.log(message); }  const any1 = returnAny('리턴은 아무거나'); any1.toString();  // 전파를 통해 안전성을 잃음 let losselyTyped: any = {}; const d = losselyTyped.a.b.c.d;  // any 누수 막는 법 function leakingAny(obj: any) {   // 타입을 지정   const a: number = obj.num;  // const a: number   const b = a + 1;  // const b: number   return b; }  const c = leakingAny({ num: 0 });  // const c: number c.indexOf(\"0\");       13. unknown      응용 프로그램을 작성할 때 모르는 변수의 타입을 묘사해야 할 수 있음   이러한 값은 동적 콘텐츠의 모든 값을 의도적으로 수락하기를 원할 수 있음   컴파일러와 사람에게 이 변수가 무엇이든 될 수 있음을 알려주는 unknwon 타입을 제공   any와 짝으로 any보다 Type-safe한 타입            any와 같이 아무거나 할당 가능       컴파일러가 타입을 추론할 수 있게끔 타입의 유형을 좁힘       타입을 확정해주지 않으면 다른 곳에 할당할 수 없고, 사용 불가           unknown 타입을 사용하면, runtime error를 줄일 수 있음   사용 전에 데이터의 일부 유형의 검사를 수행하야 함을 알리는 API에 사용 가능   // unknown.ts  declare const maybe: unknown; const aNumber: number = maybe;  // Error  if (maybe === true) {   const aBoolean: boolean = maybe;  // const maybe: true   const aString: string = maybe;  // Error }  if (typeof maybe === 'string') {   const aString: string = maybe;  // const maybe: string   const aBoolean: boolean = maybe;  // Error }       14. never      never 타입은 모든 타입의 서브타입이며, 모든 타입에 할당 할 수 있음   never에는 어떤 것도 할당할 수 없음   any조차도 never에 할당할 수 없음   잘못된 타입을 넣는 실수를 막고자 할 때 사용   // never.ts  function error(message: string): never {   throw new Error(message); }  function fail() {   return error('failed'); }  function infiniteLoop(): never {   while (true) { } }  let a: string = 'hello'; if (typeof a !== 'string') {   a;  // let a: never }  declare const b: string | number; if (typeof b !== \"string\") {   b;  // const b: number }  type Indexable&lt;T&gt; = T extends string ? T &amp; { [index: string]: any } : never; type ObjectIndexable = Indexable&lt;{}&gt;;  const b: Indexable&lt;{}&gt; = '';  // Error       15. void      리턴값으로 무엇도 하지 않음을 명시적으로 표현   function returnVoid(message: string): void {   console.log(message);   return undefined; }  const r = returnVoid('리턴이 없음.');  // const r: void  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-type/",
        "teaser": null
      },{
        "title": "[Typescript] 코드 바라보기",
        "excerpt":"1. 작성자와 사용자 관점에서 코드 바라보기      타입이란 해당 변수가 할 수 있는 일을 결정   Javascript는 함수 사용법에 대한 오해를 야기   // Javascript  // f1 이라는 함수의 body에서는 a를 사용 // a가 할 수 있는 일은 a의 타입이 결정 function f1(a) {   return a; }  // ----------------------------------------------------------- // f2 실행의 결과가 NaN을 의도한 것이 아니라면 // 함수의 작성자는 a가 number 타입이라는 가정으로 함수를 작성 function f2(a) {   return a * 20; }  // 사용자는 사용법을 숙지하지 않고, 문자열을 사용해 함수 실행 console.log(f2(10));  // 200 console.log(f2('LWW'));  // NaN          noImplicitAny 옵션을 켜면 타입을 명시적으로 지정하지 않은 경우, Typescript가 추론 중 ‘any’라고 판단하게 되면, 컴파일 에러를 발생시켜 명시적으로 지정하도록 유도   strictNullChecks 옵션을 켜면 모든 타입에 자동으로 포함되어 있는 null과 undefined를 제거   noImplicitReturns 옵션을 켜면 함수 내 모든 코드가 값을 리턴하지 않으면, 컴파일 에러 발생   // Typescript // Typescript의 추론에 의지하는 경우  // a의 타입을 명시적으로 지정하지 않아 a는 any로 추론됨 // 함수의 return 타입은 number로 추론됨 function f3(a) {   return a * 20; }  // 사용자는 a가 any이기 때문에, 사용법에 맞게 문자열을 사용해 함수 실행 console.log(f3(10));  // 200 console.log(f3('LWW') + 10)  // NaN   // ----------------------------------------------------------- // noImplicitAny에 의한 방어 function f3(a) {   return a * 20;  // error TS7006: Parameter 'a' implicitly has an 'any' type }  // 코드를 실행할 수 없음. 컴파일이 정상적으로 마무리 될 수 있도록 수정 필요 console.log(f3(10)); console.log(f3('LWW') + 10)   // ----------------------------------------------------------- // number 타입으로 추론된 return 타입 // 매개변수의 타입은 명시적으로 지정 // 명시적으로 지정하지 않은 함수의 리턴 타입은 number로 추론됨 // noImplicitAny 옵션 킴 function f4(a: number) {   if (a &gt; 0) {     return a * 20;   } }  // 사용자는 사용법에 맞게 number형을 사용하여 함수를 실행 // 함수의 리턴 타입은 number이기 때문에, 타입에 따르면 연산을 바로 할 수 있음 // 하지만 실제 undefined + 5가 실행되어 NaN이 출력 console.log(f4(5));  // 100 console.log(f4(-5) + 5)  // NaN   // ----------------------------------------------------------- // number | undefined 타입으로 추론된 return 타입 // 매개변수의 타입은 명시적으로 지정 // 명시적으로 지정하지 않은 함수의 리턴 타입은 number | undefined로 추론됨 // strictNullChecks 옵션 킴 function f4(a: number) {   if (a &gt; 0) {     return a * 20;   } }  // 사용자는 사용법에 맞게 number형을 사용하여 함수를 실행 // 함수의 리턴 타입은 number | undefined이기 때문에, 타입에 따르면 연산을 바로 할 수 없음 // 컴파일 에러를 고쳐야 하기 때문에 사용자와 작성자가 의논을 해야 함 console.log(f4(5)); console.log(f4(-5) + 5);  // error TS2532: Object is possibly 'undefined'   // ----------------------------------------------------------- // return 타입을 명시적으로 지정 // 매개변수의 타입과 함수의 return 타입을 명시적으로 지정 // 실제 함수 구현부의 return 타입과 명시적으로 지정한 타입이 일치하지 않아 컴파일 에러 발생 function f5(a: number): number {   if (a &gt; 0) {     return a * 20;  // error TS2366: Function lacks ending return statement and ...   } }   // ----------------------------------------------------------- // 모든 코드에서 리턴을 직접해야함 // if가 아닌 경우 return을 직접 하지 않고 코드가 종료됨 // noImplicitReturns 옵션 킴 function f5(a: number) {   if (a &gt; 0) {     return a * 20;  // error TS7030: Not all code paths return a value   } }       // Javascript  // 매개변수에 object가 들어오는 경우 function f6(a) {   return `이름은 ${a.name} 이고, 나이는 ${Math.floor(a.age / 10) * 10}대 입니다.`; }  console.log(f6({name: 'LWW', age: 29}));  // 이름은 LWW 이고, 나이는 20대 입니다. console.log(f6('LWW'));  // 이름은 undefined 이고, 나이는 NaN대 입니다.       // Typescript  // object literal type function f7(a: {name: string, age: number}) : string {   return `이름은 ${a.name} 이고, 나이는 ${Math.floor(a.age / 10) * 10}대 입니다.`; }  console.log(f7({name: 'LWW', age: 29}));  // 이름은 LWW 이고, 나이는 20대 입니다. console.log(f7('LWW'));  // error TS2345: Argument of type 'string' is not assignable ...       2. 나만의 타입을 만드는 방법   // interface interface PersonInterface {   name: string;   age: number; }  // typealias type PersonTypeAlias = {   name: string;   age: number; }  // class function f8(a: PersonInterface): string {   return `이름은 ${a.name} 이고, 나이는 ${Math.floor(a.age / 10) * 10}대 입니다.`; }  console.log(f8({name: 'LWW', age: 29}));  // 이름은 LWW 이고, 나이는 20대 입니다. console.log(f8('LWW'));  // error TS2345: Argument of type 'string' is not assignable ...       3. Structural Type System vs Nominal Type System      Structural Type System : 구조가 같으면, 같은 타입(Typescript)   Nominal Type System : 구조가 같아도 이름이 다르면, 다른 타입(Java)   Duck Typing : 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리면 오리라고 부름(Python)   // Structural Type System // Typescript  interface IPerson {   name: string;   age: number;   speak(): string; }  type PersonType = {   name: string;   age: number;   speak(): string; };  let personInterface: IPerson = {} as any; let personType: PersonType = {} as any;  personInterface = personType; personType = personInterface;       // Nominal Type System // Java  type PersonID = string &amp; { readonly brand: unique symbol }; function PersonID(id: stirng): PersonID {   return id as PersonID; }  function getPersonById(id: PersonID) {}  getPersonById(PersonID('id-abcdefg')); getPersonById('id-abcdefg');  // error TS2345: Argument of type 'string' is not ...       # Duck Typing # Python  class Duck:   def sound(self) :     print u\"꽥꽥\"  class Dog:   def sound(self) :     print u\"멍멍\"  def get_sound(animal) :   animal.sound()  def main() :   bird = Duck()   dog = Dog()   get_sound(bird)   get_sound(dog)  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-codelook/",
        "teaser": null
      },{
        "title": "[Typescript] 타입 호환성, 별칭",
        "excerpt":"1. 타입 호환성(Type Compatibility)      공변 : 같거나 서브 타입인 경우, 할당이 가능   반병 : 함수의 매개변수 타입만 같거나 슈퍼타입인 경우, 할당이 가능   // 서브 타입  // sub1 타입은 sup1 타입의 서브 타입 let sub1: 1 = 1; let sup1: number = sub1; sub1 = sup1;  // error! Type 'number' is not assignable to type '1'   // ---------------------------------------------------------- // sub2 타입은 sup2 타입의 서브 타입 let sub2: number[] = [1]; let sup2: object = sub2; sub2 = sup2;  // error! Type '{}' is missing the following properties from ...    // ---------------------------------------------------------- // sub3 타입은 sup3 타입의 서브 타입 let sub3: [number, number] = [1, 2]; let sup3: number[] = sub3; sub3 = sup3;  // error! Type 'number[]' is not assignable to type '[number, number]'   // ---------------------------------------------------------- // sub4 타입은 sup4 타입의 서브 타입 let sub4: number = 1; let sup4: any = sub4; sub4 = sup4;   // ---------------------------------------------------------- // sub5 타입은 sup5 타입의 서브 타입 let sub5: never = 0 as never; let sup5: number = sub5; sub5 = sup5;  // error! Type 'number' is not assignable to type 'never'   // ---------------------------------------------------------- // sub6 타입은 sup6 타입의 서브 타입 class Animal {} class Dog extends Animal {   eat() {} }  let sub6: Dog = new Dog(); let sup6: Animal = sub6; sub6 = sup6;  // error! Property 'eat' is missing in type 'SubAnimal' but ...       // 공변  // primitive type let sub7: string = ''; let sup7: string | number = sub7;   // ---------------------------------------------------------- // object -&gt; 각각의 프로퍼티가 대응하는 프로퍼티와 같거나 서브타입이어야 함 let sub8: { a: string; b: number } = { a: '', b: 1 }; let sup8: { a: string | number; b: number } = sub8;   // ---------------------------------------------------------- // array -&gt; object와 마찬가지 let sub9: Array&lt;{ a: string; b: number }&gt; = [{ a: '', b: 1 }]; let sup9: Array&lt;{ a: string | number; b: number }&gt; = sub9;       // 반병  class Person {} class Developer extends Person {   coding() {} } class StartupDeveloper extends Developer {   burning() {} }  function tellme(f: (d: Developer) =&gt; Developer) {}  // Developer =&gt; Developer에 Developer =&gt; Developer를 할당하는 경우 tellme(function dToD(d: Developer): Developer {   return new Developer(); });  // Developer =&gt; Developer에 Person =&gt; Developer를 할당하는 경우 tellme(function pToD(d: Person): Developer {   return new Developer(); });  // Developer =&gt; Developer에 StartupDeveloper =&gt; Developer를 할당하는 경우 // strictFunctionTypes 옵션을 켜면 함수 할당 시 매개변수 타입이 같거나 // 슈퍼타입인 경우가 아닌 경우, 에러를 통해 경고 tellme(function sToD(d: StartupDeveloper): Developer {   return new Developer(); });       2. 타입 별칭(Type Alias)      Interface랑 비슷   Primitive, Union Type, Tuple, Function   기타 직접 작성해야하는 타입을 다른 이름을 지정할 수 있음   만들어진 타입의 refer로 사용하는 것   타입을 만드는 것은 아님   타입이 타입으로서의 목적이 명확하면 Interface, 그렇지 않다면 Type Alias 사용   // Aliasing Primitive // 별 의미가 없음 type MyStringType = string; const str = 'world'; let myStr: MyStringType = 'hello';  myStr = str;   // ------------------------------------------ // Aliasing Union Type // Union Type은 A도 가능하고 B도 가능한 타입 // 길게 쓰는걸 짧게해주고, 반복을 줄여줌 let person: string | number = 0; person = 'LWW';  type StringOrNumber = string | number; let another: StringOrNumber = 0; another = 'Tom';   // ------------------------------------------ // Aliasing Tuple // 튜플 타입에 별칭을 줘서 여러군데서 사용할 수 있게 함 let person: [string, number] = ['LWW', 29]; type PersonTuple = [string, number]; let another: PersonTuple = ['Tom', 24];   // ------------------------------------------ // Aliasing Function type EatType = (food: string) =&gt; void;  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-typecompalias/",
        "teaser": null
      },{
        "title": "[Data Structure] 배열(Array)",
        "excerpt":"1. 배열 (Array)      데이터를 나열하고, 각 데이터를 index에 대응하도록 구성한 데이터 구조   Python에서는 리스트 타입이 배열 기능을 제공함   - 배열은 왜 필요할까?      같은 종류의 데이터를 효율적으로 관리하기 위해 사용   같은 종류의 데이터를 순차적으로 저장   장점: 빠른 접근 가능            첫 데이터의 위치에서 상대적인 위치로 데이터 접근(index 번호로 접근)           단점: 데이터 추가/삭제의 어려움            미리 최대 길이를 지정해야 함           - 파이썬과 C 언어의 배열 예제   // C // include &lt;stdio.h&gt;  int main(int argc, char * argv[]) {     char country[3] = \"US\";     printf (\"%c%c\\n\", country[0], country[1]);     printf (\"%s\\n\", country);         return 0; }       # Python  country = 'US' print(country)  # US  country = country + 'A' print(country)  # USA       - 파이썬과 배열      파이썬에서는 리스트로 배열 구현 가능   # 1차원 배열 : 리스트로 구현시 data_list = [1, 2, 3, 4, 5] data_list  # [1, 2, 3, 4, 5]   # 2차원 배열 : 리스트로 구현시 data_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] data_list  # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]   print(data_list[0])  # [1, 2, 3] print(data_list[0][0])  # 1 print(data_list[0][1])  # 2 print(data_list[0][2])  # 3 print(data_list[1][0])  # 4 print(data_list[1][1])  # 5       2. 프로그래밍 연습   # 연습1 : 위의 2차원 배열에서 9, 8, 7 순서대로 출력  print(data_list[2][2], data_list[2][1], data_list[2][0])       # 연습2 : 아래 dataset에서 전체 M 의 빈도수 출력하기  # dataset dataset = ['Braund, Mr. Owen Harris', 'Cumings, Mrs. John Bradley (Florence Briggs Thayer)', 'Heikkinen, Miss. Laina', 'Futrelle, Mrs. Jacques Heath (Lily May Peel)', 'Allen, Mr. William Henry', 'Moran, Mr. James', 'McCarthy, Mr. Timothy J', 'Palsson, Master. Gosta Leonard', 'Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)', 'Nasser, Mrs. Nicholas (Adele Achem)', 'Sandstrom, Miss. Marguerite Rut', 'Bonnell, Miss. Elizabeth', 'Saundercock, Mr. William Henry', 'Andersson, Mr. Anders Johan', 'Vestrom, Miss. Hulda Amanda Adolfina', 'Hewlett, Mrs. (Mary D Kingcome) ', 'Rice, Master. Eugene', 'Williams, Mr. Charles Eugene', 'Vander Planke, Mrs. Julius (Emelia Maria Vandemoortele)', 'Masselmani, Mrs. Fatima', 'Fynney, Mr. Joseph J', 'Beesley, Mr. Lawrence', 'McGowan, Miss. Anna \"Annie\"', 'Sloper, Mr. William Thompson', 'Palsson, Miss. Torborg Danira', 'Asplund, Mrs. Carl Oscar (Selma Augusta Emilia Johansson)', 'Emir, Mr. Farred Chehab', 'Fortune, Mr. Charles Alexander', 'Dwyer, Miss. Ellen \"Nellie\"', 'Todoroff, Mr. Lalio']   # 구현부 m_count = 0  for data in dataset :   for index in range(len(data)) :     if data[index] == 'M' :       m_count += 1  print(m_count)  # 38  ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-array/",
        "teaser": null
      },{
        "title": "[Data Structure] 큐(Queue)",
        "excerpt":"1. 큐 (Queue)   - 큐 구조      줄을 서는 행위와 유사   가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조            음식점에서 가장 먼저 줄을 선 사람이 제일 먼저 음식점에 입장하는 것과 동일       FIFO(First-In, First-Out) 또는 LILO(Last-In, Last-Out) 방식으로 스택과 꺼내는 순서가 반대                출처: http://www.stoimen.com/blog/2012/06/05/computer-algorithms-stack-and-queue-data-structure/   - 알아둘 용어      Enqueue: 큐에 데이터를 넣는 기능   Dequeue: 큐에서 데이터를 꺼내는 기능   Visualgo 사이트에서 시연해보며 이해하기 (enqueue/dequeue 만 클릭해보며): https://visualgo.net/en/list   - 파이썬 queue 라이브러리 활용해서 큐 자료 구조 사용하기      queue 라이브러리에는 다양한 큐 구조로 Queue(), LifoQueue(), PriorityQueue() 제공   프로그램을 작성할 때 프로그램에 따라 적합한 자료 구조를 사용            Queue(): 가장 일반적인 큐 자료 구조       LifoQueue(): 나중에 입력된 데이터가 먼저 출력되는 구조 (스택 구조라고 보면 됨)       PriorityQueue(): 데이터마다 우선순위를 넣어서, 우선순위가 높은 순으로 데이터 출력              일반적인 큐 외에 다양한 정책이 적용된 큐들이 있음    @ Queue()로 큐 만들기 (가장 일반적인 큐, FIFO(First-In, First-Out))   # 일반적인 큐. Queue()  import queue  data_queue = queue.Queue()  # .put() -&gt; 데이터 삽입 data_queue.put(\"first data\") data_queue.put(123)  # .qsize() -&gt; Queue 사이즈 확인 data_queue.qsize()  # 2  # .get() -&gt; 데이터 꺼내기 data_queue.get()  # 'first data'  data_queue.qsize()  # 1  data_queue.get()  # 123  data_queue.qsize()  # 0       @ LifoQueue()로 큐 만들기 (LIFO(Last-In, First-Out))   # Lifo 큐. LifoQueue()  import queue  data_queue = queue.LifoQueue()  data_queue.put(\"first data\") data_queue.put(123)  data_queue.qsize()  # 2  data_queue.get()  # 123       @ PriorityQueue()로 큐 만들기   # 우선순위 큐. PriorityQueue()  import queue  data_queue = queue.PriorityQueue()  # .put(우선순위, 데이터) data_queue.put((10, \"first data\")) data_queue.put((5, 123)) data_queue.put((15, \"LWW\"))  data_queue.qsize()  # 3  data_queue.get()  # (5, 123) data_queue.get()  # (10, 'first data')       - 어디에 큐가 많이 쓰일까?      멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됨 (운영체제 참조)      큐의 경우에는 장단점 보다는 (특별히 언급되는 장단점이 없음), 큐의 활용 예로 프로세스 스케쥴링 방식을 함께 이해해두는 것이 좋음        2. 프로그래밍 연습   # 연습 : 리스트 변수로 큐를 다루는 enqueue, dequeue 기능 구현  queue_list = list()  def enqueue(data) :   queue_list.append(data)  def dequeue() :   data = queue_list[0]   del queue_list[0]   return data  for index in range(10) :   enqueue(index)  len(queue_list)  # 10  dequeue()  # 0 dequeue()  # 1 dequeue()  # 2 dequeue()  # 3 dequeue()  # 4  ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-queue/",
        "teaser": null
      },{
        "title": "[Data Structure] 스택(Stack)",
        "excerpt":"1. 스택 (Stack)      데이터를 제한적으로 접근할 수 있는 구조            한쪽 끝에서만 자료를 넣거나 뺄 수 있는 구조           가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조            큐: FIFO 정책       스택: LIFO 정책           - 스택 구조      스택은 LIFO(Last In, Fisrt Out) 또는 FILO(First In, Last Out) 데이터 관리 방식을 따름            LIFO: 마지막에 넣은 데이터를 가장 먼저 추출하는 데이터 관리 정책       FILO: 처음에 넣은 데이터를 가장 마지막에 추출하는 데이터 관리 정책           대표적인 스택의 활용            컴퓨터 내부의 프로세스 구조의 함수 동작 방식           주요 기능            push(): 데이터를 스택에 넣기       pop(): 데이터를 스택에서 꺼내기           Visualgo 사이트에서 시연해보며 이해하기 (push/pop 만 클릭해보며): https://visualgo.net/en/list          - 스택 구조와 프로세스 스택      스택 구조는 프로세스 실행 구조의 가장 기본            함수 호출시 프로세스 실행 구조를 스택과 비교해서 이해 필요           # 재귀 함수  def recursive(data) :   if data &lt; 0 :     print('ended')   else :     print(data)     recursive(data - 1)     print('returned', data)  recursive(4)  # 4               # 3               # 2               # 1               # 0               # ended               # returned 0               # returned 1               # returned 2               # returned 3               # returned 4       - 자료 구조 스택의 장단점      장점            구조가 단순해서, 구현이 쉽다.       데이터 저장/읽기 속도가 빠르다.           단점 (일반적인 스택 구현시)            데이터 최대 갯수를 미리 정해야 한다.                    파이썬의 경우 재귀 함수는 1000번까지만 호출이 가능함                       저장 공간의 낭비가 발생할 수 있음                    미리 최대 갯수만큼 저장 공간을 확보해야 함                              스택은 단순하고 빠른 성능을 위해 사용되므로, 보통 배열 구조를 활용해서 구현하는 것이 일반적임. 이 경우, 위에서 열거한 단점이 있을 수 있음    - 파이썬 리스트 기능에서 제공하는 메서드로 스택 사용해보기      append(push), pop 메서드 제공   data_stack.append(1) data_stack.append(2)  data_stack  # [1, 2]  # .pop() -&gt; 데이터 꺼내기 data_stack.pop()  # 2       2. 프로그래밍 연습   # 연습 : 리스트 변수로 스택을 다루는 pop, push 기능 구현해보기  stack_list = list()  def push(data) :   stack_list.append(data)  def pop() :   data = stack_list[-1]   del stack_list[-1]   return data  for index in range(10) :   push(index)  pop()  # 9 pop()  # 8 pop()  # 7  ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-stack/",
        "teaser": null
      },{
        "title": "[Data Structure] 링크드 리스트(Linked List)",
        "excerpt":"1. 링크드 리스트 (Linked List)   - 링크드 리스트 (Linked List) 구조      연결 리스트라고도 함   배열은 순차적으로 연결된 공간에 데이터를 나열하는 데이터 구조   링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조   C언어에서는 주요한 데이터 구조이지만, 파이썬은 리스트 타입이 링크드 리스트의 기능을 모두 지원   링크드 리스트 기본 구조와 용어            노드(Node): 데이터 저장 단위 (데이터값, 포인터) 로 구성       포인터(pointer): 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간           일반적인 링크드 리스트 형태              (출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)   - 간단한 링크드 리스트 예시   @ Node 구현      보통 파이썬에서 링크드 리스트 구현시, 파이썬 클래스를 활용함            파이썬 객체지향 문법 이해 필요       참고: https://www.fun-coding.org/PL&amp;OOP1-3.html           # 1 class Node :   def __init__(self, data) :     self.data = data     self.next = None  # 2 class Node :   def __init__(self, data, next=None) :     self.data = data     self.next = next       @ Node와 Node 연결하기 (포인터 활용)   node1 = Node(1) node2 = Node(2) node1.next = node2 head = node1       @ 링크드 리스트로 데이터 추가하기   class Node :   def __init__(self, data, next=None) :     self.data = data     self.next = next      def add(data) :     node = head     while node.next :       node = node.next     node.next = Node(data)  node1 = Node(1) head = node1  for index in range(2, 10) :   add(index)       @ 링크드 리스트 데이터 출력하기(검색하기)   node = head while node.next :   print(node.data)   node = node.next  print(node.data)  # 1                   # 2                   # 3                   # ...                   # 9       - 링크드 리스트의 장단점 (전통적인 C언어에서의 배열과 링크드 리스트)      장점            미리 데이터 공간을 미리 할당하지 않아도 됨                    배열은 미리 데이터 공간을 할당 해야 함                           단점            연결을 위한 별도 데이터 공간이 필요하므로, 저장공간 효율이 높지 않음       연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림       중간 데이터 삭제시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요           - 링크드 리스트의 복잡한 기능1 (링크드 리스트 데이터 사이에 데이터를 추가)      링크드 리스트는 유지 관리에 부가적인 구현이 필요함              (출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)   node = head while node.next :   print(node.data)   node = node.next  print(node.data)  # 1                   # 2                   # 3                   # ...                   # 9  node3 = Node(1.5)  node = head search = True while search :   if node.data == 1 :     search = False   else :     node = node.next  node_next = node.next node.next = node3 node3.next = node_next  node = head while node.next:     print(node.data)     node = node.next  print (node.data)  # 1                    # 1.5                    # 2                    # 3                    # ...                    # 9       - 파이썬 객체지향 프로그래밍으로 링크드 리스트 구현하기   class Node :   def __init__(self, data, next=None) :     self.data = data     self.next = next  class NodeMgmt :   def __init__(self, data) :     self.head = Node(data)    def add(self, data) :     if self.head == '' :       self.head = Node(data)     else :       node = self.head       while node.next :         node = node.next       node.next = Node(data)    def desc(self) :     node = self.head     while node :       print(node.data)       node = node.next  linked_list1 = NodeMgmt(0) linked_list1.desc()  # 0  for data in range(1, 10) :   linked_list1.add(data)  linked_list1.desc()  # 0                      # 1                      # 2                      # ...                      # 9       - 링크드 리스트의 복잡한 기능2 (특정 노드를 삭제)      다음 코드는 위의 코드에서 delete 메서드만 추가한 것이므로 해당 메서드만 확인   class Node :   def __init__(self, data, next=None) :     self.data = data     self.next = next  class NodeMgmt :   def __init__(self, data) :     self.head = Node(data)    def add(self, data) :     if self.head == '' :       self.head = Node(data)     else :       node = self.head       while node.next :         node = node.next       node.next = Node(data)    def desc(self) :     node = self.head     while node :       print(node.data)       node = node.next    def delete(self, data) :     if self.head == '' :       print('해당 값을 가진 노드가 없습니다.')       return     # head 삭제     if self.head.data == data :       temp = self.head       self.head = self.head.next       del temp     else :       node = self.head       while node.next :         # 중간, 끝 노드 삭제         if node.next.data == data :           temp = node.next           node.next = node.next.next           del temp           return         else :           node = node.next  # 테스트를 위해 1개 노드를 만들어 봄 linked_list1 = NodeMgmt(0) linked_list1.desc()  # 0  # head가 살아있음을 확인 linked_list1.head  # &lt;__main__.Node at 0x...&gt;  # head를 지워봄 linked_list1.delete(0)  # linked_list1.head가 삭제됨 linked_list1.head  # 출력 없음  # 다시 하나의 노드를 만들어 봄 linked_list1 = NodeMgmt(0) linked_list1.desc()  # 0  # 여러 노드를 추가해 봄 for data in range(1, 10) :   linked_list1.add(data)  linked_list1.desc()  # 0                      # 1                      # 2                      # ...                      # 9  # 노드 중에 한개를 삭제 linked_list1.delete(4) linked_list1.desc()  # 0                      # 1                      # 2                      # 3                      # 5                      # ...                      # 9  linked_list1.delete(9) linked_list1.desc()  # 0                      # 1                      # 2                      # 3                      # 5                      # ...                      # 8       2. 프로그래밍 연습   # 연습1: 위 코드에서 노드 데이터가 특정 숫자인 노드를 찾는 함수를 만들고, 테스트해보기 # 테스트: 임의로 1 ~ 9까지 데이터를 링크드 리스트에 넣어보고, 데이터 값이 4인 노드의 데이터 값 출력해보기  class Node :   def __init__(self, data) :     self.data = data     self.next = None  class NodeMgmt :   def __init__(self, data) :     self.head = Node(data)    def add(self, data) :     if self.head == '' :       self.head = Node(data)     else :       node = self.head       while node.next :         node = node.next       node.next = Node(data)    def desc(self) :     node = self.head     while node :       print(node.data)       node = node.next    def delete(self, data) :     if self.head == '' :       print('해당 값을 가진 노드가 없습니다.')       return     # self.head를 삭제해야할 경우 - self.head를 바꿔줘야 함     if self.head.data == data :       temp = self.head  # self.head 객체를 삭제하기 위해, 임시로 temp에 담아서 객체를 삭제       self.head = self.head.next  # self.head 객체를 삭제하면, 이 코드가 실행이 안됨       del temp     else :       node = self.head       while node.next :          # self.head가 아닌 노드를 삭제해야할 경우         if node.next.data == data :           temp = node.next           node.next = node.next.next           del temp           pass         else :           node = node.next    # 노드를 찾는 함수   def search_node(self, data) :     node = self.head     while node :       if node.data == data :         return data       else :         node = node.next  # 테스트 linked_list2 = NodeMgmt(0)  for data in range(1, 10) :   linked_list2.add(data)  node = linked_list2.search_node(4) print(node.data)  # 4       3. 다양한 링크드 리스트 구조      더블 링크드 리스트(Doubly linked list) 기본 구조            이중 연결 리스트라고도 함       장점: 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능                      (출처: wikipedia, https://en.wikipedia.org/wiki/Linked_list)   class Node :   def __init__(self, data, prev=None, next=None) :     self.prev = prev     self.data = data     self.next = next  class NodeMgmt :   def __init__(self, data) :     self.head = Node(data)     self.tail = self.head    def insert(self, data) :     if self.head == None :       self.head = Node(data)       self.tail = self.head     else :       node = self.head       while node.next :         node = node.next       new = Node(data)       node.next = new       new.prev = node       self.tail = new    def desc(self) :     node = self.head     while node :       print(node.data)       node = node.next  # 테스트 double_linked_list = NodeMgmt(0)  for data in range(1, 10) :   double_linked_list.insert(data)  double_linked_list.desc()  # 0                            # 1                            # 2                            # ...                            # 9       4. 프로그래밍 연습   # 연습2: 위 코드에서 노드 데이터가 특정 숫자인 노드 앞에 데이터를 추가하는 함수를 만들고, 테스트 # 더블 링크드 리스트의 tail 에서부터 뒤로 이동하며, 특정 숫자인 노드를 찾는 방식으로 함수를 구현하기 # 테스트: 임의로 0 ~ 9까지 데이터를 링크드 리스트에 넣어보고, 데이터 값이 2인 노드 앞에 1.5 데이터 값을 가진 노드를 추가해보기  class Node :   def __init__(self, data, prev=None, next=None) :     self.prev = prev     self.data = data     self.next = next  class NodeMgmt :   def __init__(self, data) :     self.head = Node(data)     self.tail = self.head    def insert(self, data) :     if self.head == None :       self.head = Node(data)       self.tail = self.head     else :       node = self.head       while node.next :         node = node.next       new = Node(data)       node.next = new       new.prev = node       self.tail = new    def desc(self) :     node = self.head     while node :       print(node.data)       node = node.next      def search_from_head(self, data) :     if self.head == None :       return False     node = self.head     while node :       if node.data == data :         return node       else :         node = node.next     return False    def search_from_tail(self, data) :     if self.head == None :       return False     node = self.tail     while node :       if node.data == data :         return node       else :         node = node.prev     return False    def insert_before(self, data, before_data) :     if self.head == None :       self.head = Node(data)       return True     else :       node = self.tail       while node.data != before_data :         node = node.prev         if node == None :           return False       new = Node(data)       before_new = node.prev       before_new.next = new       new.prev = before_new       new.next = node       node.prev = new       return True  # 테스트 double_linked_list = NodeMgmt(0)  for data in range(1, 10):     double_linked_list.insert(data)  double_linked_list.desc()  # 0                            # 1                            # 2                            # ...                            # 9  node_3 = double_linked_list.search_from_tail(3) node_3.data  # 3  double_linked_list.insert_before(1.5, 2) double_linked_list.desc()  # 0                            # 1                            # 1.5                            # 2                            # ...                            # 9  node_3 = double_linked_list.search_from_tail(1.5) node_3.data  # 1.5       # 연습4: 위 코드에서 노드 데이터가 특정 숫자인 노드 뒤에 데이터를 추가하는 함수를 만들고, 테스트해보기 # 더블 링크드 리스트의 head 에서부터 다음으로 이동하며, 특정 숫자인 노드를 찾는 방식으로 함수를 구현하기 # 테스트: 임의로 0 ~ 9까지 데이터를 링크드 리스트에 넣어보고, 데이터 값이 1인 노드 다음에 1.7 데이터 값을 가진 노드를 추가해보기  class Node :   def __init__(self, data, prev=None, next=None):     self.prev = prev     self.data = data     self.next = next  class NodeMgmt :   def __init__(self, data) :     self.head = Node(data)     self.tail = self.head      def insert_before(self, data, before_data) :     if self.head == None :       self.head = Node(data)       return True     else :       node = self.tail       while node.data != before_data :         node = node.prev         if node == None :           return False       new = Node(data)       before_new = node.prev       before_new.next = new       new.next = node       return True    def insert_after(self, data, after_data) :     if self.head == None :       self.head = Node(data)       return True     else :       node = self.head       while node.data != after_data :         node = node.next         if node == None :           return False       new = Node(data)       after_new = node.next       new.next = after_new       new.prev = node       node.next = new       if new.next == None :         self.tail = new       return True    def insert(self, data) :     if self.head == None :       self.head = Node(data)     else :       node = self.head       while node.next :         new = Node(data)       new = Node(data)       node.next = new       new.prev = node       self.tail = new      def desc(self) :     node = self.head     while node :       print(node.data)       node = node.next  # 테스트 double_linked_list = NodeMgmt(0)  for data in range(1, 10) :   double_linked_list.insert(data)  double_linked_list.desc()  # 0                            # 1                            # 2                            # ...                            # 9  double_linked_list.insert_after(1.5, 1)  double_linked_list.desc()  # 0                            # 1                            # 1.5                            # 2                            # ...                            # 9  ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-linkedlist/",
        "teaser": null
      },{
        "title": "[Typescript] 컴파일러",
        "excerpt":"1. Compilation Context   https://radlohead.gitbook.io/typescript-deep-dive/      Typescript를 Javascript로 변환하는데 사용하는 Typescript Compiler가 어떤 파일과 어떤 방식으로 컴파일 할 것인지를 규명한 것이 Compilation Context   tsconfig.json 파일에 선언되어 있음       2. tsconfig schema   http://json.schemastore.org/tsconfig      최상위 프로퍼티            compileOnSave       extends       conpileOptions       files       include       exclude       references           # 새 프로젝트 생성  $ mkdir compilation-context  $ cd compilation-context  $ npm init -y  $ npm i typescript -D  $ npx tsc --init  $ cat tsconfig.json       3. compileOnSave      Save 하면 컴파일   true / false (default false)   Visual Studio 2015 with Typescript 1.8.4 이상   atom-typescript 플러그인   // 형태  {   ...,   \"compileOnSaveDefinition\": {     \"properties\": {       \"compileOnSave\": {         \"description\": \"Enable Compile-on-Save for this project.\",         \"type\": \"boolean\"       }     }   },   ..., }       // tsconfig.json  {   \"compileOnSave\": true,   \"compilerOptions\": {     ...   } }       4. extends      파일 (상대) 경로명: string   Typescript 2.1 New Spec   // 형태  {   ...,   \"extendsDefinition\": {     \"properties\": {       \"extends\": {         \"description\": \"Path to base configuration file to inherit from. Requires TypeScript version 2.1 or later.\",         \"type\": \"string\"       }     }   },   ..., }       // tsconfig.json  {   \"extends\": \"./base.json\",   \"compilerOptions\": {     ...   // \"strict\": true 옵션 주석처리   } }   // base.json {   \"compilerOptions\": {     \"strict\": true   } }       // test.ts  const a: number = undefined;  // Error       # 설정 다운로드 $ npm install --save-dev @tsconfig/deno       // 설정 적용 {   \"extends\": \"@tsconfig/deno/tsconfig.json\",   ... }       5. files, include, exclude      셋다 설정이 없으면, 전부다 컴파일 하려고 함   files            상대 혹은 절대 경로의 리스트 배열       exclude 보다 강함           include            glob 패턴 (마치 .gitignore)       exclude 보다 약함       *같은 것을 사용하면, .ts / .tsx / .d.ts 만 include(allowJS)           exclude            glob 패턴 (마치 .gitignore)       설정 안하면 4가지(node_modules, bower_components, jspm_packages, &#60;outDir&#62;)를 default로 제외함       &#60;outDir&#62;은 include에 있어도 항상 제외           {   ...   // files 형태   \"filesDefinition\": {     \"properties\": {       \"files\": {         \"description\": \"If no 'files' or 'include' property is present in a tsconfig.json, the compiler defaults to including all files in the containing directory and subdirectories except those specified by 'exclude'. When a 'files' property is specified, only those files and those specified by 'include' are included.\",         \"type\": \"array\",         \"uniqueItems\": true,         \"items\": {           \"type\": \"string\"         }       }     }   },   // exclude 형태   \"excludeDefinition\": {     \"properties\": {       \"exclude\": {         \"description\": \"Specifies a list of files to be excluded from compilation. The 'exclude' property only affects the files included via the 'include' property and not the 'files' property. Glob patterns require TypeScript version 2.0 or later.\",         \"type\": \"array\",         \"uniqueItems\": true,         \"items\": {           \"type\": \"string\"         }       }     }   },   // include 형태   \"includeDefinition\": {     \"properties\": {       \"include\": {         \"description\": \"Specifies a list of glob patterns that match files to be included in compilation. If no 'files' or 'include' property is present in a tsconfig.json, the compiler defaults to including all files in the containing directory and subdirectories except those specified by 'exclude'. Requires TypeScript version 2.0 or later.\",         \"type\": \"array\",         \"uniqueItems\" : true,         \"items\": {           \"type\": \"string\"         }       }     }   },   ..., }       6. compileOptions - typeRoots, types      @types는 Typescript 2.0부터 사용 가능한 내장 type definition 시스템   아무 설정도 하지 않으면, node_modules/@types라는 모든 경로를 찾아서 사용   typeRoots를 사용하면, 배열 안에 들어있는 경로들 아래서만 가져옴   types를 사용하면, 배열 안의 모듈 혹은 ./node_modules/@types/ 안의 모듈 이름에서 찾아옴, [] 빈 배열을 넣으면 이 시스템을 이용하지 않겠다는 뜻   typeRoots와 types를 같이 사용하지 않음   {   ...,   // typeRoots 형태   \"typeRoots\": {     \"description\": \"Specify multiple folders that act like `./node_modules/@types`.\",     \"type\": \"array\",     \"uniqueItems\": true,     \"items\": {       \"type\": \"string\"     },     \"markdownDescription\": \"Specify multiple folders th ... \"   },   // types 형태   \"types\": {     \"description\": \"Specify type package names to be included without being referenced in a source file.\",     \"type\": \"array\",     \"uniqueItems\": true,     \"items\": {       \"type\": \"string\"     },     \"markdownDescription\": \"Specify type package names to be ... \"   },   ..., }       # terminal  $ npm i react       // test.ts  import React from \"react\";  // Error       # terminal  $ npm i --save-dev @types/react       // test.ts  import React from \"react\";       7. compileOptions - target, lib      target            빌드의 결과물을 어떤 버전으로 할 것인지 결정       지정을 하지 않으면 es3           lib            기본 type definition 라이브러리를 어떤 것을 사용할 것인지 결정       lib를 지정하지 않을 때,                    target이 ‘es3’이고, 디폴트로 lib.d.ts를 사용           target이 ‘es5’이면, 디폴트로 dom, es5, scripthost를 사용           target이 ‘es6’이면, 디폴트로 dom, es6, dom.iterable, scripthost를 사용                       lib를 지정하면 그 lib 배열로만 라이브러리를 사용                    빈 [] : Error. ‘no definition found … ‘                           // target 형태  {   \"target\": {     \"description\": \"Set the JavaScript language version for emitted Javascript and include compatible library declarations.\",     \"type\", \"string\",     \"default\": \"ES3\",     \"anyOf\": [       {         \"enum\": [           \"ES3\",           \"ES5\",           \"ES6\",           \"ES2015\",           ...           \"ES2020\",           \"ESNext\"         ]       },       {         \"pattern\": \"^([Ee][Ss]([356]|(20(1[56789]|20))|[Nn][Ee][Xx][Tt]))$\"       }     ],     \"markdownDescription\": \"Set the JavaScript language version ...\"   },   ..., }       // tsconfig.json // target은 es5  \"target\": \"es5\"       // test.ts  const hello = () =&gt; {};       # terminal  npx tsc       // test.js // es5 에서는 arrow function이 변경되서 컴파일 됨  \"use strict\"; var hello = function () { };         // tsconfig.json // target을 es6로 변경  \"target\": \"es6\"       // test.ts  const hello = () =&gt; {};       # terminal  npx tsc       // test.js // es6 에서는 arrow function이 그대로 컴파일 됨  \"use strict\"; const hello = () =&gt; { };       // lib 형태  {   \"lib\": {     \"description\": \"Specify a set of bundled library declaration files that describe the target runtime environment.\",     \"type\": \"array\",     \"uniqueItems\": true,     \"items\": {       \"type\": \"string\",       \"anyOf\" : [         {           \"enum\": [             \"ES5\", \"ES6\", ...           ]         },         {           \"pattern\": \"^[Ee][Ss]5|[Ee][Ss]6|[Ee][Ss]7$\"         }       ]     }   } }       8. compileOptions - outDir, outFile, rootDir   {   // outFile 형태   \"outFile\": {     \"description\": \"Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output.\",     \"type\": \"string\",     \"markdownDescription\": \"Specify a file that bundles all outputs ...\"   },   // outDir 형태   \"outDir\": {     \"description\": \"Specify an output folder for all emitted files.\",     \"type\": \"string\",     \"markdownDescription\": \"Specify an output folder for all emitted files. ...\"   },   // rootDir 형태   \"rootDir\": {     \"description\": \"Specify the root folder within your source files.\",     \"type\": \"string\",     \"markdownDescription\": \"Specify the root folder within your source files. ...\"   } }       // tsconfig.json  \"outDir\": \"./dist\" \"rootDir\": \"./src\"       // src/test.ts  console.log(\"hello\")       # terminal  $ npx tsc       // dist/test.js // dist 폴더가 생성되고 컴파일 됨  console.log(\"hello\")       9. compileOptions - strict   // strict 형태  {   \"strict\": {     \"description\": \"Enable all strict type checking options.\",     \"type\": \"boolean\",     \"default\": false,     \"markdownDescription\": \"Enable all strict type checking options. ...\"   } }          –noImplicitAny            명시적이지 않게 any 타입을 사용, 표현식과 선언제 사용하면 에러 발생       Typescript가 추론을 실패한 경우, any가 맞으면 any라고 지정       아무것도 쓰지 않으면, 에러 발생       이 오류를 해결하면, any라고 지정되어 있지 않은 경우는 any가 아닌 것       suppressImplicitAnyIndexErrors                    인덱스 객체에 인덱스 signature가 없는 경우 오류 발생. 이를 예외처리                           //noImplicitAny function noImplicitAnyTestFunc(arg) {   console.log(arg);  // Error! Parameter 'arg' implicitly has an 'any' type. }   // suppressImplicitAnyIndexErrors var obj = {   bar: 10 };  // obj['foo']로 사용할 때, 인덱스 객체라 판단하여, 타입에 인덱스 시그니처가 없는 경우, 에러 발생 obj['foo'] = 10; // Error: Index signature of object type implicitly has an 'any' type obj['bar'] = 10;  // Okay obj.baz = 10;  // 이때 suppressImplicitAnyIndexErrors 옵션을 사용하면 예외로 간주하여 에러발생 x          –noImplicitThis            명시적이지 않게 any 타입을 사용하여, this 표현식에 사용하면 에러 발생           // noImplicitThis function noImplicitThisTestFunc(name: string, age: number) {   this.name = name;   this.age = age;   return this;  // Error! 'this' implicitly has type 'any' ... }   // 첫 번째 매개변수 자리에 this를 놓고, this 타입을 표현하지 않으면 에러 // Javascript에서는 매개변수에 this를 넣으면, 예약어라 SyntaxError 발생 // call / apply / bind와 같이 this를 대체하여 함수 콜을 하는 용도로도 쓰임 // this를 any로 명시적으로 지정하는 것은 합리적 // 물론 구체적인 사용처가 있는 경우 타입을 표현하기도 함 function noImplicitThisTestFunc(this, name: string, age: number) {   this.name = name;   this.age = age;   return this;  // Error! Parameter 'this' implicitly has an 'any' type }   // Class에서는 this를 사용하면서, noImplicitThis와 관련한 에러가 나지 않음 // CLass에서 constructor를 제외한 멤버 함수의 첫 번째 매개변수도 일반 함수와 마찬가지로 this를 사용할 수 있음 // noImplicitTHis 2 class NoImplicitThisTestClass {   private _name: string;   private _age: number;    constructor(name: string, age: number) {     this._name = name;     this._age = age;   }    public print(this: NoImplicitThisTestClass) {     console.log(this._name, this._age)   } }  new NoImplicitThisTestClass('LWW', 29).print();          –strictNullChecks            null및 undefined 값이 모든 유형의 도메인에 속하지 않으며, 그 자신을 타입으로 가지거나, any일 경우에만 할당이 가능       한 가지 예외는 undefined에 void 할당 가능       strictNullChecks 옵션을 적용하지 않으면                    모든 타입은 null, undefined 값을 가질 수 있음           string으로 타입을 지정해도, null 혹은 undefined 값을 할당할 수 있음                       strictNullChecks를 적용하면                    모든 타입은 null, undefined 값을 가질 수 있음           null, undefined 값을 가지려면 union type을 이용하여 직접 명시해야 함           any 타입은 null과 undefined를 가짐           예외적으로 void 타입은 undefined를 가짐                       strictNullChecks를 적용하지 않고 사용하면, 정확히 어떤 타입이 오는지 개발자 스스로 간과할 수 있음       정말로 null과 undefined를 가질 수 있는 경우, 해당 값을 조건부로 제외하고 사용하는 것이 좋음       strictNullChecks를 적용하는 경우, 사용하려는 함수를 선언할 때부터 매개변수와 리턴 값에 정확한 타입을 지정하려는 노력을 기울여야 함           // strictNullChecks const a: number = null; const b: string = undefined; const c: number | null = null; const d: any = null; const e: any = undefined; const f: void = undefined;          –strictFunctionTypes            함수 타입에 대한 bivariant 매개변수 검사를 비활성화 함       반환 타입은 공변적, 인자 타입은 반공변적       Typescript에서 인자 타입은 공변적이면서, 반공변적임       이 문제를 해결하는 옵션이 strictFunctionTypes       옵션을 켜면 에러가 나지 않던 것을 에러가 발생하게 함           // strictFunctionTypes const button = document.querySelector('#id') as HTMLButtonElement;  buttom.addEventListener('keydown', (e: MouseEvent) =&gt; {});  // 이전에는 위와 같은 코드도 에러를 발생시키지 않았지만, 이제는 에러 발생          –strictPropertyInitialization            정의되지 않은 클래스의 속성이 생성자에서 초기화되었는지 확인       이 옵션을 사용하려면 –strictNullChecks를 사용하도록 설정해야 함           // strictPropertyInitialization class Person {   private _name: string;   private _age: number;  // Error! Property '_age' has no initializer and is ..      constructor() {}    public print() {     console.log(this._name, this._age)   } }    // constructor에서 초기 값을 할당한 경우는 정상 동작 class Person {   private _name: string;   private _age: number;    constructor(name: string, age: number) {     this._name = name;     this._age = age;   }    public print() {     console.log(this._name, this._age)   } }   // constructor에서 안하는 경우 // - 보통 다른 함수로 이니셜라이즈 하는 경우 (async 함수) // - constructor에는 async를 사용할 수 없음 class Person {   private _name!: string;   private _age!: number;    public async initialize(name: string, age: number) {     this._name = name;     this._age = age;   }    public print() {     console.log(this._name, this._age)   } }          –strictBindCallApply            Function의 내장 함수인 bind, call, apply에 대한 더 엄격한 체크 수행       bind는 해당 함수 안에서 사용할 this와 인자를 설정해주는 역할       call과 apply는 this와 인자를 설정한 후, 실행까지 함       call과 apply는 인자를 설정하는 방식에서 차이점이 있음                    call은 함수의 인자를 여러 인자의 나열로 넣어서 사용           apply는 모든 인자를 배열 하나로 넣어서 사용                                  –alwaysStrict            각 소스 파일에 대해 Javascript의 strict mode로 코드를 분석       “엄격하게 사용”을 해제           // alwaysStrict var e1 = 015; var e2 = { p: 1, p: 2 };  // Error! An object literal cannot have multiple ... var e3; delete e3;  // syntex 에러가 ts error로 나옴 // 컴파일된 Javascript 파일에 \"use strict\"가 추가 됨  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-compiler/",
        "teaser": null
      },{
        "title": "[Data Structure] 시간 복잡도",
        "excerpt":"1. 알고리즘 복잡도 표현 방법   - 알고리즘 복잡도 계산이 필요한 이유      하나의 문제를 푸는 알고리즘은 다양할 수 있음            정수의 절대값 구하기       1, -1 =&gt; 1       방법1: 정수값을 제곱한 값에 다시 루트를 씌우기       방법2: 정수가 음수인지 확인해서, 음수일 때만, -1을 곱하기              다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해, 복잡도를 정의하고 계산함    - 알고리즘 복잡도 계산 항목      시간 복잡도 : 알고리즘 실행 속도   공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈      가장 중요한 시간 복잡도를 꼭 이해하고 계산할 수 있어야 함    - 알고리즘 시간 복잡도의 주요 요소      반복문       자동차로 서울에서 부산을 가기 위해, 가장 총 시간에 영향을 많이 미칠 것 같은 요소?   예:            자동차로 서울에서 부산가기                    자동차 문열기           자동차 문닫기           자동차 운전석 등받이 조정하기           자동차 시동걸기           자동차로 서울에서 부산가기 (O)           자동차 시동끄기           자동차 문열기           자동차 문닫기                           마찬가지로, 프로그래밍에서 시간 복잡도에 가장 영향을 많이 미치는 요소는 반복문   입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행 시간을 지배   - 알고리즘 성능 표기법      Big O (빅-오) 표기법: O(N)            알고리즘 최악의 실행 시간을 표기       가장 많이/일반적으로 사용       아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미           Ω (오메가) 표기법:  Ω(N)            알고리즘 최상의 실행 시간을 표기           Θ (세타) 표기법: Θ(N)            알고리즘 평균 실행 시간을 표기              시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중, 최악의 시간인 Big-O 표기법을 중심으로 익히기    - 대문자 O 표기법      빅 오 표기법, Big-O 표기법 이라고도 부름   O(입력)            입력 n 에 따라 결정되는 시간 복잡도 함수       O(1), O($log n$), O(n), O(n$log n$), O($n^2$), O($2^n$), O(n!)등으로 표기       입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음       O(1) &lt; O($log n$) &lt; O(n) &lt; O(n$log n$) &lt; O($n^2$) &lt; O($2^n$) &lt; O(n!)       참고 : log n 의 베이스는 2 - $log_2 n$           단순하게 입력 n에 따라, 몇번 실행이 되는지를 계산            표현식에 가장 큰 영향을 미치는 n 의 단위로 표기       n이 1이든 100이든, 1000이든, 10000이든 실행을 무조건 2회(상수회) 실행: O(1)                 if n &gt; 10:             print(n)                          n에 따라, n번, n + 10 번, 또는 3n + 10 번등 실행: O(n)                 variable = 1       for num in range(3):           for index in range(n):                 print(index)                          n에 따라, $n^2$번, $n^2$ + 1000 번, 100$n^2$ - 100, 또는 300$n^2$ + 1번등 실행: O($n^2$)                 variable = 1       for i in range(300):           for num in range(n):               for index in range(n):                     print(index)                                  빅 오 입력값 표기 방법            만약 시간 복잡도 함수가 2$n^2$ + 3n 이라면       가장 높은 차수는 2$n^2$       상수는 실제 큰 영향이 없음       결국 빅 오 표기법으로는 O($n^2$) (서울부터 부산까지 가는 자동차의 예를 상기)               2. 각 알고리즘의 시간 복잡도와 빅 오 표기법 알아보기      연습 :  1부터 n까지의 합을 구하는 알고리즘 작성   - 알고리즘1 : 1부터 n까지의 합      합을 기록할 변수를 만들고 0을 저장   n을 1부터 1씩 증가하면서 반복   반복문 안에서 합을 기록할 변수에 1씩 증가된 값을 더함   반복이 끝나면 합을 출력   # 알고리즘 1  def sum_all(n) :   total = 0   for num in range(1, n+1) :     total += num   return total  sum_all(100)  # 5050       - 알고리즘1 시간 복잡도      1부터 n까지의 합을 구하는 알고리즘1            입력 n에 따라 덧셈을 n 번 해야 함 (반복문)       시간 복잡도 : n, 빅 오 표기법으로는 O(n)           - 알고리즘2 : 1부터 n까지의 합      $\\frac { n (n + 1) }{ 2 }$   # 알고리즘 2  def sum_all(n) :   return int(n * (n + 1) / 2)  sum_all(100)  # 5050       - 알고리즘2 시간 복잡도      1부터 n까지의 합을 구하는 알고리즘2            입력 n이 어떻든 간에, 곱셈/덧셈/나눗셈 하면 됨 (반복문 없음)       시간 복잡도 : 1, 빅 오 표기법으로는 O(1)           - 어느 알고리즘이 성능이 좋은가      알고리즘1 vs 알고리즘2   O(n) vs O(1)          이와 같이, 동일한 문제를 푸는 알고리즘은 다양할 수 있음   어느 알고리즘이 보다 좋은지를 객관적으로 비교하기 위해, 빅 오 표기법등의 시간복잡도 계산법을 사용   이후 자료구조, 알고리즘은 빅 오 표기법으로 성능을 계산해보고, 빅 오 표기법과 계산방법에 익숙해지기  ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-timecomplexity/",
        "teaser": null
      },{
        "title": "[Data Structure] 해시 테이블(Hash Table)",
        "excerpt":"1. 해시 테이블 (Hash Table)   - 해시 구조      Hash Table: 키(Key)에 데이터(Value)를 저장하는 데이터 구조            Key를 통해 바로 데이터를 받아올 수 있으므로, 속도가 획기적으로 빨라짐       파이썬 Dictionary 타입이 해시 테이블의 예 : Key를 가지고 바로 데이터(Value)를 꺼냄       보통 배열로 미리 Hash Table 사이즈만큼 생성 후에 사용 (공간과 탐색 시간을 맞바꾸는 기법)       단, 파이썬에서는 해시를 별도 구현할 이유가 없음 - 딕셔너리 타입을 사용하면 됨           - 알아둘 용어      해시(Hash): 임의 값을 고정 길이로 변환하는 것   해시 테이블(Hash Table): 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조   해싱 함수(Hashing Function): Key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수   해시 값(Hash Value) / 해시 주소(Hash Address): Key를 해싱 함수로 연산해서, 해시 값을 알아내고, 이를 기반으로 해시 테이블에서 해당 Key에 대한 데이터 위치를 일관성있게 찾을 수 있음   슬롯(Slot): 한 개의 데이터를 저장할 수 있는 공간   저장할 데이터에 대해 Key를 추출할 수 있는 별도 함수도 존재할 수 있음              - 간단한 해시 예   @1. hash table 만들기      참고 : 파이썬 list comprehension - https://www.fun-coding.org/PL&amp;OOP5-2.html   hash_table = list(0 for i in range(10)) hash_table  # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]       @2. 간단한 해시 함수 만들기      다양한 해시 함수 고안 기법이 있으며, 가장 간단한 방식이 Division 법   Division 법 : 나누기를 통한 나머지 값을 사용하는 기법   def hash_func(key) :   return key % 5       @3. 해시 테이블에 저장      데이터에 따라 필요시 key 생성 방법 정의가 필요   data1 = 'Andy' data2 = 'Dave' data3 = 'Trump' data4 = 'Anthor'  # ord() -&gt; 문자의 ASCII(아스키)코드 리턴 print(ord(data1[0]), ord(data2[0]), ord(data3[0]))  # 65 68 84 print(ord(data1[0]), hash_func(ord(data1[0])))  # 65 0 print(ord(data1[0]), ord(data4[0]))  # 65 65          해시 테이블에 값 저장 예            data:value 와 같이 data 와 value를 넣으면, 해당 data에 대한 key를 찾아서, 해당 key에 대응하는 해시주소에 value를 저장하는 예           def storage_data(data, value) :   key = ord(data[0])   hash_address = hash_func(key)   hash_table[hash_address] = value       @4. 해시 테이블에서 특정 주소의 데이터를 가져오는 함수 만들기   storage_data('Andy', '01055553333') storage_data('Dave', '01044443333') storage_data('Trump', '01022223333')       @5. 실제 데이터를 저장하고, 읽기   def get_data(data) :   key = ord(data[0])   hash_address = hash_func(key)   return hash_table[hash_address]  get_data('Andy')  # 01055553333       - 해시 테이블의 장단점과 주요 용도      장점            데이터 저장/읽기 속도가 빠름 (검색 속도 빠름)       해시는 키에 대한 데이터가 있는지(중복) 확인이 쉬움           단점            일반적으로 저장공간이 좀더 많이 필요       여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요           주요 용도            검색이 많이 필요한 경우       저장, 삭제, 읽기가 빈번한 경우       캐시 구현시 (중복 확인이 쉽기 때문)               2. 프로그래밍 연습   연습1 : 리스트 변수를 활용해서 해시 테이블 구현      해시 함수 : key % 8   해시 키 생성 : hash(data)   hash_table = list([0 for i in range(8)])  def get_key(data) :   return hash(data)  def hash_function(key) :   return key % 8  def save_data(data, value) :   hash_address = hash_function(get_key(data))   hash_table[hash_address] = value      def read_data(data) :   hash_address = hash_function(get_key(data))   return hash_table[hash_address]   # 테스트 save_data('Dave', '0102030200') save_data('Andy', '01033232200') read_data('Dave')  # 0102030200  hash_table  # [0, 0, 0, 0, 0, '0102030200', 0, '01033232200']       3. 충돌(Collision) 해결 알고리즘      좋은 해시 함수 사용   해시 테이블의 가장 큰 문제는 충돌(Collision)   이 문제를 충돌(Collision) 또는 해시 충돌(Hash Collision)이라고 부름   - Chaining 기법      개방 해싱 또는 Open Hashing 기법 중 하나 : 해시 테이블 저장공간 외의 공간을 활용   충돌이 일어나면 링크드 리스트를 사용해서 데이터를 추가로 뒤에 연결시켜 저장   연습2 : 연습1의 해시 테이블 코드에 Chaining 기법으로 충돌해결 코드를 추가      해시 함수: key % 8   해시 키 생성: hash(data)   hash_table = list([0 for i in range(8)])  def get_key(data) :   return hash(data)  def hash_function(key) :   return key % 8  def save_data(data, value) :   index_key = get_key(data)   hash_address = hash_function(index_key)   if hash_table[hash_address] != 0 :     for index in range(len(hash_table[hash_address])) :       if hash_table[hash_address][index][0] == index_key :         hash_table[hash_address][index][1] = value         return     hash_table[hash_address].append([index_key, value])   else :     hash_table[hash_address] = [[index_key, value]]      def read_data(data) :   index_key = get_key(data)   hash_address = hash_function(index_key)   if hash_table[hash_address] != 0 :     for index in range(len(hash_table[hash_address])):       if hash_table[hash_address][index][0] == index_key :         return hash_table[hash_address][index][1]     return None   else :     return None   # 테스트(매번 다름) print(hash('Dave') % 8)  # 5 print(hash('Df') % 8)  # 0 print(hash('Data') % 8)  # 0  save_data('Df', '1201023010') save_data('Data', '3301023010') read_data('Df')  # '1201023010'  hash_table  # [[[6824493835692342864, '1201023010'], [1504471460684481160, '3301023010']],             # 0,             # 0,             # 0,             # 0,             # 0,             # 0,             # 0]       - Linear Probing 기법      폐쇄 해싱 또는 Close Hashing 기법 중 하나: 해시 테이블 저장공간 안에서 충돌 문제를 해결   충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈공간에 저장   저장공간 활용도를 높이기 위한 기법   연습3 : 연습1의 해시 테이블 코드에 Linear Probling 기법으로 충돌해결 코드를 추가      해시 함수: key % 8   해시 키 생성: hash(data)   hash_table = list([0 for i in range(8)])  def get_key(data) :   return hash(data)  def hash_function(key) :   return key % 8  def save_data(data, value) :   index_key = get_key(data)   hash_address = hash_function(index_key)   if hash_table[hash_address] != 0 :     for index in range(hash_address, len(hash_table)) :       if hash_table[index] == 0 :         hash_table[index] = [index_key, value]         return       elif hash_table[index][0] == index_key :         hash_table[index][1] = value         return   else :     hash_table[hash_address] = [index_key, value]  def read_data(data) :   index_key = get_key(data)   hash_address = hash_function(index_key)   if hash_table[hash_address] != 0 :     for index in range(hash_address, len(hash_table)) :       if hash_table[index] == 0 :         return None       elif hash_table[index][0] == index_key :         return hash_table[index][1]   else :     return None   # 테스트(매번 다름) print(hash('ds') % 8)  # 3 print(hash('db') % 8)  # 3 print(hash('dg') % 8)  # 3  save_data('ds', '01200123123') save_data('db', '3333333333') read_data('ds')  # '01200123123'       - 빈번한 충돌을 개선하는 기법      해시 함수을 재정의 및 해시 테이블 저장공간을 확대   hash_table = list([None for i in range(16)])  def hash_function(key):   return key % 16       4. 해시 함수와 키 생성 함수      파이썬의 hash() 함수는 실행할 때마다, 값이 달라질 수 있음   유명한 해시 함수 : SHA(Secure Hash Algorithm, 안전한 해시 알고리즘)            어떤 데이터도 유일한 고정된 크기의 고정값을 리턴, 해시 함수로 유용하게 활용 가능           - SHA-1   import hashlib  data = 'test'.encode() hash_object = hashlib.sha1() hash_object.update(data) hex_dig = hash_object.hexdigest()  print(hex_dig)  # a94a8fe5ccb19ba61c4c0873d391e987982fbbd3       - SHA-256   import hashlib  data = 'test'.encode() hash_object = hashlib.sha256() hash_object.update(data) hex_dig = hash_object.hexdigest()  print(hex_dig)  # 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08       5. 프로그래밍 연습   연습4 : 연습2의 Chaining 기법을 적용한 해시 테이블 코드에 키 생성 함수를 sha256를 사용하도록 변경      해시 함수 : key % 8   해시 키 생성 : hash(data)   import hashlib  hash_table = list([0 for i in range(8)])  def get_key(data) :   hash_object = hashlib.sha256()   hash_object.update(data.encode())   hex_dig = hash_object.hexdigest()   return int(hex_dig, 16)  def hash_function(key) :   return key % 8  def save_data(data, value) :   index_key = get_key(data)   hash_address = hash_function(index_key)   if hash_table[hash_address] != 0 :     for index in range(hash_address, len(hash_table)) :       if hash_table[index] == 0 :         hash_table[index] = [index_key, value]         return       elif hash_table[index][0] == index_key :         hash_table[index][1] = value         return   else :     hash_table[hash_address] = [index_key, value]  def read_data(data) :   index_key = get_key(data)   hash_address = hash_function(index_key)   if hash_table[hash_address] != 0 :     for index in range(hash_address, len(hash_table)) :       if hash_table[index] == 0 :         return None       elif hash_table[index][0] == index_key :         return hash_table[index][1]   else :     return None   # 테스트 print(get_key('db') % 8)  # 1 print(get_key('da') % 8)  # 2 print(get_key('dh') % 8)  # 2  save_data('da', '01200123123') save_data('dh', '3333333333') read_data('dh')  # '3333333333'       6. 시간 복잡도      일반적인 경우(Collision이 없는 경우)는 O(1)   최악의 경우(Collision이 모두 발생하는 경우)는 O(n)      해시 테이블의 경우, 일반적인 경우를 기대하고 만들기 때문에, O(1)라고 말할 수 있음    검색에서 해시 테이블의 사용 예      16개의 배열에 데이터를 저장하고, 검색할 때 O(n)   16개의 데이터 저장공간을 가진 위의 해시 테이블에 데이터를 저장하고, 검색할 때 O(1)  ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-hashtable/",
        "teaser": null
      },{
        "title": "[Typescript] Interface",
        "excerpt":"1. 인터페이스란?      Javascript에는 존재하지 않는 개념   Typescript 파일에서 작성하고 컴파일해도 Javascript 파일에는 반영되지 않음   어떤 객체가 특정 Property, Method를 가진다고 선언하는 것   타입 체크를 위해 사용   타입을 만들어내는 방식   외부적으로 드러나는 객체의 사용 방식이 적혀있음   # 프로젝트 생성  $ mkdir type-interface $ cd type-interface $ npm init -y $ npm i typescript -D $ npx tsc --init       // interface1.ts  interface Person1 {   name: string;   age: number; }  function hello1(person: Person1): void {   console.log(`안녕하세요! ${person.name} 입니다.`); }  const p1: Person1 = {   name: \"LWW\",   age: 29, };  hello1(p1);  // 안녕하세요! LWW 입니다.       2. Optional Property   // interface2.ts  interface Person2 {   name: string;   age?: number;  // ? -&gt; 있어도되고 없어도 됨 }  function hello2(person: Person2): void {   console.log(`안녕하세요 ${person.name} 입니다. ${person.age}살 입니다.`); }  hello2({name: 'LWW', age: 29});  // 안녕하세요! LWW 입니다. 29살 입니다. hello2({name: 'Tom'});  // // 안녕하세요! Tom 입니다. undefined살 입니다.       // interface3.ts  interface Person3 {   name: string;   age?: number;   [index: string]: any;  // 어떤 이름의 property가 와도 괜찮음 }  function hello3(person: Person3): void {   console.log(`안녕하세요! ${person.name} 입니다.`); }  const p31: Person3 = {   name: \"LWW\",   age: 29, };  const p32: Person3 = {   name: \"Tom\",   systers: [\"Kim\", \"Park\"], };  const p33: Person3 = {   name: \"Amy\",   father: p31,   mother: p32, };  hello3(p31)  // 안녕하세요! LWW 입니다. hello3(p32)  // 안녕하세요! Tom 입니다. hello3(p33)  // 안녕하세요! Amy 입니다.       3. Function in Interface      Interface 안에 Function을 정의하는 방법   // interface4.ts  interface Person4 {   name: string;   age: number;   hello(): void; }  // 방법1 const p41: Person4 = {   name: 'LWW',   age: 29,   hello: function (): void {     console.log(`안녕하세요! ${this.name} 입니다.`);   }, };  // 방법2 const p42: Person4 = {   name: 'LWW',   age: 29,   hello(): void {     console.log(`안녕하세요! ${this.name} 입니다.`);   }, };  // 방법3 const p43: Person4 = {   name: 'LWW',   age: 29,   hello(this: Person4): void {     console.log(`안녕하세요! ${this.name} 입니다.`);   }, };  p41.hello();  // 안녕하세요! LWW 입니다. p42.hello();  // 안녕하세요! LWW 입니다. p43.hello();  // 안녕하세요! LWW 입니다.       4. Class Implements Interface      Interface를 이용해 Class를 만들어내는 방법   // interface5.ts  interface IPerson1 {   name: string;   age?: number;   hello(): void; }  class Person implements IPerson1 {   name: string;   age?: number | undefined;    constructor(name: string) {     this.name = name;   }    hello(): void {     console.log(`안녕하세요! ${this.name} 입니다.`);   } }  const person: IPerson1 = new Person(\"LWW\"); person.hello();  // 안녕하세요! LWW 입니다.       5. Interface extends Interface      Interface를 상속하는 방법   // interface6.ts  interface IPerson2 {   name: string;   age?: number; }  interface IKorean extends IPerson2 {   city: string; }  const k: IKorean = {   name: \"LWW\",   // age: 29,   city: \"서울\", };  HTMLDivElement       6. Function Interface      Function을 Interface로 만드는 방법   // interface7.ts  interface HelloPerson {   (name: string, age?: number): void; }  // Error! 'age' 및 'age' 매개변수의 형식이 호환되지 않습니다. const helloPerson: HelloPerson = function (name: string, age: number) {   console.log(`안녕하세요! ${name} 입니다.`); };  const helloPerson: HelloPerson = function (name: string) {   console.log(`안녕하세요! ${name} 입니다.`); };  helloPerson('LWW', 29);       7. Readonly Interface Property      Interface의 Property에 Readonly 키워드를 사용하는 방법   interface Person8 {   name: string;   age?: number;   readonly gender: string; }  const p81: Person8 = {   name: 'LWW',   gender: 'male', };  p81.gender = 'female';  // Error! 읽기 전용 속성이므로 'gender'에 할당할 수 없음       8. Type alias vs Interface      Type alias는 어떤 타입을 부르는 이름   Interface는 새로운 타입을 만들어 내는 것   // Function  // type alias type EatType = (food: string) =&gt; void;  // interface interface IEat {   (food: string): void; }   // ------------------------------------ // Array  // type alias type PersonList = string[];  // interface interface IPersonList {   [index: number]: string; }   // ------------------------------------ // Intersection  interface ErrorHandling {   success: boolean;   error?: {message: string}; }  interface ArtistsData {   artists: {name: string}[]; }  // type alias type ArtistsResponseType = ArtistsData &amp; ErrorHandling;  let art: ArtistsResponseType;  // interface interface IArtistsResponse extends ArtistsData, ErrorHandling {}  let iar: IArtistsResponse;   // ------------------------------------ // Union types  interface Bird {   fly(): void;   layEggs(): void; }  interface Fish {   swim(): void;   layEggs(): void; }  type PetType = Bird | Fish;  interface IPet extends PetType {}  // Error! TS2312: An interface can only extend ... class Pet implements PetType {}  // Error! TS2422: A class can only implement ...   // ------------------------------------ // Declaration Merging - Interface  // interface interface MergingInterface {   a: string; }  interface MergingInterface {   b: string; }  let mi: MergingInterface; mi.  // a      // b  // type alias type MergingType = {   a: string; };  type MergingType = {  // Error! Duplicate identifier 'MergingType'.   b: string; };  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-interface/",
        "teaser": null
      },{
        "title": "[Data Structure] 트리(Tree)",
        "excerpt":"1. 트리   - 트리 (Tree) 구조      Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조   트리 중 Binary Tree 형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용   - 알아둘 용어      Node : 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)   Root Node : 트리 맨 위에 있는 노드   Level : 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이   Parent Node : 어떤 노드의 다음 레벨에 연결된 노드   Child Node : 어떤 노드의 상위 레벨에 연결된 노드   Leaf Node (Terminal Node) : Child Node가 하나도 없는 노드   Sibling (Brother Node) : 동일한 Parent Node를 가진 노드   Depth : 트리에서 Node가 가질 수 있는 최대 Level              - 이진 트리와 이진 탐색 트리      이진 트리 : 노드의 최대 Branch가 2인 트리   이진 탐색 트리 (Binary Search Tree, BST) : 이진 트리에 다음과 같은 추가적인 조건이 있는 트리            왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가짐                      (출처: https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node)   - 자료 구조 이진 탐색 트리의 장점과 주요 용도      주요 용도 : 데이터 검색(탐색)   장점 : 탐색 속도를 개선할 수 있음   - 이진트리와 정렬된 배열간의 탐색 비교              (출처: https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node)   - 파이썬으로 이진 탐색 트리 구현하기   @1. 노드 클래스 만들기   class Node :   def __init__(self, value) :     self.value = value     self.left = None     self.right = None       @2. 이진 탐색 트리에 데이터 넣기      이진 탐색 트리 조건에 부합하게 데이터를 넣어야 함   class NodeMgmt :   def __init__(self, head) :     self.head = head    def insert(self, value) :     self.current_node = self.head     while True :       if value &lt; self.current_node.value :         if self.current_node.left != None :           self.current_node = self.current_node.left         else :           self.current_node.left = Node(value)           break       else :         if self.current_node.right != None :           self.current_node = self.current_node.right         else :           self.current_node.right = Node(value)           break   # 데이터 넣기 head = Node(1) BST = NodeMgmt(head) BST.insert(2)       @3. 이진 탐색 트리 탐색   class NodeMgmt :   def __init__(self, value) :     self.head = head      def insert(self, value) :     self.current_node = self.head     while True :       if value &lt; self.current_node.value :         if self.current_node.left != None :           self.current_node = self.current_node.left         else :           self.current_node.left = Node(value)           break       else :         if self.current_node.right != None :           self.current_node = self.current_node.right         else :           self.current_node.right = Node(value)           break    def search(self, value) :     self.current_node = self.head     while self.current_node :       if self.current_node.value == value :         return True       elif value &lt; self.current_node.value :         self.current_node = self.current_node.left       else :         self.current_node = self.current_node.right     return False   # 데이터 삽입 head = Node(1) BST = NodeMgmt(head) BST.insert(2) BST.insert(3) BST.insert(0) BST.insert(4) BST.insert(8)  # 데이터 검색 BST.search(2)  # True BST.search(-1)  # False       @4. 이진 탐색 트리 삭제           경우를 나누어서 이해            Leaf Node 삭제             Leaf Node: Child Node 가 없는 Node       삭제할 Node의 Parent Node가 삭제할 Node를 가리키지 않도록 함                         Child Node 가 하나인 Node 삭제            삭제할 Node의 Parent Node가 삭제할 Node의 Child Node를 가리키도록 함                         Child Node 가 두 개인 Node 삭제            삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 함                    삭제할 Node의 오른쪽 자식 선택           오른쪽 자식의 가장 왼쪽에 있는 Node를 선택           해당 Node를 삭제할 Node의 Parent Node의 왼쪽 Branch가 가리키게 함           해당 Node의 왼쪽 Branch가 삭제할 Node의 왼쪽 Child Node를 가리키게 함           해당 Node의 오른쪽 Branch가 삭제할 Node의 오른쪽 Child Node를 가리키게 함           만약 해당 Node가 오른쪽 Child Node를 가지고 있었을 경우에는, 해당 Node의 본래 Parent Node의 왼쪽 Branch가 해당 오른쪽 Child Node를 가리키게 함                       삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 함                      @5. 이진 탐색 트리 삭제 코드 구현과 분석      삭제할 Node 탐색   삭제할 Node가 없는 경우도 처리해야 함   이를 위해 삭제할 Node가 없는 경우는 False를 리턴하고, 함수를 종료 시킴   def delete(self, value) :     searched = False     self.current_node = self.head     self.parent = self.head     while self.current_node :         if self.current_node.value == value :             searched = True             break         elif value &lt; self.current_node.value :             self.parent = self.current_node             self.current_node = self.current_node.left         else :             self.parent = self.current_node             self.current_node = self.current_node.right     if searched == False :         return False          Case 1 : 삭제할 Node가 Leaf Node인 경우          # self.current_node가 삭제할 Node, self.parent는 삭제할 Node의 Parent Node인 상태 if self.current_node.left == None and self.current_node.right == None :     if value &lt; self.parent.value :         self.parent.left == None     else :         self.parent.right == None     del self.current_node          Case 2 : 삭제할 Node가 Child Node를 한 개 가지고 있을 경우          if self.current_node.left != None and self.current_node.right == None :     if value &lt; self.parent.value :         self.parent.left = self.current_node.left     else :         self.parent.right = self.current_node.right elif self.current_node.left == None and self.current_node.right != None :     if value &lt; self.parent.value :         self.parent.left = self.current_node.right     else :         self.parent.right = self.current_node.right          Case 3-1 : 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 왼쪽에 있을 때)   기본 사용 가능 전략            삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 함       삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 함           기본 사용 가능 전략 중, 1번 전략을 사용하여 코드를 구현            Case3-1-1: 삭제할 Node가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 Child Node가 없을 때       Case3-1-2: 삭제할 Node가 Parent Node의 왼쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 오른쪽에 Child Node가 있을 때                    가장 작은 값을 가진 Node의 Child Node가 왼쪽에 있을 경우는 없음, 왜냐하면 왼쪽 Node가 있다는 것은 해당 Node보다 더 작은 값을 가진 Node가 있다는 뜻이기 때문                                  # case 3 if self.current_node.left != None and self.current_node.right != None :     # case 3-1     if value &lt; self.parent.value :         self.change_node = self.current_node.right         self.change_node_parent = self.current_node.right         while self.change_node.left != None :             self.change_node_parent = self.change_node             self.change_node = self.change_node.left         if self.change_node.right != None :             self.change_node_parent.left = self.change_node.right         else :             self.change_node_parent.left = None         self.parent.left = self.change_node         self.change_node.right = self.current_node.right         self.change_node.left = self.change_node.left          Case 3-2 : 삭제할 Node가 Child Node를 두 개 가지고 있을 경우 (삭제할 Node가 Parent Node 오른쪽에 있을 때)   기본 사용 가능 전략            삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 함       삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 함           기본 사용 가능 전략 중, 1번 전략을 사용하여 코드를 구현            Case3-2-1: 삭제할 Node가 Parent Node의 오른쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 Child Node가 없을 때       Case3-2-2: 삭제할 Node가 Parent Node의 오른쪽에 있고, 삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 가진 Node의 오른쪽에 Child Node가 있을 때                    가장 작은 값을 가진 Node의 Child Node가 왼쪽에 있을 경우는 없음, 왜냐하면 왼쪽 Node가 있다는 것은 해당 Node보다 더 작은 값을 가진 Node가 있다는 뜻이기 때문                                  # case 3-2 else :     self.change_node = self.current_node.right     self.change_node_parent = self.current_node.right     while self.change_node.left != None :         self.change_node_parent = self.change_node         self.change_node = self.change_node.left     if self.change_node.right != None :         self.change_node_parent.left = self.change_node.right     else :         self.change_node_parent.left = None     self.parent.right = self.change_node     self.change_node.left = self.current_node.left     self.change_node.right = self.current_node.right          파이썬 전체 코드 구현   class Node :     def __init__(self, value) :         self.value = value         self.left = None         self.right = None          class NodeMgmt :     def __init__(self, head) :         self.head = head      def insert(self, value) :         self.current_node = self.head         while True :             if value &lt; self.current_node.value :                 if self.current_node.left != None :                     self.current_node = self.current_node.left                 else :                     self.current_node.left = Node(value)                     break             else :                 if self.current_node.right != None :                     self.current_node = self.current_node.right                 else :                     self.current_node.right = Node(value)                     break                          def search(self, value) :         self.current_node = self.head         while self.current_node :             if self.current_node.value == value :                 return True             elif value &lt; self.current_node.value :                 self.current_node = self.current_node.left             else :                 self.current_node = self.current_node.right         return False          def delete(self, value) :         # 삭제할 노드 탐색         searched = False         self.current_node = self.head         self.parent = self.head         while self.current_node :             if self.current_node.value == value :                 searched = True                 break             elif value &lt; self.current_node.value :                 self.parent = self.current_node                 self.current_node = self.current_node.left             else :                 self.parent = self.current_node                 self.current_node = self.current_node.right         if searched == False :             return False         # case 1         if self.current_node.left == None and self.current_node.right == None :             if value &lt; self.parent.value :                 self.parent.left = None             else :                 self.parent.right = None         # case 2         elif self.current_node.left != None and self.current_node.right == None :             if value &lt; self.parent.value :                 self.parent.left = self.current_node.left             else :                 self.parent.right = self.current_node.left         elif self.current_node.left == None and self.current_node.right != None :             if value &lt; self.parent.value :                 self.parent.left = self.current_node.right             else :                 self.parent.right = self.current_node.right         # case 3         elif self.current_node.left != None and self.current_node.right != None :             # case 3-1             if value &lt; self.parent.value :                 self.change_node = self.current_node.right                 self.change_node_parent = self.current_node.right                 while self.change_node.left != None :                     self.change_node_parent = self.change_node                     self.change_node = self.change_node.left                 if self.change_node.right != None :                     self.change_node_parent.left = self.change_node.right                 else :                     self.change_node_parent.left = None                 self.parent.left = self.change_node                 self.change_node.right = self.current_node.right                 self.change_node.left = self.change_node.left             # case 3-2             else :                 self.chagne_node = self.current_node.right                 self.change_node_parent = self.current_node.right                 while self.change_node.left != None :                     self.change_node_parent = self.change_node                     self.change_node = self.change_node.left                 if self.change_node.right != None :                     self.change_node_parent.left = self.change_node.right                 else :                     self.change_node_parent.left = None                 self.parent.right = self.change_node                 self.change_node.right = self.current_node.right                 self.change_node.left = self.current_node.left         return True          참고 : http://ejklike.github.io/2018/01/09/traversing-a-binary-tree-1.html   파이썬 전체 코드 테스트            random 라이브러리 활용       random.randint(첫번째 숫자, 마지막 숫자): 첫번째 숫자부터 마지막 숫자 사이에 있는 숫자를 랜덤하게 선택해서 리턴       예: random.randint(0, 99): 0에서 99까지 숫자중 특정 숫자를 랜덤하게 선택해서 리턴해줌           # 0 ~ 999 숫자 중에서 임의로 100개를 추출해서, 이진 탐색 트리에 입력, 검색, 삭제 import random  # 0 ~ 999 중, 100 개의 숫자 랜덤 선택 bst_nums = set() while len(bst_nums) != 100 :     bst_nums.add(random.randint(0, 999))      # print(bst_nums)  # 선택된 100개의 숫자를 이진 탐색 트리에 입력, 임의로 루트노드는 500을 넣기로 함 head = Node(500) binary_tree = NodeMgmt(head) for num in bst_nums :     binary_tree.insert(num)      # 입력한 100개의 숫자 검색 (검색 기능 확인) for num in bst_nums :     if binary_tree.search(num) == False :         print(\"search failed\", num)  # 입력한 100개의 숫자 중 10개의 숫자를 랜덤 선택 delete_nums = set() bst_nums = list(bst_nums) while len(delete_nums) != 10 :     delete_nums.add(bst_nums[random.randint(0, 99)])  # 선택한 10개의 숫자를 삭제 (삭제 기능 확인) for del_num in delete_nums :     if binary_tree.delete(del_num) == False :         print(\"delete failed\", del_num)       - 이진 탐색 트리의 시간 복잡도와 단점   @1. 시간 복잡도 (탐색시)      depth (트리의 높이) 를 h라고 표기한다면, O(h)   n개의 노드를 가진다면, $h = log_2{n} $ 에 가까우므로, 시간 복잡도는 $ O(log{n}) $            참고: 빅오 표기법에서 $log{n}$ 에서의 log의 밑은 10이 아니라, 2       한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미. 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미                      (출처: https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node)       @2. 이진 탐색 트리 단점      평균 시간 복잡도는 $ O(log{n}) $ 이지만, 이는 트리가 균형잡혀 있을 때의 평균 시간복잡도   최악의 경우는 링크드 리스트등과 동일한 성능을 보여줌 ( $O(n)$ )         ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-tree/",
        "teaser": null
      },{
        "title": "[Typescript] Class",
        "excerpt":"1. 클래스란?      Object를 만드는 설계도   클래스 이전에 object를 만드는 기본적인 방법은 function   Javascript에도 class는 ES6부터 사용 가능   OOP을 위한 초석   Typescript에서는 class도 사용자가 만드는 타입의 하나   # 프로젝트 생성  $ mkdir ts-class $ cd ts-class $ npm init -y $ npm i typescript -D $ npx tsc --init       // example.ts  // 간단한 Class 만들기 1 class Person { }  const p1 = new Person(); console.log(p1);  // Person {}       # 컴파일  $ npx tsc $ node example.ts       // example.js  // es5 \"use strict\"; var Person = /** @class */ (function () {     function Person() {     }     return Person; }()); var p1 = new Person(); console.log(p1);       // tsconfig.json  // 컴파일 es6로 변경 \"target\": \"es6\"       // example.js  // es6 \"use strict\"; class Person { } const p1 = new Person(); console.log(p1);       // example.ts  class Person {   name;   constructor(name: string) {     this.name = name;   } }  const p2 = new Person(\"LWW\"); console.log(p2);  // Person { name: 'LWW' }          class 키워드를 이용하여 class를 만들 수 있음   class 이름은 보통 대문자를 이용   new를 이용하여 class를 통해 object를 만들 수 있음   constructor를 이용하여 object를 생성하면서 값을 전달할 수 있음   this를 이용해서 만들어진 object를 가리킬 수 있음   Javascript로 컴파일되면 ES5의 경우 function으로 변경됨       2. Constructor &amp; Initialize      생성자 함수가 없으면, 디폴트 생성자가 불림   개발자가 만든 생성자가 하나라도 있으면, 디폴트 생성자는 사라짐   strict 모드에서 property를 선언하는 곳 또는 생성자에서 값을 할당해야 함   peoperty를 선언하느 곳 또는 생성자에서 값을 할당하지 않는 경우에는 !를 붙여서 위험을 표현   class의 property가 정의되어 있지만, 값을 대입하지 않으면 undefined   생성자에는 async를 설정할 수 없음   // example.ts  class Person {   name: string = 'LWW';   age!: number;    constructor(age?: number) {     if (age === undefined) {       this.age = -1;     } else {       this.age = age;     }   }    async init() {    } }  const p3: Person = new Person(29); const p4: Person = new Person();  console.log(p3);  // Person { name: 'LWW', age: 29 } console.log(p3.age);  // 29 console.log(p4);  // Person { name: 'LWW', age: -1 }       3. 접근 제어자      접근 제어자에는 public, private, protected가 있음   설정하지 않으면 public   클래스 내부의 모든 곳(생성자, 프로퍼티, 메서드)에 설정 가능   private으로 설정하면 클래스 외부에서 접근할 수 없음   Javascript에서는 private를 지원하지 않아 이름 앞에 _를 붙여서 표현했음       4. Initialization in Constructor Parameters      생성자의 Parameter를 받아 그 클래스에 Property로 초기화 하는 방법   // example.ts  class Person {   public constructor(public name: string, private age: number) { } }  const p5: Person = new Person(\"LWW\", 29); console.log(p5);  // Person { name: 'LWW', age: 29 }       4. Getters, Setters   // example.ts  class Person {   public constructor(private _name: string, private age: number) { }    get name() {     console.log('get');     return this._name + \" 입니다.\";   }    set name(n: string) {     console.log('set');     this._name = n;   } }  const p6: Person = new Person(\"LWW\", 29);  // get을 하는 함수 getter console.log(p6.name);  // get                        // LWW 입니다.  // set을 하는 함수 setter p6.name = 'Tom';  // set  console.log(p6.name);  // get                        // Tom 입니다.       5. Readonly Property      Set은 불가, Get만 가능   Initialization 부분과 Constructor 안에서만 readonly property를 지정해 줄 수 있음   다른 메서드 등에서는 Set할 수 없음   Property를 초기값으로 고정하고 다른 값으로 변경하고 싶지 않을 때, readonly를 붙여서 다른 개발자가 Set할 때 에러를 발생시킴   // example.ts  class Person {   public readonly name: string = \"LWW\";   private readonly country: string    public constructor(private _name: string, private age: number) {     this.country = \"Korea\";   }    hello() {     this.country = \"Japan\";  // Error! 읽기 전용 속성이므로 ...   } }  const p6: Person = new Person(\"LWW\", 29);  console.log(p7.name); p7.name = 'Tom';  // Error! 읽기 전용 속성이므로 ... console.log(p7.name);       6. Index Signatures in Class      Class 안에서 Index Signatures를 선언하고 사용하는 방법   Property가 고정된 형태가 아닐 때, 즉 동적으로 들어올 때 사용   // example.ts  class Students {   // [index: string]: string;   [index: string]: \"male\" | \"female\";   LWW: \"male\" = \"male\" }  const a = new Students(); a.LWW = \"male\"; a.Tom = \"male\"; console.log(a)  // Students { LWW: 'male', Tom: 'male' }  const b = new Students(); b.Amy = \"female\"; b.James = \"male\"; b.Anna = \"female\"; console.log(b)  // Students { Amy: 'female', James: 'male', Anna: 'female' }       7. Static Properties &amp; Methods   // example.ts  class Person {   private static CITY = \"Seoul\";    public static sayHello() {     console.log(\"안녕하세요.\")   }   public hello() {     console.log(\"Hi.\", Person.CITY);   }   public change() {     Person.CITY = 'Busan';   } }  const p8 = new Person(); Person.sayHello();  // 안녕하세요. p8.sayHello();  // Error! p8.hello();  // Hi. Seoul  const p9 = new Person(); p9.hello();  // Hi. Seoul p8.change(); p9.hello();  // Hi. Busan       8. Singletons   // example.ts  class ClassName {   private static instance: ClassName | null = null;    public static getInstance(): ClassName {     // ClassName으로부터 만든 object가 있으면 그걸 return     // ClassName으로부터 만든 object가 없으면 만들어서 return     if (ClassName.instance === null) {       ClassName.instance = new ClassName();     }     return ClassName.instance;   }    private constructor() { } }  const a = ClassName.getInstance(); const b = ClassName.getInstance(); const c = new ClassName();  // Error!  console.log(a === b);  // true       9. 상속   // example.ts  // Parent 클래스 class Parent {   constructor(protected _name: string, private _age: number) { }    public print(): void {     console.log(`이름은 ${this._name} 이고, 나이는 ${this._age} 입니다.`);   }    protected printName(): void {     console.log(this._name, this._age);   } }  const p = new Parent(\"LWW\", 29); p._age  // Error! p._name  // Error! p.print();  // 이름은 LWW 이고, 나이는 29 입니다.  // Child 클래스 class Child extends Parent {   public gender = 'female';    constructor(age: number) {     super('LWW Jr.', age);     this.printName();   } }  const c = new Child(5);  // LWW Jr. 5 c._age  // Error! c._name  // Error! c.gender c.print();  // 이름은 LWW Jr. 이고, 나이는 5 입니다.       10. Abstract Classes      상속을 이용해 class를 구조적으로 작성하는데 도움을 줌   // example.ts  abstract class AbstractPerson {   protected _name: string = 'LWW';    abstract setName(name: string): void; }  const p1 = new AbstractPerson()  // Error!  class Person extends AbstractPerson {   setName(name: string): void {     this._name = name;   } }  const p2 = new Person(); console.log(p2);  // Person { _name: 'LWW' } p2.setName('Tom'); console.log(p2);  // Person { _name: 'Tom'}  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-class/",
        "teaser": null
      },{
        "title": "[Data Structure] 힙(Heap)",
        "excerpt":"1. 힙   - 힙 (Heap) 이란?      데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리(Complete Binary Tree)            완전 이진 트리: 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리                         힙을 사용하는 이유            배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 O(n) 이 걸림       이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면, $ O(log n) $ 이 걸림       우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용               - 힙 (Heap) 구조      힙은 최대값을 구하기 위한 구조 (최대 힙, Max Heap)와, 최소값을 구하기 위한 구조 (최소 힙, Min Heap)로 분류   힙은 두 가지 조건을 가지고 있는 자료구조            각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같음 (최대 힙의 경우)                    최소 힙의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 작음                       완전 이진 트리 형태를 가짐           @ 힙과 이진 탐색 트리의 공통점과 차이점      공통점 : 힙과 이진 탐색 트리는 모두 이진 트리   차이점 :            힙은 각 노드의 값이 자식 노드보다 크거나 같음(Max Heap의 경우)       이진 탐색 트리는 왼쪽 자식 노드의 값이 가장 작고, 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼       힙은 이진 탐색 트리의 조건인 자식 노드에서 작은 값은 왼쪽, 큰 값은 오른쪽이라는 조건은 없음                    힙의 왼쪽 및 오른쪽 자식 노드의 값은 오른쪽이 클 수도 있고, 왼쪽이 클 수도 있음                           이진 탐색 트리는 탐색을 위한 구조, 힙은 최대/최소값 검색을 위한 구조              - 힙 (Heap) 동작      데이터를 힙 구조에 삽입, 삭제하는 과정을 그림을 통해 이해   @1. 힙에 데이터 삽입하기 - 기본 동작      힙은 완전 이진 트리이므로, 삽입할 노드는 기본적으로 왼쪽 최하단부 노드부터 채워지는 형태로 삽입              @2. 힙에 데이터 삽입하기 - 삽입할 데이터가 힙의 데이터보다 클 경우      먼저 삽입된 데이터는 완전 이진 트리 구조에 맞추어, 최하단부 왼쪽 노드부터 채워짐   채워진 노드 위치에서, 부모 노드보다 값이 클 경우, 부모 노드와 위치를 바꿔주는 작업을 반복 (swap)              @3. 힙의 데이터 삭제하기 (Max Heap 의 예)      보통 삭제는 최상단 노드 (root 노드)를 삭제하는 것이 일반적            힙의 용도는 최대값 또는 최소값을 root 노드에 놓아서, 최대값과 최소값을 바로 꺼내 쓸 수 있도록 하는 것           상단의 데이터 삭제시, 가장 최하단부 왼쪽에 위치한 노드 (일반적으로 가장 마지막에 추가한 노드)를 root 노드로 이동   root 노드의 값이 child node 보다 작을 경우, root 노드의 child node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복 (swap)              8-4. 힙 구현   @1. 힙과 배열      일반적으로 힙 구현시 배열 자료구조를 활용   배열은 인덱스가 0번부터 시작하지만, 힙 구현의 편의를 위해 root 노드 인덱스 번호를 1로 지정하면, 구현이 좀더 수월   부모 노드 인덱스 번호 (parent node’s index) = 자식 노드 인덱스 번호 (child node’s index) // 2   왼쪽 자식 노드 인덱스 번호 (left child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2   오른쪽 자식 노드 인덱스 번호 (right child node’s index) = 부모 노드 인덱스 번호 (parent node’s index) * 2 + 1          # 예1 - 10 노드의 부모 노드 인덱스 2 // 2  # 1  # 예1 - 15 노드의 왼쪽 자식 노드 인덱스 번호 1 * 2  # 2  # 예1 - 15 노드의 오른쪽 자식 노드 인덱스 번호 2 * 2 + 1  # 5       @2. 힙에 데이터 삽입 구현 (Max Heap 예)      힙 클래스 구현1   class Heap :     def __init__(self, data) :         self.heap_array = list()         self.heap_array.append(None)         self.heap_array.append(data)  # 테스트 heap = Heap(1) heap.heap_array  # [None, 1]          힙 클래스 구현2 - insert1            인덱스 번호는 1번부터 시작하도록 변경                  class Heap:     def __init__(self, data):         self.heap_array = list()         self.heap_array.append(None)         self.heap_array.append(data)              def insert(self, data) :         if len(self.heap_array) == 0 :             self.heap_array.append(None)             self.heap_array.append(data)             return True         self.heap_array.append(data)         return True          힙 클래스 구현3 - insert2            삽입한 노드가 부모 노드의 값보다 클 경우, 부모 노드와 삽입한 노드 위치를 바꿈       삽입한 노드가 루트 노드가 되거나, 부모 노드보다 값이 작거나 같을 경우까지 반복                  class Heap:     def __init__(self, data):         self.heap_array = list()         self.heap_array.append(None)         self.heap_array.append(data)              def move_up(self, inserted_idx) :         if inserted_idx &lt;= 1 :             return False         parent_idx = inserted_idx // 2         if self.heap_array[inserted_idx] &gt; self.heap_array[parent_idx] :             return True         else :             return False              def insert(self, data) :         if len(self.heap_array) == 0 :             self.heap_array.append(None)             self.heap_array.append(data)             return True         self.heap_array.append(data)         inserted_idx = len(self.heap_array) - 1         while self.move_up(inserted_idx) :             parent_idx = inserted_idx // 2             self.heap_array[inserted_idx], self.heap_array[parent_idx] = self.heap_array[parent_idx], self.heap_array[inserted_idx]             inserted_idx = parent_idx         return True   # 테스트 heap = Heap(15) heap.insert(10) heap.insert(8) heap.insert(5) heap.insert(4) heap.insert(20) heap.heap_array  # [None, 20, 10, 15, 5, 4, 8]       @3. 힙에 데이터 삭제 구현 (Max Heap 예)      힙 클래스 구현4 - delete1   보통 삭제는 최상단 노드 (root 노드)를 삭제하는 것이 일반적            힙의 용도는 최대값 또는 최소값을 root 노드에 놓아서, 최대값과 최소값을 바로 꺼내 쓸 수 있도록 하는 것           class Heap:     def __init__(self, data):         self.heap_array = list()         self.heap_array.append(None)         self.heap_array.append(data)          def pop(self) :         if len(self.heap_array) &lt;= 1 :             return None         returned_data = self.heap_array[1]         return returned_data          힙 클래스 구현4 - delete2            상단의 데이터 삭제시, 가장 최하단부 왼쪽에 위치한 노드 (일반적으로 가장 마지막에 추가한 노드) 를 root 노드로 이동       root 노드의 값이 child node 보다 작을 경우, root 노드의 child node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복 (swap)                  class Heap:     def __init__(self, data):         self.heap_array = list()         self.heap_array.append(None)         self.heap_array.append(data)          def move_down(self, popped_idx) :         left_child_popped_idx = popped_idx * 2         right_child_popped_idx = popped_idx * 2 + 1         # case 1 : 자식 노드가 없을 때         if left_child_popped_idx &gt;= len(self.heap_array) :             return False         # case 2 : 왼쪽 자식 노드만 있을 때         elif right_child_popped_idx &gt;= len(self.heap_array) :             if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                 return True             else :                 return False         # case 3 : 왼쪽, 오른쪽 자식 노드가 모두 있을 때         else :             if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx] :                 if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                     return True                 else :                     return False             else :                 if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx] :                     return True                 else :                     return False                  def pop(self) :         if len(self.heap_array) &lt;= 1 :             return None         returned_data = self.heap_array[1]         self.heap_array[1] = self.heap_array[-1]         del self.heap_array[-1]         popped_idx = 1         while self.move_down(popped_idx) :             left_child_popped_idx = popped_idx * 2             right_child_popped_idx = popped_idx * 2 + 1             # case 2 : 왼쪽 자식 노드만 있을 때             if right_child_popped_idx &gt;= len(self.heap_array) :                 if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                     self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]                     popped_idx = left_child_popped_idx             # case 3 : 왼쪽, 오른쪽 자식 노드가 모두 있을 때             else :                 if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx] :                     if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                         self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]                         popped_idx = left_child_popped_idx                 else :                     if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx] :                         self.heap_array[popped_idx], self.heap_array[right_child_popped_idx] = self.heap_array[right_child_popped_idx], self.heap_array[popped_idx]                         popped_idx = right_child_popped_idx         return returned_data       @4. 파이썬 전체 코드   class Heap:     def __init__(self, data):         self.heap_array = list()         self.heap_array.append(None)         self.heap_array.append(data)              def move_up(self, inserted_idx) :         if inserted_idx &lt;= 1 :             return False         parent_idx = inserted_idx // 2         if self.heap_array[inserted_idx] &gt; self.heap_array[parent_idx] :             return True         else :             return False              def move_down(self, popped_idx) :         left_child_popped_idx = popped_idx * 2         right_child_popped_idx = popped_idx * 2 + 1         # case 1 : 자식 노드가 없을 때         if left_child_popped_idx &gt;= len(self.heap_array) :             return False         # case 2 : 왼쪽 자식 노드만 있을 때         elif right_child_popped_idx &gt;= len(self.heap_array) :             if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                 return True             else :                 return False         # case 3 : 왼쪽, 오른쪽 자식 노드가 모두 있을 때         else :             if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx] :                 if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                     return True                 else :                     return False             else :                 if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx] :                     return True                 else :                     return False              def insert(self, data) :         if len(self.heap_array) == 0 :             self.heap_array.append(None)             self.heap_array.append(data)             return True         self.heap_array.append(data)         inserted_idx = len(self.heap_array) - 1         while self.move_up(inserted_idx) :             parent_idx = inserted_idx // 2             self.heap_array[inserted_idx], self.heap_array[parent_idx] = self.heap_array[parent_idx], self.heap_array[inserted_idx]             inserted_idx = parent_idx         return True          def pop(self) :         if len(self.heap_array) &lt;= 1 :             return None         returned_data = self.heap_array[1]         self.heap_array[1] = self.heap_array[-1]         del self.heap_array[-1]         popped_idx = 1         while self.move_down(popped_idx) :             left_child_popped_idx = popped_idx * 2             right_child_popped_idx = popped_idx * 2 + 1             # case 2 : 왼쪽 자식 노드만 있을 때             if right_child_popped_idx &gt;= len(self.heap_array) :                 if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                     self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]                     popped_idx = left_child_popped_idx             # case 3 : 왼쪽, 오른쪽 자식 노드가 모두 있을 때             else :                 if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx] :                     if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx] :                         self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx]                         popped_idx = left_child_popped_idx                 else :                     if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx] :                         self.heap_array[popped_idx], self.heap_array[right_child_popped_idx] = self.heap_array[right_child_popped_idx], self.heap_array[popped_idx]                         popped_idx = right_child_popped_idx         return returned_data   # 테스트 heap = Heap(15) heap.insert(10) heap.insert(8) heap.insert(5) heap.insert(4) heap.insert(20) heap.heap_array  # [None, 20, 10, 15, 5, 4, 8] heap.pop()  # 20 heap.heap_array  # [None, 15, 10, 8, 5, 4]       - 힙 (Heap) 시간 복잡도      depth (트리의 높이) 를 h라고 표기한다면,   n개의 노드를 가지는 heap 에 데이터 삽입 또는 삭제시, 최악의 경우 root 노드에서 leaf 노드까지 비교해야 하므로 $h = log_2{n} $ 에 가까우므로, 시간 복잡도는 $ O(log{n}) $            참고: 빅오 표기법에서 $log{n}$ 에서의 log의 밑은 10이 아니라, 2.       한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미. 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미          ","categories": ["DS"],
        "tags": ["DS","CS","Programming"],
        "url": "/ds/cs-ds-heap/",
        "teaser": null
      },{
        "title": "[Typescript] Generics",
        "excerpt":"1. Generics와 Any의 차이점      Any는 들어오는 input에 대해 다른 타이핑을 할 수 없음   Generics은 타입으로 된 연산이 함수 내에서 가능하게 함   # 프로젝트 생성  $ mkdir ts-generic $ cd ts-generic $ npm init -y $ npm i typescript -D $ npx tsc --init       // generic1.ts  // 많은 반복된 함수들 function helloString(message: string): string {   return message; }  function helloNumber(message: number): number {   return message; }   //--------------------------------------------------------- // any function hello(message: any): any {   return message; }  console.log(hello('LWW').length);  // 3 console.log(hello(29).length);  // undefined   //--------------------------------------------------------- // generic function helloGeneric&lt;T&gt;(message: T): T {   return message; }  console.log(helloGeneric('LWW').length);  // 3 console.log(helloGeneric(29).length);  // Error! console.log(helloGeneric(true));  // true       2. Generics Basic   // generic2.ts  function helloBasic1&lt;T&gt;(message: T): T {   return message; }  // 방법1 -&gt; 지정 helloBasic1&lt;string&gt;('LWW'); helloBasic1&lt;string&gt;(10);  // Error!  // 방법2 -&gt; 추론 helloBasic1(36);   //--------------------------------------------------------- function helloBasic2&lt;T, U&gt;(message: T, comment: U): T {   return message; }  helloBasic2&lt;string, number&gt;('LWW', 29); helloBasic2(10, 20);       3. Generics Array &amp; Tuple   // generic3.ts  // Array function helloArray&lt;T&gt;(message: T[]): T {   return message[0]; }  helloArray(['Hello', 'World']);  // string helloArray(['Hello', 5]);  // string | number   //--------------------------------------------------------- // Tuple function helloTuple&lt;T, K&gt;(message: [T, K]): T {   return message[0]; }  helloTuple(['Hello', 'World']);  // string helloTuple(['Hello', 5]);  // string       4. Generics Function   // generic4.ts  // type alias type HelloFunctionGeneric1 = &lt;T&gt;(message: T) =&gt; T;  const helloFunction1: HelloFunctionGeneric1 = &lt;T&gt;(message: T): T =&gt; {   return message; };   //--------------------------------------------------------- // interface interface HelloFunctionGeneric2 {   &lt;T&gt;(message: T): T }  const helloFunction2: HelloFunctionGeneric2 = &lt;T&gt;(message: T): T =&gt; {   return message; };       5. Generics Class   // generic5.ts  class Person&lt;T, K&gt; {   private _name: T;   private _age: K;    constructor(name: T, age: K) {     this._name = name;     this._age = age;   } }  new Person('LWW', 29); new Person&lt;string, number&gt;('Tom', 'haha');  // Error!       6. Generics with extends      Type을 제한하는 용도로 사용   // generic6.ts  class PersonExtends&lt;T extends string | number&gt; {   private _name: T;    constructor(name: T) {     this._name = name;   } }  new PersonExtends('LWW'); new PersonExtends(29); new PersonExtends(true);  // Error!       7. keyof &amp; type lookup system   // generics.ts  interface IPerson {   name: string;   age: number; }  const person: IPerson = {   name: 'LWW',   age: 29, };  // get function getProp1(obj: IPerson, key: \"name\" | \"age\"): string | number {   return obj[key];  // 에러는 없지만 문제가 발생할 가능성 있음 } // IPerson[keyof IPerson]  // =&gt; IPerson[\"name\" | \"age\"]  // =&gt; IPerson[\"name\"] | IPerson[\"age\"] // =&gt; string | number function getProp2(obj: IPerson, key: keyof IPerson): IPerson[keyof IPerson] {   return obj[key]; } function getProp3&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {   return obj[key]; }  getProp3(person, 'name'); getProp3(person, 'age');   //--------------------------------------------------------- // set function setProp1(obj: IPerson, key: \"name\" | \"age\", value: string | number): void {   obj[key] = value;  // Error! }  function setProp2&lt;T, K extends keyof T&gt;(obj: T, key: K, value: T[K]): void {   obj[key] = value; }  setProp2(person, \"name\", \"Tom\");  ","categories": ["Typescript"],
        "tags": ["Typescript","Programming","Web","Node.js"],
        "url": "/typescript/frontend-typescript-generics/",
        "teaser": null
      },{
        "title": "[SCSS] SCSS 개요, 참조, 중첩",
        "excerpt":"1. SCSS   SCSS 테스트 페이지 https://sassmeister.com      css를 쉽게 사용하기 위해 강력한 기능을 제공하는 도구   css 전처리 도구   css로 변환해서 동작   변수를 만들어서 재활용할 수 있음   중첩 기능 제공   less, stylus보다 더 많이 사용하고 성숙도가 높으며, 안정적인 기능을 제공   sass와 scss 중 표준 css와 호환되는 scss 사용   sass와 scss는 중괄호와 세미콜론의 여부 차이(mixin 제외)   # 프로젝트 생성  $ mkdir scss-test $ cd scss-test $ npm init -y $ npm i -D parcel-bundler       // package.json  \"scripts\": {   \"dev\": \"parcel index.html\",   \"build\": \"parcel build index.html\" },       &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Document&lt;/title&gt;   &lt;link rel=\"stylesheet\" href=\"./main.scss\" /&gt; &lt;/head&gt;  &lt;body&gt;   &lt;div class=\"container\"&gt;     &lt;h1&gt;Hello SCSS!&lt;/h1&gt;   &lt;/div&gt; &lt;/body&gt;       // main.scss  $color: tomato;  .container {   h1 {     color: $color;   } }   Hello SCSS!       2. SCSS 주석      /*  */ : SCSS에서 CSS로 컴파일해도 코드 안에 포함   // : SCSS에서 CSS로 컴파일하면 코드 안에 포함되지 않음       3. 중첩 With SassMeister   &lt;div class=\"container\"&gt;   &lt;ul&gt;     &lt;li&gt;       &lt;div class=\"name\"&gt;LWW&lt;/div&gt;       &lt;div class=\"age\"&gt;43&lt;/div&gt;     &lt;/li&gt;   &lt;/ul&gt; &lt;/div&gt;       /* css */ /* 상위 선택자를 반복적으로 작성해야 함 */  .container &gt; ul li {   font-size: 40px; } .container &gt; ul li .name {   color: royalblue; } .container &gt; ul li .age {   color: orange; }       // scss // 중첩(Nesting)  .container {   &gt; ul {     li {       font-size: 40px;       .name {         color: royalblue;       }       .age {         color: orange;       }     }   } }   LWW 43      4. 상위 선택자 참조      &amp;는 자신이 포함된 영역의 상위 선택자를 참조   // ex 1) scss  .btn {   position: absolute;   &amp;.active {     color: red;   } }  .list {   li {     &amp;:last-child {       margin-right: 0;     }   } }       /* ex 1) css */  .btn {   position: absolute; } .btn.active {   color: red; } .list li:last-child {   margin-right: 0; }       // ex 2) scss  .fs {   &amp;-small { font-size: 12px; }   &amp;-medium { font-size: 14px; }   &amp;-large { font-size: 16px; } }       /* ex 2) css */  .fs-small {   font-size: 12px; } .fs-medium {   font-size: 14px; } .fs-large {   font-size: 16px; }       5. 중첩된 속성      선택자처럼 사용하고, 뒤에 : 기호를 붙임   중괄호가 끝나는 부분에 ; 붙여줌   // scss  .box {   font: {     weight: bold;     size: 10px;     family: sans-serif;   };   margin: {     top: 10px;     left: 20px;   };   padding: {     top: 10px;     bottom: 40px;     left: 20px;     right: 30px;   }; }       /* css */  .box {   font-weight: bold;   font-size: 10px;   font-family: sans-serif;   margin-top: 10px;   margin-left: 20px;   padding-top: 10px;   padding-bottom: 40px;   padding-left: 20px;   padding-right: 30px; }  ","categories": ["SCSS"],
        "tags": ["SCSS","Web","Node.js"],
        "url": "/scss/frontend-scss-start/",
        "teaser": null
      },{
        "title": "[SCSS] SCSS 변수, 연산, 재활용",
        "excerpt":"1. SCSS 변수(Variables)   // scss  $size: 100px;  // 전역변수  .container {   $color: red;  // 지역변수   position: fixed;   top: $size;   .item {     $size: 200px;  // 재할당     color: $color;     width: $size;     height: $size;     transform: translateX($size);   }   left: $size;  // 범위 밖이지만, 재할당된 값으로 바뀜 } .box {   color: $color;  // Error! }       /* css */  .container {   position: fixed;   top: 100px;   left: 200px; } .cotainer .item {   color: red;   width: 200px;   height: 200px;   transform: translateX(100px); }       2. SCSS 연산(Operation)   // scss  div {   width: 20px + 20px;   height: 40px - 10px;   font-size: 10px * 2;   margin: 30px / 2;  // 연산하지 않음(단축 속성)   padding: 20px % 7; } span {   font-size: 10px;   line-height: 10px;   font-family: serif;   font: 10px / 10px serif; // 연산하지 않음(단축 속성) }       /* css */  div {   width: 40px;   height: 30px;   font-size: 20px;   margin: 30px/2;   padding: 6px; } span {   font-size: 10px;   line-height: 10px;   font-family: serif;   font: 10px / 10px serif; }       // scss 나누기 연산  // 방법 1 : 괄호 div {   margin: (30px / 2); }  // 방법 2 : 변수 span {   $size: 30px;   font-size: $size / 2; }  // 방법 3 : 다른 산술연산 포함 h1 {   font-size: 10px + 12px / 2; }       /* css 나눗셈 결과*/  div {   margin: 15px } span {   font-size: 15px } h1 {   font-size: 16px; }       // scss 연산은 단위가 일치해야 함  div {   width: 100% - 200px;  // Error! }  .box {   width: calc(100% - 200px);  // calc 함수 사용 }       3. SCSS 재활용(Mixins)   &lt;div class=\"container\"&gt;   &lt;div class=\"item\"&gt;     Mixin!   &lt;/div&gt; &lt;/div&gt;       .container {   width: 200px;   height: 200px;   background-color: orange;   display: flex;   justify-content: center;   align-items: center; } .container .item {   width: 100px;   height: 100px;   background-color: royalblue; }           Mixin!          // ex 1) scss 재활용  @mixin center {   display: flex;   justify-content: center;   align-items: center; } .container {   @include center;   .item {     @include center;   } } .box {   @include center; }       /* ex 1) css */  .container {   display: flex;   justify-content: center;   align-items: center; } .container .item {   display: flex;   justify-content: center;   align-items: center; } .box {   display: flex;   justify-content: center;   align-items: center; }       // ex 2) scss 재활용($매개변수: 인수)  @mixin box($size: 100px, $color: tomato) {   width: $size;   height: $size;   background-color: $color; } .container {   @include box(200px, red);   .item {     @include box($color: green);  // 키워드 인수   } } .box {   @include box(); }       /* ex 2) css */  .container {   width: 200px;   height: 200px;   background-color: red; } .container .item {   width: 100px;   height: 100px;   background-color: green; } .box {   width: 100px;   height: 100px;   background-color: tomato; }  ","categories": ["SCSS"],
        "tags": ["SCSS","Web"],
        "url": "/scss/frontend-scss-variopermixins/",
        "teaser": null
      },{
        "title": "[SCSS] SCSS 반복문, 함수, 가져오기",
        "excerpt":"1. SCSS 반복문   // for (let i = 0; i &lt; 10; i += 1) { //    console.log(`loop-${i}`) // } // 보간 : #{} // scss  @for $i from 1 through 10 {   .box {     .box:nth-child(#{$i}) {       width: 100px * $i;     }   } }       .box:nth-child(1) {   width: 100px; } .box:nth-child(2) {   width: 200px; } .box:nth-child(3) {   width: 300px; } ... .box:nth-child(10) {   width: 1000px; }       2. SCSS 함수   // scss  @mixin center {   display: flex;   justify-content: center;   align-items: center; }  @function ratio($size, $ratio) {   @return $size * $ratio }  .box {   $width: 100px;   width: $width;   height: ratio($width, 9/16);   @include center; }       /* css */  .box {   width: 160px;   height: 90px;   display: flex;   justify-content: center;   align-items: center; }       3. SCSS 색상 내장 함수   &lt;!-- html --&gt;  &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;div class=\"box built-in\"&gt;&lt;/div&gt;       // scss  .box {   $color: royalblue;   width: 200px;   height: 100px;   margin: 20px;   border-radius: 10px;   background-color: $color;   &amp;:hover {     // mix() -&gt; 두 색을 섞어서 새로운 색을 출력     background-color: mix($color, red);      // lighten() -&gt; 색상을 밝게 만들어 줌     background-color: lighten($color, 10%);      // darken() -&gt; 색상을 어둡게 만들어 줌     background-color: darken($color, 10%);   }   &amp;.built-in {     // saturate() -&gt; 색상의 채도를 올림     background-color: saturate($color, 40%);      // desaturate() -&gt; 색상의 채도를 낮춤     background-color: desaturate($color, 40%);      // grayscale() -&gt; 색상을 회색으로 만들어 줌     background-color: graysclae($color);      // invert() -&gt; 색상을 반전시킴     background-color: invert($color);      // rgba() -&gt; 색상을 반투명하게 함     background-color: rgba($color, .5);   } }       4. SCSS 가져오기   &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Document&lt;/title&gt;   &lt;link rel=\"stylesheet\" href=\"./main.scss\" /&gt; &lt;/head&gt;  &lt;body&gt;   &lt;div class=\"container\"&gt;     &lt;h1&gt;Hello SCSS!!&lt;/h1&gt;   &lt;/div&gt; &lt;/body&gt;       // main.scss  // 간소화된 문법(url 함수, 확장자 표기 안해도 작동) @import \"./sub\", \"./sub2\";  $color: royalblue;  .container {   h1 {     color: $color;   } }   // sub.scss  body {   .container {     background-color: orange;   } }   // sub2.scss  body {   background-color: royalblue; }  ","categories": ["SCSS"],
        "tags": ["SCSS","Web"],
        "url": "/scss/frontend-scss-forfuncimport/",
        "teaser": null
      },{
        "title": "[SCSS] SCSS 데이터 종류, @each, @content",
        "excerpt":"1. SCSS 데이터 종류   // scss  $number: 1;  // .5, 100px, 1em $string: bold;  // relative, \"../images/a.png\" $color: red;  // blue, #FFFF00, rgba(0,0,0,.1) $boolean: true;  // false $null: null; $list: orange, royalblue, yellow; $map: (   o: orange,   r: royalblue,   y: yellow ); .box {   width: 100px;   color: red;   position: null; }       /* css */  .box {   width: 100px;   color: red; }       2. 반복문 @each   // scss  $list: orange, royalblue, yellow; $map: (   o: orange,   r: royalblue,   y: yellow );  @each $c in $list {   .box1{     color: $c;   } }  @each $key, $value in $map {   .box2-#{$k} {     color: $v;   } }       /* css */  .box1 {   color: orange; } .box1 {   color: royalblue; } .box1 {   color: yellow; } .box2-o {   color: orange; } .box2-r {   color: royalblue; } .box2-y {   color: yellow; }       3. 재활용 @content   // scss  @mixin left-top {   position: absolute;   top: 0;   left: 0;   @content; } .container {   width: 100px;   height: 100px;   @include left-top; } .box {   width: 200px;   height: 300px;   @include left-top {     bottom: 0;     right: 0;     margin: auto;   } }       /* css */  .container {   width: 100px;   height: 100px;   position: absolute;   top: 0;   left: 0;  } .box {   width: 200px;   height: 300px;   position: absolute;   top: 0;   left: 0;   bottom: 0;   right: 0;   margin: auto;   }  ","categories": ["SCSS"],
        "tags": ["SCSS","Web"],
        "url": "/scss/frontend-scss-dataeachcontent/",
        "teaser": null
      },{
        "title": "[Algorithm] 버블 정렬(Bubble Sort)",
        "excerpt":"1. 버블 정렬 (Bubble Sort)   - 정렬이란?      정렬 : 어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 것   정렬은 프로그램 작성시 빈번하게 필요로 함   다양한 알고리즘이 고안되었으며, 알고리즘 학습의 필수      다양한 정렬 알고리즘 이해를 통해, 동일한 문제에 대해 다양한 알고리즘이 고안될 수 있음을 이해하고, 각 알고리즘간 성능 비교를 통해, 알고리즘 성능 분석에 대해서도 이해할 수 있음    - 버블 정렬이란?      두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘   직접 눈으로 보기 : https://visualgo.net/en/sorting                 출처: https://en.wikipedia.org/wiki/Bubble_sort    - 어떻게 코드로 만들까?      알고리즘 연습 방법에 기반해서 단계별로 생각       데이터가 네 개 일때 : data_list = [1, 9, 3, 2]            1차 로직 적용                    1 와 9 비교, 자리바꿈없음 [1, 9, 3, 2]           9 와 3 비교, 자리바꿈 [1, 3, 9, 2]           9 와 2 비교, 자리바꿈 [1, 3, 2, 9]                       2차 로직 적용                    1 와 3 비교, 자리바꿈없음 [1, 3, 2, 9]           3 과 2 비교, 자리바꿈 [1, 2, 3, 9]           3 와 9 비교, 자리바꿈없음 [1, 2, 3, 9]                       3차 로직 적용                    1 과 2 비교, 자리바꿈없음 [1, 2, 3, 9]           2 과 3 비교, 자리바꿈없음 [1, 2, 3, 9]           3 과 9 비교, 자리바꿈없음 [1, 2, 3, 9]                               2. 알고리즘 구현      특이점 찾아보기            n개의 리스트가 있는 경우 최대 n-1번의 로직을 적용       로직을 1번 적용할 때마다 가장 큰 숫자가 뒤에서부터 1개씩 결정       로직이 경우에 따라 일찍 끝날 수도 있음. 따라서 로직을 적용할 때 한 번도 데이터가 교환된 적이 없다면 이미 정렬된 상태이므로 더 이상 로직을 반복 적용할 필요가 없음                         for num in range(len(data_list)) 반복   swap = 0 (교환이 되었는지를 확인하는 변수를 둠)   반복문 안에서, for index in range(len(data_list) - num - 1) n - 1번 반복해야 하므로   반복문안의 반복문 안에서, if data_list[index] &gt; data_list[index + 1] 이면   data_list[index], data_list[index + 1] = data_list[index + 1], data_list[index]   swap += 1   반복문 안에서, if swap == 0 이면, break 끝   def bubble_sort(data) :   swap = False   for i in range(len(data) - 1) :     for j in range(len(data) - i - 1) :       if data[j] &gt; data[j + 1] :         data[j], data[j + 1] = data[j + 1], data[j]         swap = True     if swap == False :       break   return data   # 테스트 import random  data_list = random.sample(range(100), 10) print(bubble_sort(data_list))  # [8, 24, 39, 40, 63, 68, 69, 77, 86, 91]       3. 알고리즘 분석      반복문이 두 개 O($n^2$)   최악의 경우, $\\frac { n * (n - 1)}{ 2 }$   완전 정렬이 되어 있는 상태라면 최선은 O(n)  ","categories": ["Algorithm"],
        "tags": ["Algorithm","CS","Programming"],
        "url": "/algorithm/cs-algorithm-bubblesort/",
        "teaser": null
      },{
        "title": "[Algorithm] 선택 정렬(Selection Sort)",
        "excerpt":"1. 선택 정렬 (Selection Sort)   - 선택 정렬이란?      다음과 같은 순서를 반복하며 정렬하는 알고리즘            주어진 데이터 중, 최소값을 찾음       해당 최소값을 데이터 맨 앞에 위치한 값과 교체       맨 앞의 위치를 뺀 나머지 데이터를 동일한 방법으로 반복           직접 눈으로 보기 https://visualgo.net/en/sorting             출처: https://en.wikipedia.org/wiki/Selection_sort    - 어떻게 코드로 만들까?      데이터가 두 개 일때 : data_list = [9, 1]            data_list[0] &gt; data_list[1] 이므로 data_list[0] 값과 data_ list[1] 값을 교환           데이터가 세 개 일때 : data_list = [9, 1, 7]            처음 한번 실행하면, 1, 9, 7 이 됨       두 번째 실행하면, 1, 7, 9 가 됨           데이터가 네 개 일때 : data_list = [9, 3, 2, 1]            처음 한번 실행하면, 1, 3, 2, 9 가 됨       두 번째 실행하면, 1, 2, 3, 9 가 됨       세 번째 실행하면, 변화 없음               2. 알고리즘 구현      for stand in range(len(data_list) - 1) 로 반복   lowest = stand 로 놓고,   for num in range(stand, len(data_list)) stand 이후부터 반복            내부 반복문 안에서 data_list[lowest] &gt; data_list[num] 이면,                    lowest = num                           data_list[num], data_list[lowest] = data_list[lowest], data_list[num]   def selection_sort(data) :   for stand in range(len(data) - 1) :     lowest = stand     for i in range(stand + 1, len(data)) :       if data[lowest] &gt; data[i] :         lowest = i     data[lowest], data[stand] = data[stand], data[lowest]   return data   # 테스트 import random  data_list = random.sample(range(100), 10) selection_sort(data_list)  # [1, 5, 36, 41, 55, 67, 68, 91, 95, 98]       3. 알고리즘 분석      반복문이 두 개 O($n^2$)   실제로 상세하게 계산하면, $\\frac { n * (n - 1)}{ 2 }$  ","categories": ["Algorithm"],
        "tags": ["Algorithm","CS","Programming"],
        "url": "/algorithm/cs-algorithm-selectionsort/",
        "teaser": null
      },{
        "title": "[Algorithm] 삽입 정렬(Insertion Sort)",
        "excerpt":"1. 삽입 정렬 (Insertion Sort)   - 삽입 정렬이란?      삽입 정렬은 두 번째 인덱스부터 시작   해당 인덱스(key 값) 앞에 있는 데이터(B)부터 비교해서 key 값이 더 작으면, B값을 뒤 인덱스로 복사   이를 key 값이 더 큰 데이터를 만날때까지 반복, 그리고 큰 데이터를 만난 위치 바로 뒤에 key 값을 이동   직접 눈으로 보기 : https://visualgo.net/en/sorting             출처: https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif    - 어떻게 코드로 만들까?      데이터가 네 개 일때 : data_list = [9, 3, 2, 5]            처음 한번 실행하면, key값은 9, 인덱스(0) - 1 은 0보다 작으므로 끝 : [9, 3, 2, 5]       두 번째 실행하면, key값은 3, 9보다 3이 작으므로 자리 바꾸고, 끝 : [3, 9, 2, 5]       세 번째 실행하면, key값은 2, 9보다 2가 작으므로 자리 바꾸고, 다시 3보다 2가 작으므로 끝 : [2, 3, 9, 5]       네 번째 실행하면, key값은 5, 9보다 5이 작으므로 자리 바꾸고, 3보다는 5가 크므로 끝 : [2, 3, 5, 9]               2. 알고리즘 구현      for stand in range(len(data_list)) 로 반복   key = data_list[stand]   for num in range(stand, 0, -1) 반복            내부 반복문 안에서 data_list[stand] &lt; data_list[num - 1] 이면,                    data_list[num - 1], data_list[num] = data_list[num], data_list[num - 1]                           def insertion_sort(data) :   for i in range(len(data) - 1) :     for j in range(i + 1, 0, -1) :       if data[j] &lt; data[j - 1] :         data[j], data[j - 1] = data[j - 1], data[j]       else :         break   return data   # 테스트 import random  data_list = random.sample(range(100), 10) print(insertion_sort(data_list))  # [13, 40, 58, 64, 79, 86, 92, 94, 95, 99]       3. 알고리즘 분석      반복문이 두 개 O($n^2$)   최악의 경우, $\\frac { n * (n - 1)}{ 2 }$   완전 정렬이 되어 있는 상태라면 최선은 O(n)      참고 코드 : https://goo.gl/XKBXuk   ","categories": ["Algorithm"],
        "tags": ["Algorithm","CS","Programming"],
        "url": "/algorithm/cs-algorithm-Insertionsort/",
        "teaser": null
      },{
        "title": "[Algorithm] 공간 복잡도",
        "excerpt":"1. 공간 복잡도      알고리즘 계산 복잡도는 다음 두 가지 척도로 표현될 수 있음            시간 복잡도: 얼마나 빠르게 실행되는지       공간 복잡도: 얼마나 많은 저장 공간이 필요한지              좋은 알고리즘은 실행 시간도 짧고, 저장 공간도 적게 쓰는 알고리즘       통상 둘 다를 만족시키기는 어려움            시간과 공간은 반비례적 경향이 있음       최근 대용량 시스템이 보편화되면서, 공간 복잡도보다는 시간 복잡도가 우선       그래서 알고리즘은 시간 복잡도가 중심           공간 복잡도 대략적인 계산 필요   기존 알고리즘 문제는 예전에 공간 복잡도도 고려되어야할 때 만들어진 경우가 많음   그래서 기존 알고리즘 문제에 시간 복잡도뿐만 아니라, 공간 복잡도 제약 사항이 있는 경우가 있음   또한, 기존 알고리즘 문제에 영향을 받아서, 면접시에도 공간 복잡도를 묻는 경우도 있음   Complexity     expected worst-case time complexity : O(N)   expected worst-case space complexity : O(N)      현업에서 최근 빅데이터를 다룰 때는 저장 공간을 고려해서 구현을 하는 경우도 있음    - 공간 복잡도 (Space Complexity)      프로그램을 실행 및 완료하는데 필요한 저장공간의 양   총 필요 저장 공간            고정 공간 (알고리즘과 무관한 공간): 코드 저장 공간, 단순 변수 및 상수       가변 공간 (알고리즘 실행과 관련있는 공간): 실행 중 동적으로 필요한 공간       $ S(P) = c + S_p(n) $                    c : 고정 공간           $ S_p(n) $ : 가변 공간                              빅 오 표기법을 생각해볼 때, 고정 공간은 상수이므로 공간 복잡도는 가변 공간에 좌우됨    - 공간 복잡도 계산      공간 복잡도 계산은 알고리즘에서 실제 사용되는 저장 공간을 계산하면 됨            이를 빅 오 표기법으로 표현할 수 있으면 됨               2. 공간 복잡도 예제 1      n! 팩토리얼 구하기            n! = 1 x 2 x … x n           n의 값에 상관없이 변수 n, 변수 fac, 변수 index 만 필요함   공간 복잡도는 O(1)      공간 복잡도 계산은 실제 알고리즘 실행시 사용되는 저장공간을 계산하면 됨    def factorial(n) :   fac = 1   for index in range(2, n+1) :     fac = fac * index   return fac   factorial(3)  # 6       3. 공간 복잡도 예제 2      n! 팩토리얼 구하기            n! = 1 x 2 x … x n           재귀함수를 사용하였으므로, n에 따라, 변수 n이 n개가 만들어지게 됨            factorial 함수를 재귀 함수로 1까지 호출하였을 경우, n부터 1까지 스택에 쌓이게 됨           공간 복잡도는 O(n)   def factorial(n) :   if n &gt; 1 :     return n * factorial(n - 1)   else :     return 1   factorial(3)  # 6  ","categories": ["Algorithm"],
        "tags": ["Algorithm","CS","Programming"],
        "url": "/algorithm/cs-algorithm-spacecomplexity/",
        "teaser": null
      },{
        "title": "[Algorithm] 재귀 용법(Recursive Call)",
        "excerpt":"1. 재귀 용법 (recursive call, 재귀 호출)      함수 안에서 동일한 함수를 호출하는 형태   여러 알고리즘 작성시 사용   - 재귀 용법 예제      팩토리얼을 구하는 알고리즘을 Recursive Call을 활용해서 알고리즘 작성   간단한 경우부터 생각            2! = 1 X 2       3! = 1 X 2 X 3       4! = 1 X 2 X 3 X 4 = 4 X 3!           규칙 : n! = n X (n - 1)!            함수를 만들어 봄       함수(n) 은 n &gt; 1 이면 return n X 함수(n - 1)       함수(n) 은 n = 1 이면 return n           검증 (코드로 검증하지 않고, 직접 간단한 경우부터 대입해서 검증)            먼저 2! 부터                    함수(2) 이면, 2 &gt; 1 이므로 2 X 함수(1)           함수(1) 은 1 이므로, return 2 X 1 = 2                       먼저 3! 부터                    함수(3) 이면, 3 &gt; 1 이므로 3 X 함수(2)           함수(2) 는 결국 1번에 의해 2! 이므로, return 2 X 1 = 2           3 X 함수(2) = 3 X 2 = 3 X 2 X 1 = 6                       먼저 4! 부터                    함수(4) 이면, 4 &gt; 1 이므로 4 X 함수(3)           함수(3) 은 결국 2번에 의해 3 X 2 X 1 = 6           4 X 함수(3) = 4 X 6 = 24                           코드 레벨로 적어보기   def factorial(num) :      if num &gt; 1 :         return num * factorial(num - 1)     else :         return num   for num in range(10) :   print(factorial(num))  # 0                          # 1                          # 2                          # 6                          # ...                          # 362880          시간 복잡도와 공간 복잡도            factorial(n) 은 n - 1 번의 factorial() 함수를 호출해서, 곱셈을 함                    n-1번 반복문을 호출한 것과 동일           factorial() 함수를 호출할 때마다, 지역변수 n 이 생성                       시간 복잡도/공간 복잡도는 O(n-1) 이므로 결국, 둘 다 O(n)               - 재귀 호출의 일반적인 형태   # 일반적인 형태1  def function(입력) :     if 입력 &gt; 일정값 :  # 입력이 일정 값 이상이면         return function(입력 - 1)  # 입력보다 작은 값     else :         return 일정값, 입력값, 또는 특정값  # 재귀 호출 종료   # ------------------------------------------------------------ # 일반적인 형태2  def function(입력) :     if 입력 &lt;= 일정값 :  # 입력이 일정 값보다 작으면         return 일정값, 입력값, 또는 특정값  # 재귀 호출 종료     function(입력보다 작은 값)     return 결과값       def factorial(num) :     if num &lt;= 1 :         return num     return_value = num * factorial(num - 1)     return return_value   for num in range(10) :     print(factorial(num))  # 0                            # 1                            # 2                            # 6                            # ...                            # 362880          재귀 호출은 스택의 전형적인 예            함수는 내부적으로 스택처럼 관리                     코드분석      참고: 파이썬에서 재귀 함수는 깊이가(한번에 호출되는) 1000회 이하        2. 재귀 용법을 활용한 프로그래밍 연습   프로그래밍 연습  다음 함수를 재귀 함수를 활용해서 1부터 num까지의 곱이 출력되게 만들기    def muliple(data):     if data &lt;= 1:         return data          return -------------------------      multiple(10)   # 단순 반복문 def multiple(num) :     return_value = 1     for index in range(1, num+1) :         return_value = return_value * index     return return_value   # ------------------------------------------------------------ # 재귀 용법 def multiple(num) :     if num &lt;= 1 :         return num     return num * multiple(num - 1)    multiple(10)  # 3628800       프로그래밍 연습  숫자가 들어 있는 리스트가 주어졌을 때, 리스트의 합을 리턴하는 함수를 만들기 (재귀함수 사용)    참고 : 임의 값으로 리스트 만들기 random.sample(0 ~ 99까지 중에서, 임의로 10개를 만들어서 10개 값을 가지는 리스트 변수 만들기 import random  data = random.sample(range(100), 10)    def sum_list(data):     if len(data) == 1:         return data[0]          return --------------------------------  import random  data = random.sample(range(100), 10) print (sum_list(data))   import random  data = random.sample(range(100), 10) print(data)  # [63, 1, 47, 6, 81, 74, 59, 75, 84, 51]  def sum_list(data) :     if len(data) &lt;= 1 :         return data[0]     return data[0] + sum_list(data[1:])   sum_list(data)  # 541       프로그래밍 연습  회문(palindrome)은 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 의미  회문을 판별할 수 있는 함수를 재귀함수를 활용해서 만들기       참고 - 리스트 슬라이싱 string = 'Dave'  string[-1] --&gt; e string[0] --&gt; D string[1:-1] --&gt; av string[:-1] --&gt; Dav   def palindrome(string) :     if len(string) &lt;= 1 :         return True     if string[0] == string[-1] :         return palindrome(string[1:-1])     else :         return False   palindrome('level')  # True palindrome('love')  # False       프로그래밍 연습      정수 n에 대해    n이 홀수이면 3 X n + 1 을 하고,    n이 짝수이면 n 을 2로 나눔    이렇게 계속 진행해서 n 이 결국 1이 될 때까지 2와 3의 과정을 반복    예를 들어 n에 3을 넣으면,   3 10 5 16 8 4 2 1  이 됨   이렇게 정수 n을 입력받아, 위 알고리즘에 의해 1이 되는 과정을 모두 출력하는 함수를 작성   def func(n) :     print(n)     if n == 1 :         return n     if n % 2 == 1 :         return func((3 * n) + 1)     else :         return func(int(n / 2))   func(3)  # 3          # 10          # 5          # 16          # 8          # 4          # 2          # 1           # 1       프로그래밍 연습    문제: 정수 4를 1, 2, 3의 조합으로 나타내는 방법은 다음과 같이 총 7가지가 있음 1+1+1+1 1+1+2 1+2+1 2+1+1 2+2 1+3 3+1 정수 n이 입력으로 주어졌을 때, n을 1, 2, 3의 합으로 나타낼 수 있는 방법의 수를 구하시오   힌트: 정수 n을 만들 수 있는 경우의 수를 리턴하는 함수를 f(n) 이라고 하면,  f(n)은 f(n-1) + f(n-2) + f(n-3) 과 동일하다는 패턴 찾기  출처: ACM-ICPC &gt; Regionals &gt; Asia &gt; Korea &gt; Asia Regional - Taejon 2001       문제 분석을 연습장에 작성          def func(data) :     if data == 1 :         return 1     elif data == 2 :         return 2     elif data == 3 :         return 4     return func(data - 1) + func(data - 2) + func(data - 3)   func(5)  # 13  ","categories": ["Algorithm"],
        "tags": ["Algorithm","CS","Programming"],
        "url": "/algorithm/cs-algorithm-recursivecall/",
        "teaser": null
      },{
        "title": "[Bootstrap] 개요",
        "excerpt":"1. Bootstrap이란?      동적인 웹 사이트 및 웹 응용 개발을 위한 프론트엔드 프레임워크   UI를 따로 구현하지 않아도 미리 정의된 컴포넌트를 자신의 프로젝트에 적용할 수 있음   5.0 버전부터 Tree Shaking을 지원            단일 번들을 최적화할 때 사용       필요하지 않은 코드를 제거하는 기술               2. CDN 프로젝트 생성   Bootstrap   # 프로젝트 생성  $ mkdir bootstrap-test $ cd bootstrap-test $ code .       &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Document&lt;/title&gt;   &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We\" crossorigin=\"anonymous\"&gt;   &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/head&gt;  &lt;body&gt;   &lt;div class=\"dropdown\"&gt;     &lt;button class=\"btn btn-secondary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton1\" data-bs-toggle=\"dropdown\"       aria-expanded=\"false\"&gt;       Dropdown button     &lt;/button&gt;     &lt;ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton1\"&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/div&gt; &lt;/body&gt;  ","categories": ["Bootstrap"],
        "tags": ["Bootstrap","Web"],
        "url": "/bootstrap/frontend-bootstrap-start/",
        "teaser": null
      },{
        "title": "[Bootstrap] 버튼, 드롭다운",
        "excerpt":"1. Bootstrap 버튼, 버튼 그룹   Bootstrap 버튼   &lt;!-- index.html --&gt; &lt;body&gt;   &lt;!-- 버튼 그룹 --&gt;   &lt;div class=\"btn-group\"&gt;      &lt;!-- 기본 버튼 --&gt;     &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Primary&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-secondary\"&gt;Secondary&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-success\"&gt;Success&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-danger\"&gt;Danger&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-warning\"&gt;Warning&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-info\"&gt;Info&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-light\"&gt;Light&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-dark\"&gt;Dark&lt;/button&gt;     &lt;button type=\"button\" class=\"btn btn-link\"&gt;Link&lt;/button&gt;          &lt;!-- 아웃라인 버튼 --&gt;     &lt;div class=\"btn btn-outline-primary\"&gt;ABC&lt;/div&gt;     &lt;div class=\"btn btn-outline-success\"&gt;ABC&lt;/div&gt;      &lt;!-- 버튼 사이즈 --&gt;     &lt;div class=\"btn btn-primary btn-lg\"&gt;ABC&lt;/div&gt;     &lt;div class=\"btn btn-primary btn-sm\"&gt;ABC&lt;/div&gt;      &lt;!-- 버튼 비활성화 --&gt;     &lt;div class=\"btn btn-primary btn-lg\" disabled&gt;ABC&lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;       2. Bootstrap 드롭다운, 리스트   Bootstrap 드롭다운   Bootstrap 리스트 그룹   &lt;body&gt;   &lt;div class=\"dropdown\"&gt;     &lt;button class=\"btn btn-secondary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton1\" data-bs-toggle=\"dropdown\"       aria-expanded=\"false\"&gt;       Dropdown button     &lt;/button&gt;     &lt;ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton1\"&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/div&gt;    &lt;ul class=\"list-group\"&gt;     &lt;li class=\"list-group-item list-group-item-action\"&gt;An item&lt;/li&gt;     &lt;li class=\"list-group-item list-group-item-action active\"&gt;A second item&lt;/li&gt;     &lt;li class=\"list-group-item list-group-item-action\"&gt;A third item&lt;/li&gt;     &lt;li class=\"list-group-item list-group-item-action\"&gt;A fourth item&lt;/li&gt;     &lt;li class=\"list-group-item list-group-item-action\"&gt;And a fifth one&lt;/li&gt;   &lt;/ul&gt; &lt;/body&gt;  ","categories": ["Bootstrap"],
        "tags": ["Bootstrap","Web"],
        "url": "/bootstrap/frontend-bootstrap-buttondrop/",
        "teaser": null
      },{
        "title": "[Bootstrap] 양식, 모달, 툴팁",
        "excerpt":"1. Bootstrap 양식   Bootstrap 양식      사용자에게 데이터를 입력받는 양식 제공       2. Bootstrap 모달   Bootstrap 모달   &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;!-- Button trigger modal --&gt;   &lt;button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#exampleModal\"&gt;     Launch demo modal   &lt;/button&gt;    &lt;!-- Modal --&gt;   &lt;div class=\"modal fade\" id=\"exampleModal\" tabindex=\"-1\" aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\"&gt;     &lt;div class=\"modal-dialog\"&gt;       &lt;div class=\"modal-content\"&gt;         &lt;div class=\"modal-header\"&gt;           &lt;h5 class=\"modal-title\" id=\"exampleModalLabel\"&gt;Modal title&lt;/h5&gt;           &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"&gt;&lt;/button&gt;         &lt;/div&gt;         &lt;div class=\"modal-body\"&gt;           &lt;form&gt;             &lt;div class=\"mb-3\"&gt;               &lt;label for=\"exampleInputEmail1\" class=\"form-label\"&gt;Email address&lt;/label&gt;               &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" aria-describedby=\"emailHelp\"&gt;               &lt;div id=\"emailHelp\" class=\"form-text\"&gt;We'll never share your email with anyone else.&lt;/div&gt;             &lt;/div&gt;             &lt;div class=\"mb-3\"&gt;               &lt;label for=\"exampleInputPassword1\" class=\"form-label\"&gt;Password&lt;/label&gt;               &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\"&gt;             &lt;/div&gt;             &lt;div class=\"mb-3 form-check\"&gt;               &lt;input type=\"checkbox\" class=\"form-check-input\" id=\"exampleCheck1\"&gt;               &lt;label class=\"form-check-label\" for=\"exampleCheck1\"&gt;Check me out&lt;/label&gt;             &lt;/div&gt;           &lt;/form&gt;         &lt;/div&gt;         &lt;div class=\"modal-footer\"&gt;           &lt;button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\"&gt;Close&lt;/button&gt;           &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Submit&lt;/button&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;       // main.js  // modal창 활성화 시, email 입력 form에 focus 하는 기능 const emailInputEl = document.querySelector('#exampleInputEmail1') const modalEl = document.querySelector('#exampleModal')  modalEl.addEventListener('shown.bs.modal', function () {   emailInputEl.focus() })       3. Bootstrap 툴팁   Bootstrap 툴팁      성능상의 이유로 포함되어 있지 않기 때문에, 직접 초기화해야 함   &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;button type=\"button\" class=\"btn btn-secondary\" data-bs-toggle=\"tooltip\" data-bs-placement=\"top\"     title=\"Tooltip on top\"&gt;     Tooltip on top   &lt;/button&gt;   &lt;button type=\"button\" class=\"btn btn-secondary\" data-bs-toggle=\"tooltip\" data-bs-placement=\"right\"     title=\"Tooltip on right\"&gt;     Tooltip on right   &lt;/button&gt;   &lt;button type=\"button\" class=\"btn btn-secondary\" data-bs-toggle=\"tooltip\" data-bs-placement=\"bottom\"     title=\"Tooltip on bottom\"&gt;     Tooltip on bottom   &lt;/button&gt;   &lt;button type=\"button\" class=\"btn btn-secondary\" data-bs-toggle=\"tooltip\" data-bs-placement=\"left\"     title=\"Tooltip on left\"&gt;     Tooltip on left   &lt;/button&gt; &lt;/body&gt;       // main.js  // 직접 초기화 var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')) var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {   return new bootstrap.Tooltip(tooltipTriggerEl) })  ","categories": ["Bootstrap"],
        "tags": ["Bootstrap","Web"],
        "url": "/bootstrap/frontend-bootstrap-formodaltool/",
        "teaser": null
      },{
        "title": "[Bootstrap] 커스터마이징, 성능 최적화",
        "excerpt":"1. NPM 프로젝트 생성      Bootstrap에서 사용자가 필요로하는 기능만 가지고 올 수 있음   기본적인 테마를 입맛에 맞게 커스터마이징 할 수 있음   $ npm init -y $ npm i -D parcel-bundler $ npm i bootstrap@next       // package.json  \"scripts\": {   \"dev\": \"parcel index.html\",   \"build\": \"parcel build index.html\" },       &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Document&lt;/title&gt;   &lt;link rel=\"stylesheet\" href=\"./scss/main.scss\"&gt;   &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt; &lt;/head&gt;  &lt;body&gt;   &lt;div class=\"dropdown\"&gt;     &lt;button class=\"btn btn-secondary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton1\" data-bs-toggle=\"dropdown\"       aria-expanded=\"false\"&gt;       Dropdown button     &lt;/button&gt;     &lt;ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton1\"&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/div&gt; &lt;/body&gt;       // scss/main.scss  @import \"../node_modules/bootstrap/scss/bootstrap\";       // main.js  import bootstrap from 'bootstrap/dist/js/bootstrap.bundle'       2. 테마 색상 커스터마이징   Bootstrap 색상 커스터마이징   &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;div class=\"dropdown\"&gt;     &lt;button class=\"btn btn-secondary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton1\" data-bs-toggle=\"dropdown\"       aria-expanded=\"false\"&gt;       Dropdown button     &lt;/button&gt;     &lt;ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton1\"&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/div&gt;    &lt;div class=\"spinner-border text-secondary\" role=\"status\"&gt;     &lt;span class=\"visually-hidden\"&gt;Loading...&lt;/span&gt;   &lt;/div&gt; &lt;/body&gt;       // scss/main.scss  @import \"../node_modules/bootstrap/scss/functions\"; @import \"../node_modules/bootstrap/scss/variables\"; @import \"../node_modules/bootstrap/scss/mixins\";  $theme-colors: (   \"primary\":    $primary,   \"secondary\":  royalblue,  // 색상 변경   \"success\":    $success,   \"info\":       $info,   \"warning\":    $warning,   \"danger\":     $danger,   \"light\":      $light,   \"dark\":       $dark );  @import \"../node_modules/bootstrap/scss/bootstrap\";       3. 성능 최적화   Bootstrap 성능 최적화   &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;div class=\"dropdown\"&gt;     &lt;button class=\"btn btn-secondary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton1\" data-bs-toggle=\"dropdown\"       aria-expanded=\"false\"&gt;       Dropdown button     &lt;/button&gt;     &lt;ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton1\"&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt;       &lt;li&gt;&lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt;   &lt;/div&gt;    &lt;div class=\"spinner-border text-secondary\" role=\"status\"&gt;     &lt;span class=\"visually-hidden\"&gt;Loading...&lt;/span&gt;   &lt;/div&gt;    &lt;!-- Button trigger modal --&gt;   &lt;button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#exampleModal\"&gt;     Launch demo modal   &lt;/button&gt;    &lt;!-- Modal --&gt;   &lt;div class=\"modal fade\" id=\"exampleModal\" tabindex=\"-1\" aria-labelledby=\"exampleModalLabel\" aria-hidden=\"true\"&gt;     &lt;div class=\"modal-dialog\"&gt;       &lt;div class=\"modal-content\"&gt;         &lt;div class=\"modal-header\"&gt;           &lt;h5 class=\"modal-title\" id=\"exampleModalLabel\"&gt;Modal title&lt;/h5&gt;           &lt;button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"&gt;&lt;/button&gt;         &lt;/div&gt;         &lt;div class=\"modal-body\"&gt;           ...         &lt;/div&gt;         &lt;div class=\"modal-footer\"&gt;           &lt;button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\"&gt;Close&lt;/button&gt;           &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Save changes&lt;/button&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/body&gt;       // main.js  // 개별 속성 import import Dropdown from 'bootstrap/js/dist/dropdown' import Modal from 'bootstrap/js/dist/modal'  // 초기화 코드 const dropdownElementList = [].slice.call(document.querySelectorAll('.dropdown-toggle')) dropdownElementList.map(function (dropdownToggleEl) {   return new Dropdown(dropdownToggleEl) })  // 초기화 코드 new Modal(document.querySelector('#exampleModal'), {   backdrop: 'static'  // 배경을 클릭하면 모달이 꺼지지 않도록 함 })  ","categories": ["Bootstrap"],
        "tags": ["Bootstrap","Web","Node.js"],
        "url": "/bootstrap/frontend-bootstrap-customtree/",
        "teaser": null
      },{
        "title": "[Bundler] Parcel Static, Autoprefixer",
        "excerpt":"1. Bundler 개요      웹에서는 HTML, CSS, Javascript가 동작   순수하게 HTML, CSS, Javascript로 코딩하는 것은 비효율적   따라서 다양한 기능들을 이용해 웹 개발을 하는데, 그것들은 웹에서 직접적으로 동작하지 않음   그것을 변환하는 과정을 거져 HTML, CSS, Javascript로 바꿔서 웹에서 동작시킴   즉, Vue.js, React, Sass 등을 Bundler를 통해 웹에서 동작시킬 수 있는 형태로 바꿀 수 있음   Bundler 자체가 이해해서 변환해주는 것이 아니라 외부의 패키지의 도움을 받아 변환   수동의 작업을 Bundler에게 위임   Parcel : 구성 없는 단순한 자동 번들링, 소/중형 프로젝트에 적합   Webpack : 매우 꼼꼼한 구성, 중/대형 프로젝트에 적합          2. 프로젝트 시작   # 프로젝트 생성  $ mkdir parcel-template-basic $ cd parcel-template-basic $ npm init -y $ npm i -D parcel-bundler       // package.json  \"scripts\": {   \"dev\": \"parcel index.html\",   \"build\": \"parcel build index.html\" }       &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Parcel Bundler&lt;/title&gt;   &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css\"&gt;  &lt;!-- reset.css cdn--&gt;   &lt;link rel=\"stylesheet\" href=\"./scss/main.scss\"&gt;   &lt;script defer src=\"./js/main.js\"&gt;&lt;/script&gt; &lt;/head&gt;  &lt;body&gt;   &lt;h1&gt;Hello Parcel!!&lt;/h1&gt; &lt;/body&gt;       // scss/main.scss  $color--black: #000; $color--white: #fff;  body {   background-color: $color--black;   h1 {     color: $color--white;   } }       // js/main.js  console.log('Hello Parcel!')              3. 정적 파일 연결   https://www.icoconverter.com/에서 원하는 이미지 변경      원본 이미지와 변환된 이미지를 프로젝트 폴더 루트 경로에 복사   원본 이미지는 images 폴더를 생성하고 이 폴더에 넣어줌          &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;h1&gt;Hello Parcel!!&lt;/h1&gt;   &lt;img src=\"./images/bear.jpg\" alt=\"Bear\" /&gt; &lt;/body&gt;          Favicon이 정상적으로 출력되지 않음   웹에서 확인하는 HTML 파일은 dist폴더에 있는 HTML 파일임   그것을 만들어내는 용도로 루트 경로에 있는 index.html 파일을 Parcel-Bundler가 사용   즉, favicon.ico파일을 dist 폴더로 넣어주면 됨   하지만 dist폴더는 언제든지 지울 수 있어야 하기 때문에 파일을 dist 폴더에 직접적으로 넣는 방식은 좋지 않음   따라서 해당하는 파일을 개발서버를 열거나 제품화시킬때 dist폴더로 자동으로 넣어줄 수 있는 패키지의 도움을 받아야 함   https://www.npmjs.com/package/parcel-plugin-static-files-copy에 접속해서 내용 확인   # terminal  $ npm i -D parcel-plugin-static-files-copy       // package.json  \"staticFiles\": {   \"staticPath\": \"static\" }          루트 경로에 static 폴더를 만들고 favicon.ico 파일을 넣어줌             dist 파일에 favicon.ico 파일이 복사됨             Favicon 출력 확인   $ npm run dev       4. Autoprefixer      Autoprefixer는 공급 업체 접두사(Vender Prefix)를 자동으로 붙여줄 수 있는 패키지   CSS 스타일 보험   Vender Prefix는 모든 브라우저에서 CSS의 기능을 동일하게 사용하기 위하여 브라우저의 제조사별 접두어를 CSS에 표기하는 것   # terminal  npm i -D postcss autoprefixer       // package.json  // 현재 NPM 프로젝트에서 지원할 브라우저의 범위를 명시하는 용도 // 이 명시를 Autoprefixer 패키지가 활용 \"browserslist\": [   \"&gt; 1%\",  // 점유율이 1% 이상인 모든 브라우저   \"last 2 versions\"  // 해당하는 브라우저의 마지막 2개 버전 ]       // .postcssrc.js // 뒤에 rc(Runtime Configuration)가 붙은 파일은 구성 파일을 의미  // ESM : 브라우저 환경에서 동작 // CommonJS : Node.js 환경 동작  // import autoprefixer from 'autoprefixer' const autoprefixer = require('autoprefixer')  // export { //   plugins: [ //     autoprefixer //   ] // } module.exports = {   plugins: [     autoprefixer   ] }   // --------------------------------------------------------- // 간소화 module.exports = {   plugins: [     require('autoprefixer')   ] }       // scss/main.scss  $color--black: #000; $color--white: #fff;  body {   background-color: $color--black;   h1 {     color: $color--white;     display: flex;   } }       # terminal  $ npm run dev          Autoprefixer와 Postcss의 버전이 충돌하는 경우   # terminal  $ npm i -D autoprefixer@9 $ npm run dev         ","categories": ["Bundler"],
        "tags": ["Bundler","Web","Node.js","Parcel"],
        "url": "/bundler/frontend-bundler-parcelstaticautopre/",
        "teaser": null
      },{
        "title": "[Github 블로그] Favicon 등록",
        "excerpt":"1. Github 블로그 Favicon 등록하기   https://favicon.io/emoji-favicons에 접속해 필요한 Favicon 압축파일을 다운로드 받음          다운받은 파일의 압축을 풀고, 내 블로그 폴더의 index.html 파일이 있는 최상위 루트 경로에 파일을 옮김(about.txt파일 제외)          https://realfavicongenerator.net에 접속해 Select your Favicon image 버튼을 클릭하고 이미지를 업로드함                 페이지 맨 하단에 Generate your Favicons and HTML code를 클릭          HTML 태그가 나오면, 복사해서 블로그 폴더의 _include/head/custom.html에 붙여넣기                        Github에 업로드   $ git add . $ git commit -m \"commit message\" $ git push origin master       반영된 Favicon 확인          2. 원하는 이미지 ICO 파일로 변경   https://www.icoconverter.com/에 접속해 원하는 이미지를 등록하고 변환할 수 있음(32 pixels면 충분)     ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/etc-blog-favicon/",
        "teaser": null
      },{
        "title": "[Bundler] Parcel Babel, CLI",
        "excerpt":"1. Babel      컴파일러   최신의 문법으로 만든 Javascript 코드를 구형 브라우저에서도 동작할 수 있는 ES5 버전으로 컴파일 해줌   # terminal  npm i -D @babel/core @babel/preset-env  # async, await 등 비동기 문법 동작용 패키지 npm i -D @babel/plugin-transform-runtime         // package.json  \"browserslist\": [   \"&gt; 1%\",  // 점유율이 1% 이상인 모든 브라우저   \"last 2 versions\"  // 해당하는 브라우저의 마지막 2개 버전 ]       // .babelrc.js  module.exports = {   presets: ['@babel/preset-env'],   plugins: [     ['@babel/plugin-transform-runtime']   ] }       // js/main.js  console.log('Hello Parcel!')  async function test() {   const promise = Promise.resolve(123)   console.log(await promise) }  test()       # terminal  $ npm run dev              2. CLI   https://ko.parceljs.org/cli.html에서 내용 확인      빠른 모듈 교체(HMR) : 런타임에서 페이지 새로고침 없이 수정된 내용을 자동으로 갱신   // package.json    \"scripts\": {     // 포트 번호 변경     \"dev\": \"parcel index.html --port 7777\",     \"build\": \"parcel build index.html\"   },       $ npm run dev  # localhost:7777  ","categories": ["Bundler"],
        "tags": ["Bundler","Web","Node.js","Parcel"],
        "url": "/bundler/frontend-bundler-parcelbabelcli/",
        "teaser": null
      },{
        "title": "[Bundler] Webpack Entry, Output, Plugins",
        "excerpt":"1. 프로젝트 시작   # 프로젝트 생성  $ mkdir webpack-template-basic $ cd webpack-template-basic $ npm init -y $ npm i -D webpack webpack-cli webpack-dev-server@next       // package.json  \"scripts\": {   \"dev\": \"webpack-dev-server --mode development\",   \"build\": \"webpack --mode production\" },  \"devDependencies\": {   \"webpack\": \"^5.51.1\",  // Bundler가 동작하기 위한 핵심 패키지   \"webpack-cli\": \"^4.8.0\",  // CLI를 지원하는 패키지   \"webpack-dev-server\": \"^4.0.0-rc.1\"  // 페이지 자동 새로고침 패키지 }       &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Hello Webpack!&lt;/title&gt;   &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css\"&gt; &lt;!-- reset.css --&gt; &lt;/head&gt;  &lt;body&gt;   &lt;h1&gt;Hello Webpack!!&lt;/h1&gt; &lt;/body&gt;       // js/main.js  console.log('Webpack!')       2. Entry, Output   // webpack.config.js  // import const path = require('path')  // path 전역 모듈  // export module.exports = {   entry: './js/main.js',  // 파일을 읽어들이기 시작하는 진입점 설정   output: {    // 결과물(Bundle)을 반환하는 설정     // path: path.resolve(__dirname, 'dist'),     // filename: 'main.js',     clean: true  // 새롭게 build 했을 때, 기존에 필요하지 않은 파일을 제거   } }       # terminal  $ npm run build       3. Plugins   # terminal  $ npm i -D html-webpack-plugin       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin')  module.exports = {   entry: './js/main.js',   output: {     clean: true   },    // 번들링 후 결과물의 처리 방식 등 다양한 플러그인들을 설정   plugins: [     new HtmlPlugin({       template: './index.html'     })   ],   devServer: {     host: 'localhost'   } }       # terminal  $ npm run dev         ","categories": ["Bundler"],
        "tags": ["Bundler","Web","Node.js","Webpack"],
        "url": "/bundler/frontend-bundler-webpackenouplug/",
        "teaser": null
      },{
        "title": "[Bundler] Webpack Static, Module, SCSS",
        "excerpt":"1. 정적 파일 연결   https://www.icoconverter.com/에서 원하는 이미지 변경      원본 이미지와 변환된 이미지를 프로젝트 폴더 루트 경로에 복사   static 폴더를 생성하고 favicon.ico와 원본 이미지를 이 폴더에 넣어줌   static 폴더 안에 images 폴더를 생성하고 원본 이미지를 이 폴더에 넣어줌              &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;h1&gt;Hello Webpack!!&lt;/h1&gt;   &lt;img src=\"./images/bear.jpg\" alt=\"Bear\"&gt; &lt;/body&gt;       # terminal  $ npm i -D copy-webpack-plugin       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin') const CopyPlugin = require('copy-webpack-plugin')  module.exports = {   entry: './js/main.js',   output: {     clean: true   },   plugins: [     new HtmlPlugin({       template: './index.html'     }),     // static 폴더 안의 내용이 copy되어 dist폴더로 들어가는 plugin     new CopyPlugin({       patterns: [         { from: 'static' }       ]     })   ],   devServer: {     host: 'localhost'   } }       # terminal  $ npm run dev       2. Module   static 폴더 안에 css 폴더 생성하고 main.css 파일 생성   /* static/css/main.css */  body {   background-color: orange; }       &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Hello Webpack!&lt;/title&gt;   &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/reset-css@5.0.1/reset.min.css\"&gt;   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt; &lt;/head&gt;       # terminal  $ npm run dev       루트 경로에 css 폴더 생성하고 main.css 파일 생성   /* css/main.css */  body {   background-color: orange; }       // js/main.js  import '../css/main.css'  console.log('Webpack!')       CSS 파일을 읽을 수 있는 패키지 설치   # terminal  $ npm i -D css-loader style-loader       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin') const CopyPlugin = require('copy-webpack-plugin')  module.exports = {   entry: './js/main.js',   output: {     clean: true   },   module: {     rules: [       {         test: /\\.css$/,  // .css로 끝나는 파일         use: [  // 순서 중요!!           'style-loader',  // HTML의 style 태그에 해석된 내용을 삽입하는 용도           'css-loader'  // Javascript에서 css파일을 해석하는 용도         ]       }     ]   },   plugins: [     new HtmlPlugin({       template: './index.html'     }),     new CopyPlugin({       patterns: [         { from: 'static' }       ]     })   ],   devServer: {     host: 'localhost'   } }       # terminal  $ npm run dev       3. SCSS   루트 경로에 scss 폴더 생성하고 main.scss 파일 생성   # terminal  $ npm i -D sass-loader sass       /* scss/main.css */  $color--black: #000; $color--white: #fff;  body {   background-color: $color--black;   h1 {     color: $color--white;     font-size: 50px;   } }       // js/main.js  import '../scss/main.scss'  console.log('Webpack!')       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin') const CopyPlugin = require('copy-webpack-plugin')  module.exports = {   entry: './js/main.js',   output: {     clean: true   },   module: {     rules: [       {         test: /\\.s?css$/,  // .scss or .css로 끝나는 파일         use: [           'style-loader',           'css-loader',           'sass-loader'  // Webpack에서 scss파일을 읽어내는 용도         ]       }     ]   },   plugins: [     new HtmlPlugin({       template: './index.html'     }),     new CopyPlugin({       patterns: [         { from: 'static' }       ]     })   ],   devServer: {     host: 'localhost'   } }       # terminal  $ npm run dev         ","categories": ["Bundler"],
        "tags": ["Bundler","Web","Node.js","Webpack"],
        "url": "/bundler/frontend-bundler-webpackstaticmodulescss/",
        "teaser": null
      },{
        "title": "[Bundler] Webpack Autoprefixer, Babel",
        "excerpt":"1. Autoprefixer      Autoprefixer는 공급 업체 접두사(Vender Prefix)를 자동으로 붙여줄 수 있는 패키지   CSS 스타일 보험   Vender Prefix는 모든 브라우저에서 CSS의 기능을 동일하게 사용하기 위하여 브라우저의 제조사별 접두어를 CSS에 표기하는 것   # terminal  $ npm i -D postcss autoprefixer postcss-loader       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin') const CopyPlugin = require('copy-webpack-plugin')  module.exports = {   entry: './js/main.js',   output: {     clean: true   },    module: {     rules: [       {         test: /\\.s?css$/,         use: [           'style-loader',           'css-loader',           'postcss-loader',  // sass-loader롤 통해 해석된 내용에 공급업체 접두사를 적용하는 용도           'sass-loader'         ]       }     ]   },   plugins: [     new HtmlPlugin({       template: './index.html'     }),     new CopyPlugin({       patterns: [         { from: 'static' }       ]     })   ],   devServer: {     host: 'localhost'   } }       // package.json  \"browserslist\": [   \"&gt; 1%\",  // 점유율이 1% 이상인 모든 브라우저   \"last 2 versions\"  // 해당하는 브라우저의 마지막 2개 버전 ]       // .postcssrc.js  module.exports = {   plugins: [     require('autoprefixer')   ] }       // scss/main.scss  $color--black: #000; $color--white: #fff;  body {   background-color: $color--black;   h1 {     color: $color--white;     font-size: 50px;     display: flex;   } }       # terminal  $ npm run dev                 2. Babel      컴파일러   최신의 문법으로 만든 Javascript 코드를 구형 브라우저에서도 동작할 수 있는 ES5 버전으로 컴파일 해줌   # terminal  $ npm i -D @babel/core @babel/preset-env @babel/plugin-transform-runtime $ npm i -D babel-loader       // .babelrc.js  module.exports = {   presets: ['@babel/preset-env'],   plugins: [     ['@babel/plugin-transform-runtime']   ] }       // package.json  \"browserslist\": [   \"&gt; 1%\",  // 점유율이 1% 이상인 모든 브라우저   \"last 2 versions\"  // 해당하는 브라우저의 마지막 2개 버전 ]       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin') const CopyPlugin = require('copy-webpack-plugin')  module.exports = {   entry: './js/main.js',   output: {     clean: true   },   module: {     rules: [       {         test: /\\.s?css$/,         use: [           'style-loader',           'css-loader',           'postcss-loader',           'sass-loader'         ]       },       {         test: /\\.js$/,  // .js로 끝나는 파일         use: [           'babel-loader'  // Webpack에서 js파일을 읽어내는 용도         ]       }     ]   },   plugins: [     new HtmlPlugin({       template: './index.html'     }),     new CopyPlugin({       patterns: [         { from: 'static' }       ]     })   ],   devServer: {     host: 'localhost'   } }  ","categories": ["Bundler"],
        "tags": ["Bundler","Web","Node.js","Webpack"],
        "url": "/bundler/frontend-bundler-webpackautoprebabel/",
        "teaser": null
      },{
        "title": "[Bundler] NPX, Degit",
        "excerpt":"NPX, Degit      npx는 Node.js에서 쓸 수 있는 명령으로, degit을 설치하지 않고 동작시킬 수 있음   degit은 Github에 있는 원격 저장소를 현재 경로에 다운로드   버전관리가 되어있지 않은 상태이기 때문에 처음부터 다시 버전관리가 가능            npx degit : 버전관리가 없는 새로운 프로젝트 다운로드       git clone : 해당하는 저장소가 가지고 있는 버전의 내역까지 가지고 옴           # terminal  # $ npx degit Github계정이름/저장소이름 폴더이름 $ npx degit LeeWonWoo1/webpack-template-basic webpack-template-test  $ cd webpack-template-test $ code . -r  ","categories": ["Bundler"],
        "tags": ["Bundler","Web","Git","Github"],
        "url": "/bundler/frontend-bundler-npxdegit/",
        "teaser": null
      },{
        "title": "[Algorithm] 동적 계획법(DP), 분할 정복(DC)",
        "excerpt":"1. 동적 계획법과 분할 정복   - 동적 계획법(Dynamic Programming)      입력 크기가 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서, 보다 큰 크기의 부분 문제를 해결, 최종적으로 전체 문제를 해결하는 알고리즘   상향식 접근법으로, 가장 최하위 해답을 구한 후, 이를 저장하고, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식   Memoization 기법을 사용함            Memoization (메모이제이션) 이란: 프로그램 실행 시 이전에 계산한 값을 저장하여, 다시 계산하지 않도록 하여 전체 실행 속도를 빠르게 하는 기술           문제를 잘게 쪼갤 때, 부분 문제는 중복되어, 재활용됨            예 : 피보나치 수열               -  분할 정복(Divide and Conquer)      문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘   하양식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식            일반적으로 재귀함수로 구현           문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않음            예: 병합 정렬, 퀵 정렬 등               - 공통점과 차이점      공통점            문제를 잘게 쪼개서, 가장 작은 단위로 분할           차이점            동적 계획법                    부분 문제는 중복되어, 상위 문제 해결 시 재활용됨           Memoization 기법 사용 (부분 문제의 해답을 저장해서 재활용하는 최적화 기법으로 사용)                       분할 정복                    부분 문제는 서로 중복되지 않음           Memoization 기법 사용 안함                               2. 동적 계획법 알고리즘   프로그래밍 연습  피보나치 수열: n 을 입력받아서 다음과 같이 계산  n 을 입력받았을 때 피보나치 수열로 결과값을 출력        함수를 fibonacci 라고 하면, fibonacci(0):0 fibonacci(1):1 fibonacci(2):1 fibonacci(3):2 fibonacci(4):3 fibonacci(5):5 fibonacci(6):8 fibonacci(7):13 fibonacci(8):21 fibonacci(9):34          - Recursive Call 활용   def fibo(num) :     if num &lt;= 1 :         return num     return fibo(num - 1) + fibo(num - 2)   fibo(4)  # 3       - 동적 계획법 활용   def fibo_dp(num) :     cache = [0 for index in range(num + 1)]     cache[0] = 0     cache[1] = 1     for index in range(2, num+1) :         cache[index] = cache[index - 1] + cache[index - 2]     return cache[num]   fibo_dp(10)  # 55       실행 코드를 보며 이해 : 코드분석  ","categories": ["Algorithm"],
        "tags": ["Algorithm","CS","Programming"],
        "url": "/algorithm/cs-algorithm-dpdc/",
        "teaser": null
      },{
        "title": "[Algorithm] 퀵 정렬(Quick Sort)",
        "excerpt":"1. 퀵 정렬(Quick Sort)      정렬 알고리즘의 꽃   기준점(pivot)을 정해서, pivot보다 작은 데이터는 왼쪽, 큰 데이터는 오른쪽으로 모으는 함수를 작성   각 왼쪽, 오른쪽은 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복   함수는 왼쪽 + pivot + 오른쪽을 리턴   - 어떻게 코드로 만들까?   프로그래밍 연습  다음 리스트를 리스트 슬라이싱을 이용해서 세 개로 짤라서 각 리스트 변수에 넣고 출력해보기     data_list = [1, 2, 3, 4, 5] 출력: print (data1) print (data2) print (data3) [1, 2] 3 [4, 5]   data_list = [1, 2, 3, 4, 5] data1 = data_list[:2] data2 = data_list[2] data3 = data_list[3:]  print(data1)  # [1, 2] print(data2)  # 3 print(data3)  # [4, 5]       프로그래밍 연습  다음 리스트를 맨 앞에 데이터를 기준으로 작은 데이터는 left 변수에, 그렇지 않은 데이터는 right 변수에 넣기     data_list = [4, 1, 2, 5, 7]   data_list = [4, 1, 2, 5, 7] pivot = data_list[0] left, right = list(), list()  for i in range(1, len(data_list)) :     if pivot &gt; data_list[i] :         left.append(data_list[i])     else :         right.append(data_list[i])  print(left)  # [1, 2] print(pivot)  # 4 print(right)  # [5, 7]       프로그래밍 연습  data_list 가 임의 길이일 때 리스트를 맨 앞에 데이터를 기준으로 작은 데이터는 left 변수에, 그렇지 않은 데이터는 right 변수에 넣기     import random  data_list = random.sample(range(100), 10)  left = list() right = list() pivot = data_list[0]  for index in range(1, -----------------):     if data_list[index] &lt; pivot:         left.append(data_list[index])     else:         right.append(data_list[index])   import random data_list = random.sample(range(100), 10)  left, right = list(), list() pivot = data_list[0]  for i in range(1, len(data_list)) :     if pivot &gt; data_list[i] :         left.append(data_list[i])     else :         right.append(data_list[i])          print(left)  # [2, 21] print(pivot)  # 22 print(right)  # [31, 24, 55, 40, 26, 97, 78]       2. 알고리즘 구현      quicksort 함수 만들기            만약 리스트 갯수가 한개이면 해당 리스트 리턴       그렇지 않으면, 리스트 맨 앞의 데이터를 pivot으로 놓기       left, right 리스트 변수를 만들고,       맨 앞의 데이터를 뺀 나머지 데이터를 pivot과 비교                    pivot보다 작으면 left.append(해당 데이터)           pivot보다 크면 right.append(해당 데이터)                       return quicksort(left) + pivot + quicksort(right) 로 재귀 호출              리스트로 만들어서 리턴 : return quick_sort(left) + [pivot] + quick_sort(right)    def qsort(data) :     if len(data) &lt;= 1 :         return data     left, right = list(), list()     pivot = data[0]     for index in range(1, len(data)) :         if pivot &gt; data[index] :             left.append(data[index])         else :             right.append(data[index])     return qsort(left) + [pivot] + qsort(right)   # 테스트 import random  data_list = random.sample(range(100), 10) qsort(data_list)  # [8, 15, 34, 38, 39, 42, 69, 70, 77, 82]       프로그래밍 연습  위 퀵정렬 코드를 파이썬 list comprehension을 사용해서 더 깔끔하게 작성해보기    def qsort(data) :     if len(data) &lt;= 1 :         return data     pivot = data[0]     left = [item for item in data[1:] if pivot &gt; item]     right = [item for item in data[1:] if pivot &lt;= item]     return qsort(left) + [pivot] + qsort(right)   # 테스트 import random  data_list = random.sample(range(100), 10) qsort(data_list)  # [6, 53, 57, 61, 65, 81, 90, 92, 93, 94]       3. 알고리즘 분석      병합정렬과 유사, 시간복잡도는 O(nlogn)   단, 최악의 경우            맨 처음 pivot이 가장 크거나, 가장 작으면       모든 데이터를 비교하는 상황이 나옴       O($n^2$)                 ","categories": ["Algorithm"],
        "tags": ["Algorithm","CS","Programming"],
        "url": "/algorithm/cs-algorithm-quicksort/",
        "teaser": null
      },{
        "title": "[Vue.js] 개요, 시작",
        "excerpt":"1. Vue.js란?      사용자 인터페이스를 만들기 위한 프로그레시브 프레임워크   점진적 채택할 수 있도록 설계   다른 라이브러리나 기존 프로젝트와의 통합이 쉬움   현대적 도구 및 지원 라이브러리와 함께 사용하면 정교한 단일 페이지 응용프로그램을 완벽하게 지원할 수 있음   반응성이 뛰어남       2. Vue.js 시작 방법   - CDN      프로토 타이핑 또는 학습 목적으로 사용할 시 CDN으로 간편하게 사용   &lt;!-- html --&gt;  &lt;script src=\"https://unpkg.com/vue@next\"&gt;&lt;/script&gt; &lt;div id=\"app\"&gt;   &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt;       // js  Vue.createApp({   data() {     return {       message: 'Hello Vue!'     }   } }).mount('#app')       - CLI      단일 페이지 App을 빠르게 구축할 수 있는 공식 CLI 제공   # terminal  $ npm i -g @vue/cli $ vue create vue3-test 버전 선택 $ cd vue3-test $ code .          코드 가독성을 위해 Vetur 확장 프로그램 설치      // App.vue 구성  // HTML &lt;template&gt;   &lt;img alt=\"Vue logo\" src=\"./assets/logo.png\"&gt;   &lt;HelloWorld msg=\"Welcome to Your Vue.js App\"/&gt;  // 제거하고 시작 &lt;/template&gt;  // JavaScript &lt;script&gt; import HelloWorld from './components/HelloWorld.vue'  export default {   name: 'App',   components: {     HelloWorld   } } &lt;/script&gt;  // CSS &lt;style&gt; #app {   font-family: Avenir, Helvetica, Arial, sans-serif;   -webkit-font-smoothing: antialiased;   -moz-osx-font-smoothing: grayscale;   text-align: center;   color: #2c3e50;   margin-top: 60px; } &lt;/style&gt;       - Webpack   # terminal  $ npx degit LeeWonWoo1/webpack-template-basic vue3-webpack-template $ cd vue3-webpack-template $ code . -r $ npm i vue@next $ npm i -D vue-loader@next vue-style-loader @vue/compiler-sfc       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin') const CopyPlugin = require('copy-webpack-plugin') const { VueLoaderPlugin } = require('vue-loader')  module.exports = {   resolve: {     extensions: ['.js', '.vue']  // js, vue 확장자를 명시하지 않아도 에러 발생 막음   },   entry: './src/main.js',   output: {     clean: true   },   module: {     rules: [       {         test: /\\.vue$/,  // .vue로 끝나는 파일         use: 'vue-loader'  // Webpack에서 vue 파일을 읽어내는 용도       },       {         test: /\\.s?css$/,         use: [           // 순서 중요!           'vue-style-loader',  // Vue 파일 내의 style 태그를 해석해서 동작시키는 용도           'style-loader',           'css-loader',           'postcss-loader',           'sass-loader'         ]       },       {         test: /\\.js$/,         use: [           'babel-loader'         ]       }     ]   },   plugins: [     new HtmlPlugin({       template: './index.html'     }),     new CopyPlugin({       patterns: [         { from: 'static' }       ]     }),     new VueLoaderPlugin()  // 생성자 함수로 호출   ],   devServer: {     host: 'localhost'   } }          루트 경로에 src 폴더를 생성하고   src 폴더 안에 main.js 파일 만들기   src 폴더 안에 App.vue 파일 만들기   기존 js 폴더는 삭제   // App.vue  &lt;template&gt;   &lt;h1&gt;&lt;/h1&gt; &lt;/template&gt;  &lt;script&gt; export default {   data() {     return {       message: \"Hello Vue!!\",     };   }, }; &lt;/script&gt;       // src/main.js  import { createApp } from 'vue' import App from './App'  createApp(App).mount('#app')       &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;/body&gt;       # terminal  $ npm run dev                 기존 static 폴더 내부의 images 폴더를 src 폴더 내부로 이동   images 폴더의 이름을 assets로 변경   src 폴더 내부에 components 폴더 생성   components 폴더 내부에 HelloWorld.vue 파일 생성              # terminal  $ npm i -D file-loader       // webpack.config.js  const path = require('path') const HtmlPlugin = require('html-webpack-plugin') const CopyPlugin = require('copy-webpack-plugin') const { VueLoaderPlugin } = require('vue-loader')  module.exports = {   resolve: {     extensions: ['.js', '.vue'],     alias: {  // 경로 별칭       '~': path.resolve(__dirname, 'src'),       'assets': path.resolve(__dirname, 'src/assets')     }     },   entry: './src/main.js',   output: {     clean: true   },   module: {     rules: [       {         test: /\\.vue$/,         use: 'vue-loader'       },       {         test: /\\.s?css$/,         use: [           'vue-style-loader',           'style-loader',           'css-loader',           'postcss-loader',           'sass-loader'         ]       },       {         test: /\\.js$/,         use: [           'babel-loader'         ]       },       {         test: /\\.(png|jpe?g|gif|webp)$/,  // png, jpg, jpeg, git, webp로 끝나는 파일         use: 'file-loader'       }     ]   },   plugins: [     new HtmlPlugin({       template: './index.html'     }),     new CopyPlugin({       patterns: [         { from: 'static' }       ]     }),     new VueLoaderPlugin()   ],   devServer: {     host: 'localhost'   } }       // src/components/HelloWorld.vue  &lt;template&gt;   &lt;img src=\"~assets/bear.jpg\" alt=\"Bear\" /&gt; &lt;/template&gt;       // src/App.vue  &lt;template&gt;   &lt;h1&gt;&lt;/h1&gt;   &lt;HelloWorld /&gt; &lt;/template&gt;  &lt;script&gt; import HelloWorld from \"~/components/HelloWorld\";  export default {   components: {     HelloWorld,   },   data() {     return {       message: \"Hello Vue!!\",     };   }, }; &lt;/script&gt;              3. ESLint 구성   # terminal  $ npm i -D eslint eslint-plugin-vue babel-eslint          루트 경로에 .eslintrc.js 파일 생성   // .eslintrc.js  module.exports = {   env: {  // browser, node 환경에서 동작하는 전역 개념들을 모두 코드 검사     browser: true,     node: true   },   extends: [  // 사용 가능한 규칙 세트     // vue     // 'plugin:vue/vue3-essential',  // Lv1     'plugin:vue/vue3-strongly-recommended',  // Lv2     // 'plugin:vue/vue3-recommended',  // Lv3     // js     'eslint:recommended'   ],   parserOptions: {  // 구문 분석할 패키지 설정(Babel, ES6^ =&gt; ES5)     parser: 'babel-eslint'   },   rules: {  // 추가적인 코드 규칙 설정     \"vue/html-self-closing\": [\"error\", {       \"html\": {         \"void\": \"always\",         \"normal\": \"never\",         \"component\": \"always\"       },       \"svg\": \"always\",       \"math\": \"always\"     }],     \"vue/html-closing-bracket-newline\": [\"error\", {       \"singleline\": \"never\",       \"multiline\": \"never\"     }]   } }       // setting.json  // 저장시 eslint 형식으로 자동 코드 정렬 \"editor.codeActionsOnSave\": {     \"source.fixAll.eslint\": true }       // src/components/HelloWorld.vue  &lt;template&gt;   &lt;img     src=\"~assets/bear.jpg\"     alt=\"Bear\" /&gt;   &lt;div&gt;&lt;/div&gt; &lt;/template&gt;  ","categories": ["Vue"],
        "tags": ["Vue","Web","Node.js"],
        "url": "/vue/frontend-vue-start/",
        "teaser": null
      },{
        "title": "[Vue.js] 조건문, 반복문",
        "excerpt":"1. 프로젝트 시작   # terminal  $ npx degit LeeWonWoo1/vue3-webpack-template vue3-test $ cd vue3-webpack-template vue3-test $ code . -r $ npm i   2. 조건문   // src/App.vue   &lt;template&gt;   &lt;h1 @click=\"increase\"&gt;     8   &lt;/h1&gt;   &lt;div v-if=\"count &gt; 4\"&gt;  // 조건문 작성     4보다 큽니다!   &lt;/div&gt; &lt;/template&gt;  &lt;script&gt;   data() {     return {       count: 0,     }   },   methods: {     increase() {       this.count += 1     }   } } &lt;/script&gt;  &lt;style lang=\"scss\"&gt;   h1 {     font-size: 50px;     color: royalblue;   }   ul {     li {       font-size: 40px;     }   } &lt;/style&gt;&gt;              3. 반복문   // src/App.vue  &lt;template&gt;   &lt;h1 @click=\"increase\"&gt;     8   &lt;/h1&gt;   &lt;div v-if=\"count &gt; 4\"&gt;     4보다 큽니다!   &lt;/div&gt;   &lt;ul&gt;  // 반복문     &lt;Fruit        v-for=\"fruit in fruits\"       :key=\"fruit\"       :name=\"fruit\"&gt;            &lt;/Fruit&gt;   &lt;/ul&gt; &lt;/template&gt;  &lt;script&gt; import Fruit from '~/components/Fruit'  export default {   components: {     Fruit   },   data() {     return {       count: 0,       fruits: ['Apple', 'Banana', 'Cherry']     }   },   methods: {     increase() {       this.count += 1     }   } } &lt;/script&gt;  &lt;style lang=\"scss\"&gt;   h1 {     font-size: 50px;     color: royalblue;   }   ul {     li {       font-size: 40px;     }   } &lt;/style&gt;&gt;       // src/components/Fruit.vue  &lt;template&gt;   &lt;li&gt;?!&lt;/li&gt; &lt;/template&gt;  &lt;script&gt; export default {   props: {     name: {       type: String,       default: ''     }   } } &lt;/script&gt;  &lt;style scoped lang=\"scss\"&gt;   h1 {     color: red !important;   } &lt;/style&gt;         ","categories": ["Vue"],
        "tags": ["Vue","Web","Node.js"],
        "url": "/vue/frontend-vue-iffor/",
        "teaser": null
      },{
        "title": "[React] 개요, 라이브러리",
        "excerpt":"1. React Keyword   - React vs Angular vs Vue      React            JavaScript library for building user interfaces       User Interface를 표현하고, 동작하는 것에 초점       View를 다루는 Library       오직 랜더링과 업데이트에만 관여되는 라이브러리                    HTTP Client나 Style에 대한 기능들이 포함되지 않음                       Library 지향           Angular            어떤 플랫폼에서도 하나의 코드 베이스로 결과물을 낼 수 있음       Full Development Story       전반적인 모든 기능 제공(클라이언트, 인증 등)       Full Framework 지향           Vue.js            Progressive JavaScript Framework       React처럼 View를 다루는 Library로 쓸 수 있음       Angular처럼 여러가지 생태계를 끌어와서 전반적인 기능 제공할 수 있음       Library처럼도, Framework처럼도 쓸 수 있음               - Component      컴포넌트 기반의 개발            독립적인 코드 블럭(HTML, CSS, JavaScript)       작업의 단위           &lt;!-- HTML Element --&gt;  &lt;!-- 이미 정의되어 있는 Element --&gt; &lt;img src=\"이미지 주소\" /&gt; &lt;button class=\"클래스\"&gt;버튼&lt;/button&gt;       &lt;!-- 내가 만든 Component --&gt;  &lt;!-- HTML, CSS, JavaScript를 합쳐서 내가 만든 일종의 태그 --&gt; &lt;사용자지정이름 name=\"LWW\" /&gt; &lt;사용자지정이름 prop={false}&gt;내용&lt;/사용자지정이름&gt;       - Virtual DOM           DOM을 직접 다루지 않음       DOM을 직접 제어하는 경우            바뀐 부분만 정확히 바꿔야 함           DOM을 직접 제어하지 않는 경우            가상의 DOM Tree를 사용해서 이전 상태와 이후 상태를 비교하여, 바뀐 부분을 찾아내서 자동으로 바꿈               - JSX      치환되는 템플릿이 아니라 순수한 JS로 transpile되는 문법(Babel, TypeScript)       - Client Side Rendering &amp; Server Side Rendering      특정 웹 서비스에 접속하면 HTML이 다운로드   HTML이 화면에 보이면서 HTML 내부의 DOM요소가 보이거나, 스타일이 적용됨      이때 React는 JavaScript로 이루어진 하나의 커다란 웹 어플리케이션  이 웹 어플리케이션은 JS가 전체 다운로드 되어야 실행 가능    @1. CSR      HTML 다운로드 시 빈 껍데기의 HTML이 내려옴   HTML 안에 있는 JS 파일을 다시 요청   JS 파일 안에는 React 웹 어플리케이션 전체가 들어있음   JS 앱을 다시 다운로드 받음   다운로드 받은 후에 스크립트가 브라우저에서 로드, 실행됨   이렇게 실행되면 이제서야 React 웹 어플리케이션이 실행됨   React가 실행되면, React Component들이 화면에 그려짐   이때 화면이 보이고, 유저가 인터렉션이 가능함      JS가 전부 다운로드 되어 React 애플리케이션이 정상 실행되기 전까지 화면이 보이지 않음  JS가 전부 다운로드 되어 React 애플리케이션이 정상 실행된 후, 화면이 보이면서 유저가 인터렉션 가능  SSR을 활용하지 않는다면 React는 기본적으로 CSR로 동작    @2. SSR      최초에 이미 HTML로 표현되어 있는 HTML을 다운   HTML 안의 JS를 다시 요청하는 과정에서는 HTML의 구성요소가 Render되고 있기 때문에 화면이 보임   대신 화면 안의 동작들은 JS가 실행되지 않았기 때문에 동작하지 않음   유저는 찰나의 순간에 동작하지 않는 Render된 결과물을 볼 수 있음   이 결과물을 보는 중간에 JS가 다운로드 됨   JS에 React 앱이 다운로드 되고, 소스코드를 실행하면 React가 실행됨   React 앱이 실행되면 실제로 JS를 통해 Component가 HTML 상에 다시 동작하는 순간부터 유저가 동작할 수 있음      JS가 전부 다운로드 되지 않아도, 일단 화면은 보이지만 유저가 사용할 수 없음  JS가 전부 다운로드 되어 React 어플리케이션이 정상 실행된 후, 유저가 사용 가능  유저가 찰나의 화면을 먼저 보는 것이 의미 있다면 SSR 기능 활용        2. Library      React 핵심 모듈로 React가 하는 일 알아보기   // 1. React Component -&gt; HTMLElement 연결 import ReactDOM from 'react-dom';  // 2. React Component 만들기 import React from 'react';          { React Component } - JS, JSX ==&gt; &#60; HTMLElement &#62;            ReactDOM 라이브러리 이용           ReactDOM.render(   &lt;HelloMessage name=\"LWW\" /&gt;,   document.getElementById('hello-example') );  class HelloMessage extends React.Component {   render() {     return (       &lt;div&gt;         Hello {this.props.name}       &lt;/div&gt;     )   } }          { React Component } 만들 때 사용하는 API            https://ko.reactjs.org/docs/react-api.html           React, ReactDOM Library를 CDN을 통해 사용해보기            https://ko.reactjs.org/docs/cdn-links.html           # terminal  $ mkdir what-is-react $ cd what-is-react $ npm init -y $ code . $ npx serve              &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/javascript\"&gt;     console.log(React);     console.log(ReactDOM);   &lt;/script&gt; &lt;/body&gt;                 Component를 활용한 프론트엔드            Component를 정의하고, 실제 DOM에 Component를 그려줌           &lt;!-- index.html --&gt;  &lt;head&gt;   &lt;title&gt;Example&lt;/title&gt;   &lt;style&gt;     * {       margin: 0;       padding: 0;       border: 0;     }     #root p {       color: white;       font-size: 20px;       background-color: royalblue;       text-align: center;       width: 100px;     }     #btn_plus {       background-color: orange;       border: 2px solid #000;       font-size: 15px;       width: 200px;     }   &lt;/style&gt; &lt;/head&gt;  &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;button id=\"btn_plus\"&gt;+&lt;/button&gt;    &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\"&gt;     const component = {       message: 'init',       count: 0,       render() {         return `&lt;p&gt;${this.message} : ${this.count}&lt;/p&gt;`;       }     };      function render(rootElement, component) {       rootElement.innerHTML = component.render();     }      // 초기화      render(document.querySelector('#root'), component);      document.querySelector('#btn_plus').addEventListener('click', () =&gt; {       component.message = 'update';       component.count = component.count + 1;       render(document.querySelector('#root'), component);     });   &lt;/script&gt; &lt;/body&gt;                 React를 활용한 프론트엔드   &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;button id=\"btn_plus\"&gt;+&lt;/button&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/javascript\"&gt;     console.log(React);     console.log(ReactDOM);      const Component = props =&gt; {       return React.createElement('p', null, `${props.message} : ${props.count}`);     }      ReactDOM.render(       React.createElement(Component, {message: 'init', count: 0}, null),        document.querySelector('#root'));      document.querySelector('#btn_plus').addEventListener('click', () =&gt; {       ReactDOM.render(         React.createElement(           Component,            {message: 'update', count: 77},            null         ),          document.querySelector('#root')       );     });   &lt;/script&gt; &lt;/body&gt;         ","categories": ["React"],
        "tags": ["React","Web","Node.js"],
        "url": "/react/frontend-react-start/",
        "teaser": null
      },{
        "title": "[React] Component를 만드는 법",
        "excerpt":"1. Component를 만드는 법      Hooks 이전            Component 내부에 상태가 있다면 : class       Component 내부에 상태가 없다면                    Lifecycle을 사용해야 한다면 : class           Lifecycle에 관계 없다면 : function                           Hooks 이후            class       function           import React from 'react';  // Class Component 정의 class ClassComponent extends React.Component {   render() {     return &lt;div&gt;Hello&lt;/div&gt;;   } }  // 사용 &lt;ClassComponent /&gt;       import React from 'react';  // Function Component 정의 1 function FunctionComponent() {   return &lt;div&gt;Hello&lt;/div&gt;; }  // Function Component 정의 2 const FunctionComponent = () =&gt; &lt;div&gt;Hello&lt;/div&gt;;  // 사용 &lt;FunctionComponent /&gt;       2. React.createElement로 Component 만들기   // React.createElement 요소  React.createElement(   type, // 태그 이름 문자열 | React Component | React.Fragment   [props],  // React Component에 넣어주는 데이터 객체   [...children]  // 자식으로 넣어주는 요소들 );       - 태그 이름 문자열 type   &lt;!-- index.html --&gt;  &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/javascript\"&gt;     console.log(React);     console.log(ReactDOM);      // 1. 태그 이름 문자열 type     // &lt;h1&gt;type이 \"태그 이름 문자열\" 입니다.&lt;/h1&gt;     ReactDOM.render(       React.createElement('h1', null, `type이 \"태그 이름 문자열\" 입니다.`),       document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              - React Component type   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/javascript\"&gt;     console.log(React);     console.log(ReactDOM);      // 2. React Component type     const Component = () =&gt; {       return React.createElement('p', null, `type 이 \"React Component 입니다.\"`);     }      // &lt;Component&gt;&lt;/Component&gt; =&gt; &lt;Component /&gt; =&gt; &lt;p&gt;type 이 \"React Component 입니다.&lt;/p&gt;     ReactDOM.render(       React.createElement(Component, null, null), document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              - React.Fragment   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/javascript\"&gt;     console.log(React);     console.log(ReactDOM);      // 3. React.Fragment     ReactDOM.render(       React.createElement(React.Fragment, null,          `type 이 \"React Fragment\" 입니다.`,         `type 이 \"React Fragment\" 입니다.`,         `type 이 \"React Fragment\" 입니다.`       ),       document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              - 복잡한 React Element 모임(createElement 한계)      정상작동 하지만, 가독성이 매우 떨어짐   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/javascript\"&gt;     console.log(React);     console.log(ReactDOM);      // 4. 복잡한 React Element 모임(createElement 한계)     // &lt;div&gt;     //   &lt;div&gt;     //     &lt;h1&gt;주제&lt;/h1&gt;     //     &lt;ul&gt;     //       &lt;li&gt;React&lt;/li&gt;     //       &lt;li&gt;Vue&lt;/li&gt;     //     &lt;/ul&gt;     //   &lt;/div&gt;     // &lt;/div&gt;          ReactDOM.render(       React.createElement(         'div',          null,          React.createElement(           'div',            null,            React.createElement('h1', null, \"주제\"),           React.createElement(             'ul',              null,              React.createElement('li', null, \"React\"),             React.createElement('li', null, 'Vue')           )         )       ),       document.querySelector('#root')     )   &lt;/script&gt;              3. JSX      JSX 문법으로 작성된 코드는 순수한 JavaScript로 Compile하여 사용   Babel 사용            https://babeljs.io/setup#installation           JSX를 사용하는 이유            React.createElement보다 가독성 측면에서 압도적       babel과 같은 compile 과정에서 문법적 오류를 인지하기 쉬움           &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/babel\"&gt;       &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // 우리가 작성한 어떤 코드 =&gt; 순수하게 실행할 수 있는 JavaScript     // babel     ReactDOM.render(       &lt;div&gt;         &lt;div&gt;           &lt;h1&gt;주제&lt;/h1&gt;           &lt;ul&gt;             &lt;li&gt;React&lt;/li&gt;             &lt;li&gt;Vue&lt;/li&gt;           &lt;/ul&gt;         &lt;/div&gt;       &lt;/div&gt;,       document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              - JSX 문법      최상위 요소가 하나여야 함   최상위 요소 리턴하는 경우, ()로 감싸야 함   자식들을 바로 Rendering하고 싶으면, &lt;&gt;자식들&lt;/&gt;를 사용 =&gt; Fragment   JavaScript 표현식을 사용하려면, {표현식}을 이용   if문은 사용할 수 없음            삼항 연산자 혹은 &amp;&amp; 사용           style을 이용해 inline 스타일링 가능   class 대신 className을 사용해 class를 적용할 수 있음   자식요소가 있으면 꼭 닫아야 하고, 자식요소가 없으면 열면서 닫아야 함            &#60;p&#62;abc&#60;/p&#62;       &#60;br /&#62;          ","categories": ["React"],
        "tags": ["React","Web","Node.js"],
        "url": "/react/frontend-react-component/",
        "teaser": null
      },{
        "title": "[React] Props, State",
        "excerpt":"1. Props와 State      Props는 Component 외부에서 Component에게 주는 데이터   State는 Component 내부에서 변경할 수 있는 데이터   둘 다 변경이 발생하면, Render가 다시 일어날 수 있음   Component를 그리는 방법을 기술하는 함수가 Render 함수   Render 함수는 Props와 State를 바탕으로 Component를 그림   Props와 State가 변경되면, Component를 다시 그림       - Props   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Function Component     // {message: '안녕하세요!!'}     function Component(props) {       return (         &lt;div&gt;           &lt;h1&gt;{props.message} 이것은 함수로 만든 Component 입니다.&lt;/h1&gt;         &lt;/div&gt;       );     }      ReactDOM.render(       &lt;Component message=\"안녕하세요!!\" /&gt;,        document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       render() {         return (           &lt;div&gt;             &lt;h1&gt;{this.props.message} 이것은 클래스로 만든 Component 입니다.&lt;/h1&gt;           &lt;/div&gt;         );       }     }      ReactDOM.render(       &lt;Component message=\"안녕하세요!!\" /&gt;,        document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              @ defaultProps   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       render() {         return (           &lt;div&gt;             &lt;h1&gt;{this.props.message} 이것은 클래스로 만든 Component 입니다.&lt;/h1&gt;           &lt;/div&gt;         );       }       static defaultProps = {         message: \"기본값1\",       };     }      ReactDOM.render(       &lt;Component /&gt;,        document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       render() {         return (           &lt;div&gt;             &lt;h1&gt;{this.props.message} 이것은 클래스로 만든 Component 입니다.&lt;/h1&gt;           &lt;/div&gt;         );       }     }      Component.defaultProps = {       message: \"기본값2\",     };      ReactDOM.render(       &lt;Component /&gt;,        document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Function Component     function Component(props) {       return (         &lt;div&gt;           &lt;h1&gt;{props.message} 이것은 함수로 만든 Component 입니다.&lt;/h1&gt;         &lt;/div&gt;       );     }      Component.defaultProps = {       message: \"기본값3\",     };      ReactDOM.render(       &lt;Component /&gt;,        document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              - State   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       // 그냥 작성       state = {         count: 0,       };        render() {         return (           &lt;div&gt;             &lt;h1&gt;{this.props.message} 이것은 클래스로 만든 Component 입니다.&lt;/h1&gt;             &lt;p&gt;{this.state.count}&lt;/p&gt;           &lt;/div&gt;         );       }        componentDidMount() {         setTimeout(() =&gt; {           // this.state.count = this.state.count + 1           this.setState({             count: this.state.count + 1,           });         }, 1000);       }        static defaultProps = {         message: \"기본값\",       };     }      ReactDOM.render(       &lt;Component message=\"안녕하세요!\" /&gt;,        document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;              &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       // 생성자       constructor(props) {         super(props);         this.state = { count: 0 };       }        render() {         return (           &lt;div&gt;             &lt;h1&gt;{this.props.message} 이것은 클래스로 만든 Component 입니다.&lt;/h1&gt;             &lt;p&gt;{this.state.count}&lt;/p&gt;           &lt;/div&gt;         );       }        componentDidMount() {         setTimeout(() =&gt; {           this.setState((previousState) =&gt; {             const newState = { count: previousState.count + 1};             return newState;           });         }, 1000);       }        static defaultProps = {         message: \"기본값\",       };     }      ReactDOM.render(       &lt;Component message=\"안녕하세요!\" /&gt;,        document.querySelector('#root')     );   &lt;/script&gt; &lt;/body&gt;         ","categories": ["React"],
        "tags": ["React","Web","Node.js"],
        "url": "/react/frontend-react-propstate/",
        "teaser": null
      },{
        "title": "[React] Event Handling",
        "excerpt":"Event Handling      HTML DOM에 클릭하면 이벤트가 발생하고, 그에 맞는 변경이 일어나도록 해야함   JSX에 이벤트를 설정할 수 있음   camelCase로만 사용할 수 있음            onClick, onMouseEnter           이벤트에 연결된 JavaScript 코드는 함수            이벤트 = {함수}와 같이 씀           실제 DOM 요소들에만 사용 가능            React Component에 사용하면, 그냥 props로 전달           class Comp extends React.Component {   render() {     return (       &lt;div&gt;         &lt;button onClick={() =&gt; {           console.log('cilcked');         }}&gt;클릭&lt;/button&gt;       &lt;/div&gt;     );   } }       &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Function Component     function Component() {       return (         &lt;div&gt;           &lt;button              onClick={() =&gt; {                console.log('clicked');              }}           &gt;             클릭           &lt;/button&gt;         &lt;/div&gt;       );     }      ReactDOM.render(&lt;Component /&gt;, document.querySelector('#root'))   &lt;/script&gt; &lt;/body&gt;              &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       state = {         count: 0,       };       render() {         return (           &lt;div&gt;             &lt;p&gt;{this.state.count}&lt;/p&gt;             &lt;button                onClick={() =&gt; {                  console.log('clicked');                 this.setState((state) =&gt; ({                   ...state,                   count: state.count + 1,                 }));               }}             &gt;               클릭             &lt;/button&gt;           &lt;/div&gt;         );       }     }      ReactDOM.render(&lt;Component /&gt;, document.querySelector('#root'))   &lt;/script&gt; &lt;/body&gt;                 메서드 분리   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       state = {         count: 0,       };       // bind 방법 1       constructor(props) {         super(props);         this.click = this.click.bind(this);       }       render() {         return (           &lt;div&gt;             &lt;p&gt;{this.state.count}&lt;/p&gt;             &lt;button onClick={this.click}&gt;클릭&lt;/button&gt;           &lt;/div&gt;         );       }       click() {         console.log('clicked');         this.setState((state) =&gt; ({           ...state,           count: state.count + 1,         }));       }     }      ReactDOM.render(&lt;Component /&gt;, document.querySelector('#root'))   &lt;/script&gt; &lt;/body&gt;       &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      // Class Component     class Component extends React.Component {       state = {         count: 0,       };       render() {         return (           &lt;div&gt;             &lt;p&gt;{this.state.count}&lt;/p&gt;             &lt;button onClick={this.click}&gt;클릭&lt;/button&gt;           &lt;/div&gt;         );       }       click = () =&gt; {  // bind 방법 2         console.log('clicked');         this.setState((state) =&gt; ({           ...state,           count: state.count + 1,         }));       }     }      ReactDOM.render(&lt;Component /&gt;, document.querySelector('#root'))   &lt;/script&gt; &lt;/body&gt;         ","categories": ["React"],
        "tags": ["React","Web","Node.js"],
        "url": "/react/frontend-react-eventhandling/",
        "teaser": null
      },{
        "title": "[React] Component Lifecycle",
        "excerpt":"1. 16.3 이전 Component Lifecycle      React Component는 탄생부터 죽음까지 여러 지점에서 개발자가 작업이 가능하도록 메서드를 오버라이딩 할 수 있게 해줌   Declarative 성질 : Component의 탄생부터 죽음까지 순간순간을 선언적으로 표현하면, React Component가 선언적으로 표현된 함수들을 실행해서 사용할 수 있게 해주기 때문에, 효과적으로 처리할 수 있음   Initialization            setup props and state           Mounting            componentWillMount       render       componentDidMount           Updation            props                    componentWillReceiveProps           shouldComponentUpdate           componentWillUpdate           render           componentDidUpdate                       states                    shouldComponentUpdate           componentWillUpdate           render           componentDidUpdate                           Unmounting            componentWillUnmount               - Component 생성 및 마운트      constructor   componentWillMount   render (최초 랜더)   componentDidMount   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      class App extends React.Component {       state = {         age: 29,       };       constructor(props) {         super(props);         console.log('consturctor', props);       }       render() {         console.log('render')         return (           &lt;div&gt;             &lt;h2&gt;Hello {this.props.name} - {this.state.age}&lt;/h2&gt;           &lt;/div&gt;         );       }       componentWillMount() {         console.log('componentWillMount');       }       componentDidMount() {         console.log('componentDidMount');          // 타이머 설정         setInterval(() =&gt; {           this.setState(state =&gt; ({ ...state, age: state.age + 1}));         }, 1000);       }     }      ReactDOM.render(&lt;App name=\"LWW\" /&gt;, document.querySelector(\"#root\"));   &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;              - Component props, state 변경      componentWillReceiveProps            props를 새로 지정했을 때 바로 호출됨       state의 변경에 반응하지 않음       props의 값에 따라 state를 변경해야 한다면,                    setState를 이용해 state를 변경           각각 다음 이벤트로 가는것이 아니라 한번에 변경됨                           shouldComponentUpdate            props만, state만, props와 state 둘다 변경되어도 실행       new Props와 new State를 인자로 해서 호출       return type이 boolean                    true면 render           false면 render가 호출되지 않음           이 함수를 구현하지 않으면, default는 true                           componentWillUpdate            Component가 재 rendering되기 직전에 호출       setState 같은 것을 쓰면 안됨           render   componentDidUpdate            Component가 재 rendering을 마치면 호출           &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      class App extends React.Component {       state = {         age: 29,       };       constructor(props) {         super(props);         console.log('consturctor', props);       }       render() {         console.log('render')         return (           &lt;div&gt;             &lt;h2&gt;Hello {this.props.name} - {this.state.age}&lt;/h2&gt;           &lt;/div&gt;         );       }       componentWillMount() {         console.log('componentWillMount');       }       componentDidMount() {         console.log('componentDidMount');          // 타이머 설정         setInterval(() =&gt; {           this.setState(state =&gt; ({ ...state, age: state.age + 1}));         }, 1000);       }        componentWillReceiveProps(nextProps) {         console.log('componentWillReceivePorps', nextProps);       }       shouldComponentUpdate(nextProps, nextState) {         console.log('shouldComponentUpdate', nextProps, nextState);         return true;  // 바로 render할 준비         // return false;  // props나 state가 변경되어도 다시 render하지 않음       }       componentWillUpdate(nextProps, nextState) {         console.log('componentWillUpdate', nextProps, nextState)       }       componentDidUpdate(prevProps, prevState) {         console.log('componentDidUpdate', prevProps, prevState)       }     }      ReactDOM.render(&lt;App name=\"LWW\" /&gt;, document.querySelector(\"#root\"));   &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;          ShouldComponentUpdate가 false일 경우             ShouldComponentUpdate가 true 경우          - Component 언마운트      componentWillUnmount            언마운트되기 직전       Component가 사용하고 있던 메모리 중에 정리할 것이 있으면 정리       API 응답을 받기 전에 언마운트 된다면 API를 더 이상 받을 준비를 하지 않는 처리 등            &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      class App extends React.Component {       state = {         age: 29,       };       // 변수 정의       interval = null;       constructor(props) {         super(props);         console.log('consturctor', props);       }       render() {         console.log('render')         return (           &lt;div&gt;             &lt;h2&gt;Hello {this.props.name} - {this.state.age}&lt;/h2&gt;           &lt;/div&gt;         );       }       componentWillMount() {         console.log('componentWillMount');       }       componentDidMount() {         console.log('componentDidMount');                  // 멤버 변수로 할당         this.interval = setInterval(() =&gt; {           this.setState(state =&gt; ({ ...state, age: state.age + 1}));         }, 1000);       }        componentWillReceiveProps(nextProps) {         console.log('componentWillReceivePorps', nextProps);       }       shouldComponentUpdate(nextProps, nextState) {         console.log('shouldComponentUpdate', nextProps, nextState);         return true;       }       componentWillUpdate(nextProps, nextState) {         console.log('componentWillUpdate', nextProps, nextState)       }       componentDidUpdate(prevProps, prevState) {         console.log('componentDidUpdate', prevProps, prevState)       }       // Interval 함수 종료       componentWillUnmount() {         clearInterval(this.interval);       }     }      ReactDOM.render(&lt;App name=\"LWW\" /&gt;, document.querySelector(\"#root\"));   &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;       2. 16.3 이후 Component Lifecycle      Initialization            setup props and state           Mounting            getDerivedStateFromProps       render       componentDidMount           Updation            props                    getDerivedStateFromProps           shouldComponentUpdate           render           getSnapshotBeforeUpdate(DOM에 적용)           componentDidUpdate                       states                    shouldComponentUpdate           render           getSnapshotBeforeUpdate(DOM에 적용)           componentDidUpdate                           Unmounting            componentWillUnmount               - Component 생성 및 마운트      constructor   getDerivedStateFromProps            시간의 흐름에 따라 변하는 Props에 State가 의존하는 경우 사용           render   componentDidMount   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      class App extends React.Component {       state = {         age: 29,       };       interval = null;       constructor(props) {         super(props);         console.log('consturctor', props);       }       render() {         console.log('render')         return (           &lt;div&gt;             &lt;h2&gt;Hello {this.props.name} - {this.state.age}&lt;/h2&gt;           &lt;/div&gt;         );       }       static getDerivedStateFromProps(nextProps, prevState) {         console.log('getDerivedStateFromProps', nextProps, prevState);         return {           age: 100         };       }       componentDidMount() {         console.log('componentDidMount');         this.interval = setInterval(() =&gt; {           this.setState(state =&gt; ({ ...state, age: state.age + 1}));         }, 1000);       }        shouldComponentUpdate(nextProps, nextState) {         console.log('shouldComponentUpdate', nextProps, nextState);         return true;       }       componentDidUpdate(prevProps, prevState) {         console.log('componentDidUpdate', prevProps, prevState)       }       componentWillUnmount() {         clearInterval(this.interval);       }     }      ReactDOM.render(&lt;App name=\"LWW\" /&gt;, document.querySelector(\"#root\"));   &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;              - Component props, state 변경   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);      let i = 0 ;      class App extends React.Component {       state = { list: [] };        render() {         return (           &lt;div id=\"list\" style=&gt;             {this.state.list.map(i =&gt; {               return (&lt;div&gt;{i}&lt;/div&gt;);             })}             &lt;/div&gt;         );       }       componentDidMount() {         setInterval(() =&gt; {           this.setState(state =&gt; ({             list: [ ...state.list, i++],           }));         }, 1000);       }       getSnapshotBeforeUpdate(prevPorps, prevState) {         if (prevState.list.length === this.state.list.length) {           return null;         }         const list = document.querySelector('#list');         return list.scrollHeight - list.scrollTop;       }       componentDidUpdate(prevPorps, prevState, snapshot) {         console.log(snapshot);         if (snapshot === null) {           return;         }         const list = document.querySelector('#list');         list.scrollTop = list.scrollHeight - snapshot;       }     }          ReactDOM.render(&lt;App name=\"LWW\" /&gt;, document.querySelector(\"#root\"));   &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;              - Component 에러 캐치      componentDidCatch   &lt;body&gt;   &lt;div id=\"root\"&gt;&lt;/div&gt;   &lt;script crossorigin src=\"https://unpkg.com/react@17/umd/react.development.js\"&gt;&lt;/script&gt;   &lt;script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"&gt;&lt;/script&gt;   &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;   &lt;script type=\"text/babel\"&gt;     console.log(React);     console.log(ReactDOM);          class App extends React.Component {       state = {         hasError: false       };       render() {         if (this.state.hasError) {           return &lt;div&gt;예상치 못한 에러 발생!!&lt;/div&gt;         }         return &lt;WebService /&gt;;       }       componentDidCatch(error, info) {         this.setState({ hasError: true });       }     }      ReactDOM.render(&lt;App name=\"LWW\" /&gt;, document.querySelector(\"#root\"));   &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;  ","categories": ["React"],
        "tags": ["React","Web","Node.js"],
        "url": "/react/frontend-react-lifecycle/",
        "teaser": null
      },{
        "title": "[React] Create React Project",
        "excerpt":"1. Create React App   CRA 링크   # terminal  $ npx create-react-app tic-tac-toe $ cd tic-tac-toe $ code .       // package.json  {   \"name\": \"tic-tac-toe\",   \"version\": \"0.1.0\",   \"private\": true,   \"dependencies\": {     \"@testing-library/jest-dom\": \"^5.14.1\",  // 테스팅     \"@testing-library/react\": \"^11.2.7\",  // 테스팅     \"@testing-library/user-event\": \"^12.8.3\",  // 테스팅     \"react\": \"^17.0.2\",  // 핵심 모듈     \"react-dom\": \"^17.0.2\",  // 핵심 모듈     \"react-scripts\": \"4.0.3\",  // 개발환경, production 모드에서 build를 위한 배포작업, create-react-app의 프로젝트 관리 역할     \"web-vitals\": \"^1.1.2\"  // 구글에서 사이트 경험을 측정하고 개선할 수 있도록 정보를 얻는 라이브러리   },   \"scripts\": {     \"start\": \"react-scripts start\",  // 개발서버를 로컬에서 띄움     \"build\": \"react-scripts build\",  // production 모드로 build. 컴파일, $ npx serve -s build     \"test\": \"react-scripts test\",  // Jest가 실행되면서 test code 실행     \"eject\": \"react-scripts eject\"  // cra 내에서 해결이 안되는 설정을 추가할 때 사용   },   ... }       2. ESLint      코딩 스타일을 내부적으로 규정   {   ...   \"eslintConfig\": {     \"extends\": [       \"react-app\",       \"react-app/jest\"     ],     \"rules\": {  // ESLint 규칙 설정       \"semi\": [\"error\", \"always\"]     }   },   ... }       3. Prettier      코드 포매터   eslint-config-prettier            Prettier에서 불필요하거나 Prettier와 충돌할 수 있는 모든 규칙을 끔       규칙을 끄기만 하기 때문에 다른 설정과 함께 사용           # terminal  $ npm i prettier -D       {   ...   \"eslintConfig\": {     \"extends\": [       \"react-app\",       \"react-app/jest\",       \"prettier\"     ],   },   ... }              4. Husky      Git으로 어떤 액션이 발생할 때, 처리할 것을 처리해 주는 툴   ex) Commit 전에 코드 테스트   # terminal  $ npm i husky -D $ npx husky install       // package.json {   ...   \"scripts\": {     \"prepare\": \"husky install\",     \"start\": \"react-scripts start\",     \"build\": \"react-scripts build\",     \"test\": \"react-scripts test\",     \"eject\": \"react-scripts eject\"   },   ... }       # terminal  $ npx husky add .husky/pre-commit \"~~~\"       5. Lint-staged      Run linters on git staged files   # terminal  $ npm i lint-staged -D $ npx husky add .husky/pre-commit \"lint-staged\"       // package.json {   ...   \"lint-staged\": {     \"**/*.js\": [       \"eslint --fix\",       \"prettier --write\",       \"git add\"     ]   },   ... }       6. React Component Debugging      React Developer Tools   React Developer Tools 설치   # terminal  $ npm start         ","categories": ["React"],
        "tags": ["React","Web","Node.js"],
        "url": "/react/frontend-react-createreactproject/",
        "teaser": null
      },{
        "title": "[React] Router",
        "excerpt":"1. React Routing 이해하기      Single Page Application            기존에는 서버로부터 해당 url에 대한 데이터를 받아옴       이제는 서버로부터 하나의 전체 App 받아온 후 클라이언트(Browser)에서 url에 따라서 어떤 것을 보여줄지 결정           SPA 라우팅 과정            브라우저에서 최초에 ‘/’ 경로로 요청       React Web App을 내려줌       내려받은 React App에서 ‘/’ 경로에 맞는 Component를 보여줌       React App에서 다른 페이지로 이동하는 동작을 수행하면,       새로운 경로에 맞는 Component를 보여줌          ","categories": ["React"],
        "tags": ["React","Web","Node.js"],
        "url": "/react/frontend-react-router/",
        "teaser": null
      }]
