var store = [{
        "title": "[Github 블로그] Github Blog 시작!",
        "excerpt":"Github blog를 개설하는 과정을 간단하게 알아봅니다.   주의! Git의 사용법을 어느정도 숙지해야 합니다.   1. Github repository 생성  새 repository 이름을 [자신의 Github ID].github.io 로 설정한다.      2. Import code  원하는 Jekyll 테마를 선택하고 코드를 복사한다. Jekyll 테마를 모아둔 사이트는 다음과 같다.   Jekyll ? Ruby 언어로 만들어져 html, markdown 등의 텍스트를 가공하는 텍스트 변환 엔진    http://jekyllthemes.org/  http://themes.jekyllrc.org/  https://jekyllthemes.io/    나의 경우 minimal-mistakes 의 ‘dark’ 테마가 마음에 들어 선택했다.   코드를 복사한 뒤 생성한 [자신의 Github ID].github.io repository로 돌아와 import 한다.            이때 나와 같이 Import하지 않고 repository를 fork 하거나 파일을 Download해도 된다.   3. git clone  Import한 파일들을 작업하기 위해 vscode 터미널에서 clone한다.   $ git clone https://github.com/Github ID/Github ID.github.io.git   4. Rubby 설치  Jekyll을 설치하기 전에 Ruby를 설치한다.   Linux Ubuntu 환경   $ sudo apt-get install ruby-full $ ruby -v   설치가 잘 되었다면 cmd 창에 버전이 잘 출력될 것이다.       Windows 환경    Ruby 다운로드 사이트 에서 다운받아 설치한다.  설치 과정에서 \"Add Ruby executables to your PATH\" 에 체크하면 자동으로 환경변수 설정이 완료된다.   5. Jekyll, Bundler 설치  본인이 clone한 폴더로 들어가면 Gemfile 이라는 파일이 있을 것이다. cmd를 켜서 이 파일이 있는 경로로 들어간 후, 아래의 명령을 수행한다.   $ gem install jekyll bundler $ bundle $ jekyll -v   Jekyll이 잘 설치되었다면 cmd 창에 버전이 잘 출력될 것이다.  그 다음 아래의 명령어를 통해 로컬 환경에서 자신이 개발하는 블로그를 확인해 볼 수 있다.   $ jekyll serve   정상적으로 설치 되었다면 로컬서버 http://localhost:4000/  에서 확인하자.      6. 불필요한 파일 삭제  Github에 commit하기 전에 본인이 clone한 폴더에서 불필요한 파일을 삭제한다.      docs 폴더 : post 샘플이 들어가 있으므로 백업해 놓는다.  README.md : 다시 작성하기 위해 삭제했다.   7. Github 연동  수정된 사항들을 깃헙에 “add-commit-push” 하여 반영한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master    push가 완료되면 [자신의 Github ID].github.io 에서 블로그를 확인할 수 있다.  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/my-first-post/",
        "teaser": null
      },{
        "title": "[Github 블로그] _config.yml 셋팅",
        "excerpt":"config 수정 공식 사이트   minimal-mistakes _config.yml 설정 공식 사이트    _config.yml 실행   vscode로 루트경로에 있는 _config.yml 을 열어주고 작업한다.  필요없는 부분은 제외하고 작성했다.   _config.yml 수정   minimal_mistakes_skin    : \"dark\" # \"air\", \"aqua\", \"contrast\", \"dark\", \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"  # 사이트 기본 세팅 locale                   : \"ko-KR\" title                    : \"LWW's Tech Blog\" # 타이틀 title_separator          : \"&amp;#124;\" # 구분자 subtitle                 : \"Version 1.0\" # 타이틀 하단 글씨 name                     : \"이원우\" # footer에 찍히는 이름 description              : \"꾸준히 기록하는 블로그\" # 설명 url                      : \"https://LeeWonWoo1.github.io\" # 호스트 주소 repository               : \"LeeWonWoo1/LeeWonWoo1.github.io\" # GitHub 유저이름 / 레포지 이름 teaser                   :  logo                     : # 타이틀 옆 이미지 masthead_title           : \"LWW's Tech Blog\" # 최 상단 타이틀 breadcrumbs              : true # 브래드크럼 사용 여부 words_per_minute         : 200   # 댓글 comments:   provider               : \"disqus\" #   disqus:     shortname            : LWW # disqus에 입력한 Web Site Name   discourse:     server               :   # 구글 Recaptcha reCaptcha:   siteKey                :   secret                 : atom_feed:   path                   :    hide                   :  search                   : true  search_full_content      : true   # Analytics analytics:   provider               : false    # Site Author author:   name             : \"이원우\"   avatar           : \"/assets/images/profile/bear.jpg\" # 프로필 이미지   bio              : \"CS / FrontEnd\"   location         : \"Republic of Korea\"   email            : \"plmplmdnjsdn@naver.com\"   links:     - label: \"Website\"       icon: \"fas fa-fw fa-link\"       url: \"https://LeeWonWoo1.github.io\"     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"   # Site Footer footer:   links:     - label: \"Email\"       icon: \"fab fa-fw fa-envelope-square\"       url: mailto:plmplmdnjsdn@naver.com     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       url: \"https://github.com/LeeWonWoo1\"  # Post에 적용될 default 설정 defaults:   # _posts   - scope:       path: \"\"       type: posts     values:       layout: single       author_profile: true       read_time: true       comments: true       share: true       related: true       popular: false   수정하면서 종종 jekyll 서버로 확인한다.   $ jekyll serve   Github 연동  수정을 완료하면 Github에 연동한다.   $ git add . $ git commit -m \"commit message\" $ git push origin master  ","categories": ["Blog"],
        "tags": ["Blog","jekyll","Github","Git","minimal-mistake"],
        "url": "/blog/github-blog-config/",
        "teaser": null
      },{
        "title": "[HTML] 글자와 상자",
        "excerpt":"글자와 상자   요소가 화면에 출력되는 특성. 크게 2가지로 구분됨.   인라인(Inline) 요소 : 글자를 만들기 위한 요소  블록(Block) 요소 : 상자(레이아웃)를 만들기 위한 요소   - Inline 요소   &lt;span&gt;Hello&lt;/span&gt; &lt;span&gt;World!!&lt;/span&gt;  Hello World!! -------------&gt; 요소가 수평으로 쌓임  가로는 포함한 콘텐츠 크기만큼 줄어듬 &lt;---&gt; &lt;-----&gt; Hello World!! ↕ 세로도 포함한 콘텐츠 크기만큼 줄어듬   span은 가장 대표적인 인라인 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Inline 요소는 가로, 세로 너비를 지정할 수 없음   &lt;span style=\"width: 100px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"height: 100px;\"&gt;World!!&lt;/span&gt;  Hello World!!  &lt;-- 반응 없음     외부, 내부 여백을 지정할 수 있지만, 상하 여백은 사용 불가   &lt;span style=\"margin: 20px 20px;\"&gt;Hello&lt;/span&gt; &lt;span style=\"padding: 20px 20px;\"&gt;World!!&lt;/span&gt;  20px         20px   20px     20px &lt;--&gt;『Hello』&lt;--&gt; 『&lt;--&gt;World&lt;--&gt;』      &lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt;    &lt;!-- Inline 요소 안에 Block 요소 사용 불가 --&gt; &lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;  &lt;!-- Inline 요소 안에 Inline 요소 사용 가능 --&gt;       - Block 요소   &lt;div&gt;Hello&lt;/div&gt; &lt;div&gt;World!!&lt;/div&gt;  Hello     ↓ World!!   ↓  요소가 수직으로 쌓임  가로는 부모 요소의 크기만큼 늘어남 &lt;----------------------------------&gt; Hello                              ↕ World!!                            ↕ 세로는 포함한 콘텐츠 크기만큼 줄어듬   div은 가장 대표적인 블록 요소.  본질적으로 아무것도 나타내지 않는 콘텐츠 영역을 설정하는 용도      Block 요소는 가로, 세로 너비를 지정할 수 있음   &lt;div style=\"width: 100px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"height: 40px;\"&gt;World!!&lt;/div&gt;       100px &lt;--------------&gt; Hello          ↕ World!!                        ↕                                ↕ 40px &lt;------------------------------&gt;     외부, 내부 여백을 지정할 수 있음   &lt;div style=\"margin: 20px;\"&gt;Hello&lt;/div&gt; &lt;div style=\"padding: 20px;\"&gt;World!!&lt;/div&gt;  20px             ↕ 20px          20px &lt;--&gt;『Hello                    』&lt;--&gt;                  ↕ 20px 『               ↕ 20px          20px &lt;--&gt;World!!                      &lt;--&gt;  20px            ↕ 20px             』      &lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;    &lt;!-- Block 요소 안에 Block 요소 사용 불가 --&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;  &lt;!-- Block 요소 안에 Inline 요소 사용 가능 --&gt;   ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-inlineblock/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-1. 요구사항 확인",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 생명 주기(Software Life Cycle) – A   소프트웨어 개발 방법론의 바탕   - 폭포수 모형(Waterfall Model)      고전적 생명 주기 모형   개발의 한 단계가 끝나야 다음 단계로 넘어가는 선형 순차적 모형   메뉴얼 작성   단계가 끝나면 다음 단계 _결과물 명확히 산출_되어야 함   두 개 이상의 과정이 병행 수행 X   타당성 검토 -&gt; 계획 -&gt; 요구 분석 -&gt; 설계 -&gt; 구현(코딩) -&gt; 시험(검사) -&gt; 유지보수   - 프로토타입 모형(Prototype Model)      인터페이스에 중점을 두어 개발   시스템의 일부를 만드는 과정으로 추후 구현 단계에서 사용될 골격 코드   폭포수 모형의 단점 보완   요구 수집 -&gt; 빠른 설계 -&gt; 프로토타입 구축 -&gt; 고객 평가 -&gt; 포로토타입 조정 -&gt; 구현   - 나선형 모형(Spiral Model)      프로토타입 + 위험 분석 기능   여러번의 개발 과정을 거쳐 완벽한 소프트웨어 개발. 점진적 모형   위험의 관리와 최소화 목적   누락되거나 추가된 요구사항 첨가 가능, 정밀   유지보수 과정 필요 없음   계획 및 정의 -&gt; 위험 분석 -&gt; 공학적 개발 -&gt; 고객 평가   - 애자일 모형(Agile Model)      일정 주기 반복 하며 개발   고객과의 소통에 초점   스프린트, 이터레이션의 짧은 개발 주기 반복   결과물에 대한 고객의 평가와 요구를 적극 수용   스크럼(Scrum), XP(eXtreme Programming), 칸반(Kanban), Lean, 크리스탈, ASD, FDD 등   – 애자일 선언   애자일 개발 4대 핵심 가치      개인과 상호작용에 더 가치를 둠   실행되는 SW에 더 가치를 둠   고객과 협업에 더 가치를 둠   변화에 반응하는 것에 더 가치를 둠   - 폭포수 모형과 애자일의 비교                  구분       폭포수       애자일                       요구사항 반영       어려움       지속적으로 반영                 고객과의 의사소통       적음       지속적                 테스트       마지막에 테스트       반복되는 주기마다 테스트                 개발 중심       계획, 문서(메뉴얼)       고객               2. 스크럼(Scrum) 기법 – A   팀 중심으로 개발 효율성 높임   - 개요      스스로 팀을 구성, 스스로 해결   제품 책임자(PO; Product Owner)            개발 의뢰자나 사용자가 담당       제품 요구사항 작성의 주체       요구사항 백로그 작성, 우선순위 지정           스크럼 마스터(SM; Scrum Master)            객관적인 시각에서 조언       통제가 목표 아님       진행사항 점검, 장애요소 공론화           개발팀(DT; Development Team)            PO, SM을 제외한 개발에 참여하는 모든 사람           - 스크럼 개발 프로세스      제품 백로그 -&gt; 스프린트 계획 회의 -&gt; 스프린트 -&gt; 일일 스크럼 회의 -&gt; 스프린트 검토 회의 -&gt; 스프린트 회고       3. XP(eXtreme Programming) 기법 – A   고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상   - XP      짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적 참여로 S/W를 빠르게 개발   릴리즈 기간을 짧게 반복   릴리즈 테스트마다 고객을 직접 참여시킴   소규모 인원 개발 프로젝트에 효과적   XP의 5대 핵심 가치 : 의사소통, 단순성, 용기, 존중, 피드백   - XP 개발 프로세스      사용자 스토리 -&gt; 릴리즈 계획 수립 -&gt; 스파이크 -&gt; 이터레이션 -&gt; 승인검사 -&gt; 소규모 릴리즈   - XP 주요 실천 방법      짝 프로그래밍(Pair Programming)            다른 사람과 함께 스행하여 책임을 공동으로 나눔           테스트 주도 개발(Test-Driven Development)            테스트 케이스 먼저 작성       테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구 사용           전체 팀(Whole Team)            모든 구성원들을 각자 자신의 역할이 있고 거기에 책임을 가져야 함           계속적인 통합(Continuous Integration)            모듈 단위로 개발된 코드가 지속적으로 통합           디자인 개선(Design Improvement) 또는 리팩토링(Refactoring)            기능 변경 없이, 단순화, 유연성 강화 등을 통해 시스템 재구성           소규모 릴리즈(Small Releases)            릴리즈 기간을 짧게 반복하여 고객 요구 변화에 신속히 대응               4. 요구사항 정의 – B   - 요구사항 개념 및 특징      요구사항은 소프트웨어가 제공하는 서비스에 대한 설명과 운영되는데 필요한 제약 조건   개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공   개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 도움   요구사항이 잘 정의 되어야 이후 과정의 목표와 계획을 수립할 수 있음   - 요구사항의 유형      기능 요구사항            무엇을 하는지, 어떤 기능을 하는지       입출력에 무엇이 포함되어야 하는지, 어떤 데이터를 저장하거나 연산을 수행해야 하는지       반드시 수행해야 하는 기능       사용자가 제공받기 원하는 기능           비기능 요구사항            시스템 장비 구성       성능       인터페이스       데이터       테스트       보안       품질       제약사항       프로젝트 관리 요구사항       프로젝트 지원 요구사항           사용자 요구사항            사용자 관점에서 본 시스템이 제공해야 할 요구사항       친숙한 표현으로 이해하기 쉽게 작성           시스템 요구사항            개발자 관점에서 본 시스템이 사용자와 다른 시스템에 제공해야 할 요구사항       전문적이고 기술적인 용어로 표현       소프트웨어 요구사항이라고도 함           - 요구사항 개발 프로세스   요구 사항 도출(Elicitation) -&gt; 분석(Analysis) -&gt; 명세(Specification) -&gt; 확인(Validation)       5. UML(Unified Modeling Language) – A   - UML 개요      객체 지향 모델링 언어   Rumbaugh, Booch, Jacobson 등 객체지향 방법론의 장접 통합. OMG에서 표준으로 지정   구조 다이어그램 6개, 행위 다이어그램 7개   사물과 사물 간의 관계를 용도에 맞게 표현   구성요소는 사물, 관계, 다이어그램   - 사물(Things)      관계가 형성될 수 있는 대상   구조 사물(Structural Things)            시스템의 개념적, 물리적 요소       Class, Use Case, Component, Node 등           행동 사물(Behavioral Things)            시간과 공간에 따른 요소들의 행위       Interaction, State Machine           그룹 사물(Grouping Things)            요소들을 그룹으로 묶어서 표현       Package           주해 사물(Annotation Things)            부가적인 설명이나 제약조건       Note           - 관계(Relationships)      사물과 사물 사이의 연관성 표현   연관(Association) 관계            2개 이상의 사물이 서로 관련되어 있음       사물 사이 실선 연결, 방향성은 화살표로       양방향 관계의 경우 화살표 생략하고 실선으로만 연결       다중도를 선 위에 표기           집합(Aggregation) 관계            하나의 사물이 다른 사물에 포함되어 있음       서로 독립적       포함하는 쪽으로 속이 빈 마름모 연결하여 표현           포함(Composition) 관계            포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계       독립될 수 없고 생명주기를 함께 함       포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현           일반화(Generalization) 관계            하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현       일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)       상위 사물 쪽으로 속이 빈 화살표 연결하여 표현           의존(Dependency) 관계            연관은 있으나 짧은 시간 동안만 연관을 유지하는 관계       소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계       영향 받는 쪽으로 점선 화살표 연결하여 표현           실체화(Realization) 관계            할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계       기능 쪽으로 속이 빈 점선 화살표 연결           - 다이어그램(Diagram)      사물과 관계를 도형으로 표현   가시화한 View를 제공하여 의사소통에 도움   정적 모델링에서는 구조적 다이어그램, 동적 모델링에서는 행위 다이어그램 사용   - 구조적 다이어그램      클래스(Class) 다이어그램   객체(Object) 다이어그램   컴포넌트(Component) 다이어그램   배치(Deployment) 다이어그램   복합체 구조(Composite Structure) 다이어그램   패키지(Package) 다이어그램   - 행위 다이어그램      유스케이스(Use Case) 다이어그램   시퀀스(Sequence) 다이어그램   커뮤니케이션(Communication) 다이어그램   상태(State) 다이어그램   활동(Activity) 다이어그램   상호작용 개요(Interaction Overview) 다이어그램   타이밍(Timing) 다이어그램  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-2. 화면 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 사용자 인터페이스 – A   - UI 개요      사용자 인터페이스(UI)는 사용자와 시스템 간의 상호작용이 원활하도록 돕는 장치나 S/W   UI의 3가지 분야            정보 제공을 위한 물리적 제어       콘텐츠의 상세적인 표현과 전체적인 구성       모든 사용자가 편리하고 간편하게 사용           - UI 특징      S/W 영역 중 변경이 가장 많이 발생   편리성과 가독성을 높여 작업 시간을 단축시키고 업무에 대한 이해도 높여줌   최소한의 노력으로 원하는 결과 얻을 수 있게 함   오류를 줄임   구체적인 방법 제시   매개 역할   UI를 설계하기 위해서는 S/W 아키텍처 반드시 숙지해야 함   - UI 구분      CLI(Command Line Interface) : 텍스트 형태   GUI(Graphical User Interface) : 그래픽 환경   NUI(Natural User Interface) : 말이나 행동으로 조작   - UI 기본 원칙      직관성   유효성   학습성   유연성   - UI 설계 지침      사용자 중심   일관성   단순성   결과 예측 가능   가시성   표준화   접근성   명확성   오류 발생 해결       2. UI 표준 및 지침 – B      기술의 중립성(웹 표준), 표현 보장성(웹 접근성), 기능의 호환성(웹 호환성) 고려 확인   UI 표준 : 모든 UI에 공통적으로 적용될 내용   UI 지침 : UI 개발 과정에서 꼭 지켜야 할 공통의 조건   - 한국형 웹 콘텐츠 접근성 지침(KWCAG)      인식의 용이성            대체 텍스트       멀티미디어 대체 수단       명료성           운용의 용이성            키보드 접근성       충분한 시간 제공       광과민성 발작 예방       쉬운 내비게이션           이해의 용이성            가독성       예측 가능성       콘텐츠의 논리성       입력 도움           견고성            문법 준수       접근성           - 전자정부 웹 표준 준수 지침      내용의 문법 준수            적절한 문서타입 명시       문법 준수       인코딩 방식 표기           내용과 표현의 분리            마크업 언어를 사용해 웹 문서 구조화       스타일 언어는 표준 문법 준수           동작의 기술 중립성 보장            스크립트의 비표준 문법 확장 배제       대체 텍스트나 정보 제공           플러그인의 호환성            다양한 웹 브라우저에서 호환되는 것 사용           콘텐츠의 보편적 표현            메뉴는 다양한 브라우저에서 접근할 수 있어야 함       웹 사이트를 다양한 인터페이스로 이용할 수 있어야 함           운영체제에 독립적인 콘텐츠 제공            운영체제에 종속적이지 않은 범용적인 포맷을 사용           부가 기능의 호환성 확보            다양한 브라우저에서 사용할 수 있어야 함           다양한 프로그램 제공            다양한 브라우저에서 사용할 수 있어야 함       윈도우, 리눅스, 맥킨토시 중 2개 이상의 운영체제를 지원해야 함               3. UI 설계 도구 – A      UI의 화면 구조나 화면 배치 등을 설계할 때 사용하는 도구   기획단계에서 미리 보여주기 위한 용도   - 와이어프레임(Wireframe)      페이지에 대한 개략적인 레아아웃이나 UI 요소 등에 대한 뼈대 설계   페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계   레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용   툴 : 손그림, PPT, 키노트, 스케치, 일러스트, 포토샵 등   - 목업(Mockup)      와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형   실제로 구현되지는 않음   툴 : 파워 목업, 발사믹 목업 등   - 스토리보드(Story Board)      와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가   최종적으로 참고하는 작업 지침서, 서비스 구축을 위한 모든 정보 포함   상단이나 우측에는 제목, 작성자 기입, 좌측에는 UI화면, 우측에는 Description 기입   Description은 명확하고 세부적으로 작성   툴 : PPT, 키노트, 스케치, Axure 등   - 프로토타입(Prototype)      와이어프레임이나 스토리보드 등에 인터렉션을 적용한 동적인 형태의 모형   작업자 간 서비스 이해를 위해 작성하는 샘플   페이퍼 프로토타입과 디지털 프로토타입으로 나뉨   툴 : HTML/CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등   - 유스케이스(Use Case)      사용자 측면에서의 요구사항   사용자의 요구사항을 파악해 초기에 기능적인 요구를 결정하고 그 결과를 문서화할 수 있음   자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것. 다이어그램 형식으로 묘사   유스케이스 다이어그램이 완성되면, 명세서 작성       4. UI 요구사항 확인 – B      새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해서 작성하는 단계   목표 정의 -&gt; 활동사항 정의 -&gt; UI 요구사항 작성 -&gt; 요구사항 요소 확인 -&gt; 정황 시나리오 작성 -&gt; 요구사항 작성       5. 품질 요구사항 – B      요구사항이 얼마나 충족하는가를 나타내는 S/W 특성의 총체   품질은 사용자의 요구사항을 충족시킴으로써 확립   ISO/IEC 9126            품질 특성과 평가를 위한 표준 지침       품질에 대한 요구사항을 기술하거나 품질 평가 등에 사용       기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성           호환성과 보안성을 강화하여 ISO/IEC 25010으로 개정            기능적합성, 신뢰성, 사용성, 실행효율성, 유지보수성, 이식성, 호환성, 보안성           - 기능성(Functionality)      사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부   적절성/정합성(Suitability) : 적절한 기능을 제공   정밀성/정확성(Accuracy) : 결과를 정확하게 산출   상호 운용성(Interoperability) : 서로 어울려 작업   보안성(Security) : 접근을 권한에 따라 허용하거나 차단   준수성(Compliance) : 표준, 관례 및 규정을 준수   - 신뢰성(Reliability)      요구된 기능을 정확하고 일관되게 오류 없이 수행   성숙성(Maturity) : 고장을 피해감   고장 허용성(Fault Tolerance) : 고장 시 규정된 성능 수준을 유지   회복성(Recoverability) : 고장 시 다시 회복하고 데이터를 복구   - 사용성(Usability)      사용자가 정확하게 이해하고 사용하며, 다시 사용하고 싶은 정도   이해성(Understandability) : 사용자가 이해할 수 있는 능력   학습성(Learnability) : S/W를 학습할 수 있도록 하는 능력   운용성(Operability) : 운용하고 제어할 수 있도록 하는 능력   친밀성(Attractiveness) : 다시 사용하고 싶어 하도록 하는 능력   - 효율성(Efficiency)      할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도   시간 효율성(Time Behaviour) : 적절한 반응 시간 및 처리시간, 처리율 제공   자원 효율성(Resource Behaviour) : 적절한 자원의 양과 종류를 제공   - 유지 보수성(Maintainability)      환경의 변화에서 S/W를 개선하거나 확장할 수 있는 정도   분석성(Analyzability) : 수정될 부분의 식별을 가능하게 하는 능력   변경성(Changeability) : 변화로 인한 수정 등을 쉽게 구현   안정성(Stability) : 변경으로 인한 예상치 못한 결과를 최소화하는 능력   시험성(Testability) : 변경이 검증될 수 있는 능력   - 이식성(Portability)      다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도   적용성(Adaptability) : 다른 환경으로 변경될 수 있는 능력   설치성(Installability) : 임의의 환경에 설치할 수 있는 능력   대체성(Replaceability) : 다른 S/W를 대신하여 사용될 수 있는 능력   공존성(Co-existence) : 다른 S/W와 공존할 수 있는 능력       6. UI 프로토타입 제작 및 검토 – A   - UI 프로토타입 개요      프로토타입은 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적 형태의 모형   테스트 가능   간단하게 만들어야 함   핵심 기능만을 제공하지만, 필요한 기능은 반드시 포함   요구사항이 모두 반영될 때까지 개선, 보완   실제 사용자를 대상으로 테스트   - UI 프로토타입 장단점      장점            설득, 이해 쉬움       혼선 예방으로 개발 시간 단축       사전 오류 발견           단점            반복적인 개선작업으로 작업 시간 증가, 필요이상으로 자원 소모       중요한 작업 생략될 수 있음           - 프로토타이핑 종류      페이퍼 프로토타입(Paper Prototype)            아날로그적 방법, 손으로 직접 작성       제작기간이 짧고, 업무 협의가 빠른 경우 사용       장점                    비용 저렴           대화하면서 생성 가능           즉시 변경 가능           고객이 과다한 기대 안함                       단점                    테스트하기 부적당           상호 관계가 많은 경우 나타내기 복잡           여러 사람들에게 나눠주거나 공유하기 어렵다                           디지털 프로토타입(Digital Prototype)            프로그램을 사용하여 작성       재사용이 필요한 경우, 숙련된 전문가가 있을 경우 사용       장점                    최종 제품과 비슷하게 테스트           수정 쉬움           재사용 가능                       단점                    프로그램의 사용법을 알아야 함                           - UI 프로토타입 제작 단계      요구사항 분석   개발할 시스템의 핵심적인 기능을 페이퍼/디지털 방식으로 작성   사용자가 확인하는 단계, 추가 및 수정 의견 제안   수정과 합의가 이루어짐       7. UI 설계서 작성 – B   - UI 설계서 개요      UI 설계를 구체화하여 작성하는 문서. 대표적인 화면들을 설계   원활한 의사소통을 위해 작성   - UI 설계서 표지 작성      혼동되지 않도록 프로젝트명 또는 시스템명을 포함   - UI 설계서 개정 이력 작성      UI 설계서가 수정될 때마다 어떤 부분이 수정되었는지 정리해 놓은 문서   - UI 요구사항 정의서 작성      사용자의 요구사항을 확인하고 정리한 문서   - 시스템 구조 작성      전체 시스템의 구조를 설계한 것   - 사이트 맵 작성      사이트에 표시할 콘텐츠를 한 눈에 알아 볼 수 있도록 메뉴별로 구분하여 설계한 것   - 프로세스 정의서 작성      프로세스들을 작업 진행 순서에 맞춰 정리한 것   UI 전체적인 흐름 파악 가능   - 화면 설계      필요한 화면을 페이지별로 설계   와이어프레임을 대략적으로 스케치   주요 흐름을 스토리보드 형태로 작성   - UI 화면 설계의 기본 구성 요소      윈도우, 메뉴, 아이콘, 포인터       8. UI 상세 설계 – B      실제 구현을 위해 모든 화면에 대한 자세한 설계를 진행하는 단계. 반드시 시나리오 작성   최종 목표를 달성하기 위한 방법이 순차적으로 묘사   - UI 시나리오 문서 작성 원칙      구체적으로 작성. Tree 구조 또는 Flow Chart 표기법으로 작성   공통적으로 적용될 UI 요소와 인터렉션을 일반 규칙으로 정의   레이아웃과 속할 기능 정의   인터렉션의 순서, 분기, 조건, 루프 등을 명시   예외 상황에 대비한 다양한 케이스 정의   기능별 상세 기능 시나리오를 정의   UI 시나리오 규칙을 지정   - UI 시나리오 문서 작성을 위한 일반 규칙      주요 키의 위치와 기능   공통 UI 요소   기본 스크린 레이아웃   기본 인터랙션 규칙   공통 단위 태스크 흐름   케이스 문서   - UI 요소      체크 박스 : 1개 이상의 값을 선택할 수 있는 버튼   라디오 버튼 : 하나만 선택할 수 있는 버튼   텍스트 박스 : 데이터를 입력하고 수정할 수 있는 상자   콤보 상자 : 지정된 목록 상자에 내용을 표시하여 선택하거나 새로 입력할 수 있는 상자   목록 상자 : 콤보 상자와 같이 목록을 표시하지만 새로운 내용을 입력할 수 없음   - UI 시나리오 문서의 요건      완정성(Complete)   일관성(Consistent)   이해성(Understandable)   가독성(Readable)   수정 용이성(Modifiable)   추적 용이성(Traceable)   - UI 시나리오 문서로 인한 기대 효과      오류 감소   재작업 감소, 혼선 최소화   불필요한 기능 최소화   개발 비용 절감   개발 속도 향상  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp2/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-3. 애플리케이션 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 소프트웨어 아키텍처 – A   - 소프트웨어 아키텍처의 설계      골격이 되는 기본 구조, 시스템의 구조 또는 구조체   원칙과 지침, 의사소통 도구   비기능적 요구사항의 제약 반영, 기능적 요구사항을 구현하는 방법을 찾는 과정   분할 방법, 모듈에 할당될 기능, 모듈 간의 인터페이스 등 결정   - 모듈화(Modularity)      성능을 향상시키거나 수정 및 재사용, 유지관리 등을 위해 기능들을 모듈 단위로 나누는 것   자주 사용하는 것들을 공통 모듈로 구성하여 재사용성 향상   크기를 작게 나누면 통합 비용이 많이 듦   크기를 크게 나누면 모듈 하나의 개발 비용이 많이 듦   - 추상화(Abstraction)      전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화   유사한 모델을 만들어서 여러 가지 요인들을 테스트   최소의 비용으로 실제 상황에 대처, 구조 및 구성을 대략적으로 파악   과정 추상화            전반적인 흐름만 파악할 수 있게 설계           데이터 추상화            데이터 구조를 대표할 수 있는 표현으로 대체           제어 추상화            이벤트 발생을 대표할 수 있는 표현으로 대체           - 단계적 분해(Stepwise Refinement)      하향식 설계 전략. 상위의 중요 개념으로부터 하위의 개념으로 구체화   추상화의 반복에 의해 세분화   기능에서부터 시작해 알고리즘, 자료구조 등 상세한 내역을 뒤로 미뤄 진행   - 정보 은닉(Information Hiding)      정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법   필요한 정보만 인터페이스를 통해 주고 받음   모듈을 독립적으로 수행할 수 있음   모듈이 변경되더라도 다른 모듈에 영향을 주지 않아 수정, 시험, 유지보수 용이   - 소프트웨어 아키텍처의 품질 속성      시스템 측면            성능, 보안, 가용성, 기능성, 사용성, 변경용이성, 확장성 등           비즈니스 측면            시장 적시성, 비용과 혜택, 예상 시스템 수명 등           아키텍처 측면            개념적 무결성, 정확성, 완결성, 구축 가능성 등           - 소프트웨어 아키텍처 설계 과정      설계 목표 설정 -&gt; 시스템 타입 결정 -&gt; 아키텍처 패턴 적용 -&gt; 서브시스템 구체화 -&gt; 검토       2. 아키텍처 패턴 – A   - 아키텍처 패턴의 개요      아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식   S/W 시스템의 구조를 구성하기 위한 기본적인 윤곽   서브시스템들과 그 역할이 정의, 관계와 여러 규칙, 지침 등이 포함   아키텍처 스타일 또는 표준 아키텍처라고도 함   - 레이어 패턴(Layers pattern)      시스템을 계층으로 구분   상위 계층은 서비스 제공자, 하위 계층은 클라이언트가 됨   마주보는 두 개의 계층 사이에서만 상호작용   변경 작업 용이   특정 계층만을 교체해 시스템을 개선하는 것이 가능   OSI 참조 모델   - 클라이언트-서버 패턴(Client-Server pattern)      하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성   사용자는 클라이언트와만 의사소통   서버는 항상 대기 상태를 유지   클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고 서로 독립적   - 파이프-필터 패턴(Pipe-Filter Pattern)      데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터 전송   재사용성이 좋고, 추가가 쉬워 확장이 용이   재배치하여 다양한 파이프라인 구축 가능   데이터 변환, 버퍼링, 동기화 등에 주로 사용   Unix의 Shell   - 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)      서브시스템을 3개의 부분으로 구조화   모델(Model) : 핵심 기능과 데이터를 보관   뷰(View) : 정보를 표시   컨트롤러(Controller) : 입력을 처리   별도의 컴포넌트로 분리되어 서로 영향을 받지 않고 개발 작업 수행 가능   여러 개의 뷰를 만들 수 있으므로 대화형 어플리케이션에 적합   - 마스터-슬레이브 패턴(Master-Slave Pattern)      장애 허용 시스템, 병렬 컴퓨팅 시스템   - 브로커 패턴(Broker Pattern)      분산 환경 시스템   - 피어-투-피어 패턴(Peer-To-Peer Pattern)      클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용   - 이벤트-버스 패턴(Event-Bus Pattern)      소스, 리스너, 채널, 버스   - 블랙보트 패턴(Blackboard Pattern)      음성 인식, 차량 식별, 신호 해석   - 인터프리터 패턴(Interpreter Pattern)      프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용       3. 객체지향(Object-Oriented) – A   - 객체지향의 개요      S/W를 개발할 때 객체들을 조립해서 작성할 수 있는 기법   재사용 및 확장 용이, 빠르게 개발할 수 있고 유지보수 쉬움   복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리 지원   사용자와 개발자가 쉽게 이해할 수 있음   - 객체(Object)      데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 S/W 모듈   데이터            객체가 가지고 있는 정보. 속성이나 상태, 분류 등       속성, 상태, 변수, 상수, 자료 구조           함수            객체가 수행하는 기능       메소드, 서비스, 동작, 연산           객체의 특성            독립적으로 식별 가능한 이름       상태는 시간에 따라 변함       상호 연관성에 의한 관계 형성       행위의 특징을 나타낼 수 있음       일정한 기억장소를 가지고 있음           - 클래스(Class)      공통된 속성과 연산을 갖는 객체의 집합   객체들이 갖는 속성과 연산을 정의하고 있는 틀   각각의 객체를 인스턴스, 새로운 객체를 생성하는 것을 인스턴스화   최상위 클래스는 상위 클래스를 갖지 않는 클래스   슈퍼 클래스는 특정 클래스의 부모 클래스   서브 클래스는 특정 클래스의 자식 클래스   - 캡슐화(Encapsulation)      데이터와 데이터를 처리하는 함수를 하나로 묶는 것   인터페이스를 제외한 세부 내용이 은폐   외부 모듈의 변경으로 인한 파급 효과가 적음   재사용 용이   인터페이스가 단순해지고, 객체 간 결합도 낮아짐   - 상속(Inheritance)      부모 클래스의 모든 속성과 연산을 자식 클래스가 물려 받는 것   자식 클래스는 속성과 연산을 다시 정의하지 않고 사용 가능   새로운 속성과 연산을 첨가하여 사용 가능   재사용을 높임   - 다형성(Polymorphism)      메시지에 의해 객체가 연산을 수행할 때, 고유한 방법으로 응답할 수 있는 능력   객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 함   같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 함       4. 모듈 – A   - 모듈의 개요      모듈화를 통해 분리된 시스템의 각 기능. 서브루틴, 서브시스템 등과 같은 의미로 사용   단독으로 컴파일 가능, 재사용 가능   모듈의 기능적 독립성은 하나의 기능만을 수행하고 과도한 상호작용을 배재함으로써 달성   수정하더라도 다른 모듈에 거의 영향을 미치지 않으며, 오류 발생시 쉽게 발견하고 해결 가능   결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 함   - 결합도(Coupling)      모듈간 상호 의존하는 정도   결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음   결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움   – 내용 결합도(Content Coupling)      한 모듈이 다른 모듈이 내부 기능 및 그 내부 자료를 직접 참조하거나 수정   제어가 이동하는 경우   – 공통(공유) 결합도(Common Coupling)      공통 데이터 영역을 여러 모듈이 사용할 때의 결합도   조금의 변경이 모든 모듈에 영향을 미치므로 모듈의 독립성을 약하게 함   – 외부 결합도(External Coupling)      선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도   데이터의 범위를 각 모듈에서 제한할 수 있음   – 제어 결합도(Control Coupling)      다른 모듈 내부의 논리적 흐름을 제어하기 위해 제어신호를 이용하여 통신   다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우   처리 기능이 두 모듈에 분리되어 설계된 경우   하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상 발생   – 스탬프 결합도(Stamp Coupling)      배열이나 레코드 등의 자료 구조가 전달될 때의 결합도   동일한 자료 구조를 조회하는 경우   – 자료 결합도(Data Coupling)      자료 요소로만 구성될 때의 결합도   가장 바람직한 결합도   - 응집도(Cohesion)      정보 은닉 개념을 확장한 것   모듈이 독립적인 기능으로 정의되어 있는 정도   응집도가 강할수록 품질이 높고, 약할수록 품질이 낮음   – 기능적 응집도(Functional Cohesion)      모든 기능 요소들이 단일 문제와 연관되어 수행될 경우   – 순차적 응집도(Sequential Cohesion)      출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우   – 교환적 응집도(Communication Cohesion)      동일한 입출력을 사용하여 서로 다른 기능을 수행하는 구성요소들이 모였을 경우   – 절차적 응집도(Procedural Cohesion)      다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우   – 시간적 응집도(Temporal Cohesion)      특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우   – 논리적 응집도(Logical Cohesion)      유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우   – 우연적 응집도(Coincidental Cohesion)      각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우   - 팬인(Fan-In) / 팬아웃(Fan-Out)      팬인은 모듈을 제어하는 모듈의 수. 팬아웃은 모듈에 의해 제어되는 모듈의 수   시스템의 복잡도를 알 수 있음   팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있으나, 단일 장애점 발생 가능   팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고 단순화할 수 있는지 검토   시스템 복잡도를 최적화하기 위해 팬인을 높게, 팬아웃은 낮게 설계       5. 코드 – B   - 코드의 개요      자료의 추출을 쉽게 하기 위해 사용하는 기호   신속, 정확, 명료하게 정보 전달   일정한 규칙에 따라 작성   식별기능, 분류기능, 배열기능   - 코드의 종류      순차 코드            1, 2, 3 ..           블록 코드            1001~1100 : 총무부           10진 코드            1000 : 공학, 1100 : S/W 공학           그룹 분류 코드            1-01-001 : 본사-총무부-인사계           연상 코드            TV-40 : 40인치 TV           표의 숫자 코드            120-720-1500 : 두께x폭x길이가 120x720x1500인 강판           합성 코드            KE-711 : 대한항공 711기           - 코드 부여 체계      이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식   유일한 코드 부여하여 식별 및 추출을 용이하게 함   각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 함   코드의 자릿수와 구분자, 구조 등을 상세하게 명시       6. 디자인 패턴 – B   - 디자인 패턴의 개요      세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식   재사용할 수 있는 기본형 코드들이 포함   디자인 패턴을 참고하여 적용하는 것이 더 효율적   Don’t reinvent the wheel   유사한 형태의 다른 패턴으로 변화되는 특징   - 아키텍처 패턴 vs 디자인 패턴                  아키택처       디자인                       상위수준 설계       하위수준 설계                 전체 시스템 구조 설계       서브시스템에 속하는 컴포넌트들과 그 관계 설계           - 생성 패턴(Creational Pattern)      객체의 생성과 관련된 패턴   객체의 생성과 참조 과정을 캡슐화하여 프로그램에 유연성을 더해줌   – 추상 팩토리(Abstract Factory)      인터페이스를 통해 서료 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현   연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능   – 빌더(Builder)      작게 분리된 인스턴스를 건축 하듯이 조합하여 객체 생성   동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음   – 팩토리 메소드(Factory Method)      객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화   상위클래스에서는 인터페이스 정의하고 실제 생성은 서브 클래스가 담당   – 프로토타입(Prototype)      원본 객체를 복제하는 방법으로 객체를 생성   비용이 큰 경우 이용   – 싱글톤(Singleton)      객체를 생성하면 어디서든 참조할 수 있지만, 여러 프로세스가 동시 참조 불가   클래스 내에서 인스턴스가 하나뿐임을 보장, 불필요한 메모리 낭비 최소화   - 구조 패턴(Structural Pattern)      클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴   구조가 복잡한 시스템을 개발하기 쉽게 도와줌   – 어댑터(Adapter)      인터페이스를 다른 클래스가 이용할 수 있도록 변환   인터페이스가 일치하지 않을 때 이용   – 브리지(Bridge)      서로가 독립적으로 확장할 수 있도록 구성한 패턴   기능과 구현을 두 개의 별도 클래스로 구현   – 컴포지트(Composite)      복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용   객체를 트리구조로 구성   – 데코레이터(Decorator)      객체 간의 결합을 통해 능동적으로 기능들을 확장   부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식   – 퍼싸드(Facade)      상위에 인터페이스를 구성함으로써 서브 클래스의 기능을 간편하게 사용할 수 있도록 함   통합 인터페이스를 제공하는 Wrapper 객체가 필요   – 플라이웨이트(Flyweight)      매번 생성하는 것이 아니고 가능한 한 공유해서 사용해 메모리 절약   다수의 유사 객체를 생성하거나 조작할 때 유용   – 프록시(Proxy)      접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할   네트워크 연결, 메모리의 대용량 객체로의 접근 등에 이용   - 행위 패턴(Behavioral Pattern)      클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의   하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화하도록 도움   – 책임 연쇄(Chain of Responsibility)      객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태   – 커맨드(Command)      요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장   추상 클래스와 구체 클래스로 분리하여 단순화   – 인터프리터(Interpreter)      언어에 문법 표현을 정의하는 패턴   SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용   – 반복자(Iterator)      접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴   내부 표현 방법의 노출 없이 순차적인 접근이 가능   – 중재자(Mediator)      복잡한 상호작용을 캡슐화하여 객체로 정의   객체 사이의 의존성을 줄여 결합도 감소시킴   – 메멘토(Memento)      객체 내부 상태를 객체화함으로써 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공   Ctrl + Z 같은 기능 개발할 때 이용   – 옵서저(Observer)      객체의 상태가 변화하면 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴   분산 시스템 간에 이벤트를 생성, 발행하고, 이를 수신해야 할 때 이용   – 상태(State)      동일한 동작을 다르게 처리해야 할 때 사용하는 패턴   객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리   – 전략(Strategy)      동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴   원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘 변경 가능   – 템플릿 메소드(Template Method)      상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 패턴   코드의 양을 줄이고 유지보수를 용이하게 해줌   – 방문자(Visitor)      데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴   분리된 처리 기능은 각 클래스를 방문하여 수행  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp3/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 1-4. 인터페이스 설계",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외   1. 시스템 인터페이스 요구사항 분석 – B   - 시스템 인터페이스 요구사항 구성      시스템끼리 서로 연동하여 상호작용하기 위한 접속 방법이나 규칙   명세서에는 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 방식, 송신 데이터, 주기 등 포함   - 시스템 인터페이스 요구사항 분석      기능적 요구사항과 비기능적 요구사항으로 분류   요구사항 분석 기법을 적절히 이용   적절한 수준으로 세분화   누락된 요구사항이나 제한조건 추가   상대적 중요도를 평가하여 우선순위를 부여   - 시스템 인터페이스 요구사항 분석 절차      요구사항 선별 -&gt; 요구사항 관련 자료 준비 -&gt; 요구사항 분류 -&gt; 요구사항 분석 및 명세서 구체화 -&gt; 요구사항 명세서 공유       2. 인터페이스 요구사항 검증 – B      요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 베이스라인 설정   검토 계획 수립 -&gt; 검토 및 오류 수정 -&gt; 베이스라인 설정   - 요구사항 검증 방법      요구사항 검토            동료 검토 : 동료들이 결함 발견       워크스루 : 짧은 검토 회의를 통해 결함 발견       인스펙션 : 검토 전문가들이 결함 발견           프로토타이핑   테스트 설계   CASE 도구 활용   - 인터페이스 요구사항 검증의 주요 항목      완전성(Completeness)   일관성(Consistency)   명확성(Unambiguity)   기능성(Functionality)   검증 가능성(Verifiability)   추적 가능성(Traceability)   변경 용이성(Easily Changeable)       3. 인터페이스 방법 명세화 – B   - 시스템 연계 기술      DB Link : DB Link 객체를 이용하는 방식   API/Open API : DB에서 데이터를 읽어 와 제공   연계 솔루션 : EAI 서버와 송수신 시스템에 설치되는 클라이언트 이용   Socket : 서버는 통신을 위한 소켓을 생성하여 포토 할당하여 클라이언트의 통신 요청 시 연결하여 통신   Web Service : WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스   - 인터페이스 통신 유형      단방향 : 요청만 하고 응답이 없는 방식   동기 : 요청하고 응답이 올때까지 대기   비동기 : 요청하고 다른 작업을 수행하다 응답이 오면 처리   - 인터페이스 처리 유형      실시간 방식 : 요청한 내용을 바로 처리   지연 처리 방식 : 매건 단위로 처리할 경우 비용이 많이 발생할 때   배치 방식 : 대량의 데이터를 처리할 때       4. 미들웨어 솔루션 명세 – A   - 미들웨어의 개념 및 종류      운영체제와 응용프로그램 사이에서 추가적인 서비스를 제공하는 소프트웨어   표준화된 인터페이스 제공하여 데이터 교환에 일관성 보장   - DB(DataBase)      클라이언트에서 원격의 DB와 연결하기 위한 미들웨어   DB를 사용해서 시스템 구축하는 경우 2-Tier 아키텍처라고 함   ODBC, IDAPI, Glue   - RPC(Remote Procedure Call)      응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식   Entera, ONC/RPC   - MOM(Message Oriented Middleware)      메시지 기반의 비동기형 메시지를 전달하는 방식   온라인 업무보다 이기종 분산 데이터 시스템의 데이터 동기를 위해 사용됨   MQ, Message Q, JMS   - TP-Monitor(Transaction Processing Monitor)      온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어   빠른 응답 속도를 유지해야 하는 업무에 사용   tuxedo, tmax   - ORB(Object Request Broker)      객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현   트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음   Orbix, CORBA   - WAS(Web Application Server)      동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어   웹 환경을 구현하기 위한 미들웨어   웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현 가능   WebLogic, WebSphere  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp4/",
        "teaser": null
      },{
        "title": "[HTML] HTML 구조 및 태그",
        "excerpt":"HTML 구조   &lt;!DOCTYPE html&gt;  &lt;!-- 문서의 HTML 버전을 지정 --&gt;  &lt;html&gt;       &lt;!-- 문서의 전체 범위 --&gt;    &lt;head&gt;     &lt;!-- 문서의 정보를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보이지 않는 정보를 작성하는 범위 --&gt;   &lt;/head&gt;    &lt;body&gt;     &lt;!-- 문서의 구조를 나타내는 범위 --&gt;              &lt;!-- 웹 페이지의 보여지는 구조를 작성하는 범위 --&gt;   &lt;/body&gt; &lt;/html&gt;   Head 태그 내부   - meta 태그   &lt;meta charset=\"UTF-8\" /&gt;   &lt;!-- 문자 인코딩 방식 --&gt; &lt;meta name=\"viewport\" content=\"width=xxxx...\" /&gt; &lt;!-- 정보의 종류     정보의 값 --&gt;  &lt;meta /&gt;는 HTML 문서의 제작자, 내용, 키워드 등의 정보를 검색엔진이나 브라우저에 제공       - title 태그   &lt;title&gt;Google&lt;/title&gt; &lt;!-- HTML 문서의 제목을 정의. 웹 브라우저 탭에 표시됨--&gt;       - link 태그   &lt;!-- 관계              경로 --&gt; &lt;link rel=\"stylesheet\" href=\"./main.css\" /&gt; &lt;link rel=\"icon\" htrf=\"./favicon.png\" /&gt;  &lt;link /&gt;는 외부 문서를 가져와 연결할 때 사용. 대부분 CSS 파일       - style 태그   &lt;!-- CSS를 HTML 문서 안에서 작성하는 경우에 사용 --&gt; &lt;style&gt;   div {     color : red;   } &lt;/style&gt;       - script 태그   &lt;script defer src=\"./main.js\"&gt;&lt;/script&gt;  &lt;!-- JS파일 가져오는 경우--&gt; &lt;!-- defer : HTML 구조가 준비된 후에 JS를 해석 --&gt;  &lt;!-- JS를 HTML 문서 안에서 작성하는 경우 --&gt; &lt;script&gt;   console.log('Hello World!!') &lt;/script&gt;   Body 태그 내부   - div 태그   &lt;div&gt;&lt;/div&gt;  &lt;!-- Block, 특별한 의미가 없는 구분을 위한 요소 --&gt;       - h 태그   &lt;h1&gt;제목1&lt;/h1&gt;    &lt;!-- Block, 제목을 의미하는 요소 --&gt; &lt;h2&gt;제목2&lt;/h2&gt;    &lt;!-- 숫자가 작을수록 더 중요한 제목--&gt; &lt;h6&gt;제목6&lt;/h6&gt;       - p 태그   &lt;p&gt;가나 다라마&lt;/p&gt;  &lt;!-- Block, 문장을 의미하는 요소 --&gt;       - img 태그   &lt;!-- 경로              대체 텍스트 --&gt; &lt;img src=\"img/xxx.png\" alt=\"xxx\" /&gt; &lt;!-- Inline, 이미지 삽입 요소--&gt;       - ul, li 태그   &lt;ul&gt;  &lt;!-- Block, 순서가 필요 없는 목록의 집합--&gt;   &lt;li&gt;강아지&lt;/li&gt;    &lt;li&gt;고양이&lt;/li&gt;  &lt;!-- 목록 내 각 항목 --&gt;   &lt;li&gt;돼지&lt;/li&gt; &lt;/ul&gt;       - a 태그   &lt;!-- Inline, 다른/같은 페이지로 이동하는 하이퍼링크 지정하는 요소 --&gt; &lt;a href=\"http://www.google.com\" target=\"_blank\"&gt;Google&lt;/a&gt; &lt;!-- URL                       URL의 표시(브라우저 탭) 위치 --&gt;       - span 태그   &lt;span&gt;가나다&lt;/span&gt; &lt;!-- Inline, 특별한 의미가 없는 구분을 위한 요소--&gt;       - br 태그   &lt;p&gt;가나다라&lt;br/&gt;마바사아&lt;/p&gt; &lt;!--Inline, 줄바꿈 요소--&gt;  가나다라 마바사아       - input 태그   &lt;!--Inline-Block, 데이터를 입력하는 요소--&gt; &lt;input type=\"text\" value=\"xxx\" placeholder=\"yyy\" disabled/&gt;  &lt;!--  타입         입력된 값     힌트            비활성화 --&gt;       - label 태그   &lt;label&gt; &lt;!--Inline, 라벨 가능 요소(input)의 제목--&gt;   &lt;input type=\"checkbox\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"checkbox\" checked /&gt; Cat &lt;/label&gt;   &lt;label&gt; &lt;!-- animals 그룹에서 1개만 입력 --&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Dog &lt;/label&gt; &lt;label&gt;   &lt;input type=\"radio\" name=\"animals\" /&gt; Cat &lt;/label&gt;        - table, tr, td 태그   &lt;table&gt;  &lt;!-- Table, 표 요소, 행과 열의 집합 --&gt;    &lt;tr&gt;   &lt;!-- Table, 행을 지정하는 요소 --&gt;     &lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt; &lt;!-- Table, 열을 지정하는 요소 --&gt;   &lt;/tr&gt;   &lt;tr&gt;     &lt;td&gt;C&lt;/td&gt;&lt;td&gt;D&lt;/td&gt;   &lt;/tr&gt;  &lt;/table&gt;  A B C D  주의! TABLE 요소보다 Grid같은 CSS 기능으로 레이아웃을 작업해야 함   HTML 전역 속성   &lt;태그 title=\"설명\"&gt;&lt;/태그&gt;   &lt;!-- 요소의 정보나 설명을 지정 --&gt; &lt;태그 style=\"스타일\"&gt;&lt;/태그&gt; &lt;!-- 요소에 적용할 스타일 지정 --&gt; &lt;태그 class=\"이름\"&gt;&lt;/태그&gt;   &lt;!-- 요소를 지칭하는 중복 가능한 이름 --&gt; &lt;태그 id=\"이름\"&gt;&lt;/태그&gt;      &lt;!-- 요소를 지칭하는 고유한 이름 --&gt; &lt;태그 data-이름=\"데이터\"&gt;&lt;/태그&gt; &lt;!-- 요소에 데이터를 지정 --&gt;  ","categories": ["HTML"],
        "tags": ["HTML","Web"],
        "url": "/html/frontend-html-structure/",
        "teaser": null
      },{
        "title": "[CSS] CSS 개요",
        "excerpt":"CSS 기본 문법   /* 주석 */ 선택자 {   속성 : 값;   속성 : 값; }   CSS 선언 방식   - 내장 방식   style 태그의 내용으로 스타일 작성   &lt;style&gt;   div {     color: red;     margin: 10px;   } &lt;/style&gt;       - 인라인 방식   요쇼의 style 속성에 직접 스타일 작성   &lt;div style=\"color: red; margin: 10px;\"&gt;&lt;/div&gt;       - 링크 방식   링크 태그로 외부 CSS 파일을 가져와서 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ div {   color: red;   margin: 20px; }       - @import 방식   CSS의 @import 규칙으로 CSS문서 안에서 또 다른 CSS문서를 가져와 연결   &lt;link rel=\"stylesheet\" href=\"./css/main.css\"&gt;  /* main.css */ @import url(\"./sub.css\");  div {   color: red;   margin: 20px; }  /* sub.css */ .sub {   width: 10px;   height: 20px; }   CSS 선택자   - 기본   /* 전체 선택자 : 모든 요소 선택 */ * {   color: red; }  /* 태그 선택자 : 태그 이름의 요소 선택 */ div {   color: red; }  /* 클래스 선택자 : class 속성 값의 요소 선택  */ .cat {   color: red; }  /* 아이디 선택자 : id 속성 값의 요소 선택 */ #cat {   color: red; }       - 복합   /* 일치 선택자 : 선택자를 동시에 만족하는 요소 선택 */ div.cat {   color: red; }  /* 자식 선택자 : 자식 요소 선택 */ ul &gt; .cat {   color: red; }  /* 하위(후손) 선택자 : 하위 요소 선택. 띄어쓰기가 선택자의 기호 */ div .cat {   color: red; }  /* 인접 형제 선택자 : 다음 형제 요소 하나를 선택 */ .cat + li {   color: red; }  /* 일반 형제 선택자 : 다음 형제 요소 모두를 선택 */ .cat ~ li {   color: red; }       - 가상 클래스   /* hover : 마우스 커서가 올라가 있는 동안 */ a:hover {   color: red; }  /* active : 마우스를 클릭하고 있는 동안 */ a:active {   color: red; }  /* focus : 포커스되면 선택 */ /* focus가 될 수 있는 요소는 HTML 대화형 콘텐츠가 해당 */ /* input, a, button, label, select 등 여러 요소 */  /* HTML 대화형 콘텐츠 요소가 아니더라도, tabindex 속성을 사용한 요소도 focus가 될 수 있음 */  input:focus {   color: red; }  /* first-child : 형제 요소중 첫째라면 선택*/ .animals div:first-child {   color: red; }  /* last-child : 형제 요소중 막내라면 선택 */ .animals span:last-child {   color: red; }  /* nth-child : 형제 요소중 n째라면 선택 */ .animals *:nth-child(2) {   color: red; } .animals *:nth-child(2n) {   color: red; } .animals *:nth-child(2n+1) {   color: red; }  /* not : 아닌 요소 선택 */ .animals *:not(div) {   color: red; }       - 가상 요소   /* before : 내부 앞에 내용을 삽입 */ .cat::before {   content: \"앞\" }  /* after 내부 뒤에 내용을 삽입 */ .cat::after {   content: \"뒤\" }       - 속성   /* 속성 : 해당 속성을 포함한 요소 선택 */ [disabled] {   color: red; } [type] {   color: red; }  /* 속성-값 : 해당 속성을 포함하고 값이 x인 요소 선택 */ [type=\"password\"] {   color: red; }   스타일 상속   .animals {   color: red; }  &lt;div class=\"ecosystem\"&gt;생태계   &lt;div class=\"animals\"&gt;동물     &lt;div class=\"cat\"&gt;고양이&lt;/div&gt;     &lt;div class=\"dog\"&gt;강아지&lt;/div&gt;     &lt;div class=\"tiger\"&gt;호랑이&lt;/div&gt;   &lt;/div&gt;   &lt;div class=\"plant\"&gt;식물&lt;/div&gt; &lt;/div&gt;  생태계   동물     고양이     강아지     호랑이      식물       - 상속되는 CSS 속성들   모두 글자/문자 관련 속성들      font-style   font-weight   font-size   line-height   font-family   color   text-align   …       - 강제 상속      값에 inherit 넣어서 명시하면 상속됨   선택자 우선순위      같은 요소가 여러 선언의 대상이 된 경우, 어떤 선언의 CSS속성을 우선 적용할지 결정하는 방법   점수가 높은 선언 우선   점수가 같으면 마지막에 해석된 선언이 우선   body { color : red; } /* 전체 선택자 : 0점 */ * { color : orange; }  div { color : yellow; } /* 태그 선택자 : 1점 */  .cat { color: green; } /* Class 선택자 : 10점 */  #dog { color: blue; } /* ID 선택자 : 100점 */  &lt;div style=\"color: darkblue;\"&gt;Hi&lt;/div&gt; &lt;!-- 인라인 선언 : 1000점 --&gt;  div { color: purple !important; } /* !important : 999999점 */  ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-basic/",
        "teaser": null
      },{
        "title": "[CSS] CSS 박스모델",
        "excerpt":" ","categories": ["CSS"],
        "tags": ["CSS","Web"],
        "url": "/css/frontend-css-properties-boxmodel/",
        "teaser": null
      },{
        "title": "[정보처리기사 필기] 2-1. 데이터 입출력 구현",
        "excerpt":"2020 시나공 정보처리기사 필기책 참고   주의! 중요도가 낮은 항목(C)은 제외  ","categories": ["JCKP"],
        "tags": ["JCKP"],
        "url": "/jckp/etc-jckp5/",
        "teaser": null
      }]
